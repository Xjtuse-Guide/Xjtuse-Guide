# 第十章 虚拟内存管理

> 易俊泉学长原始笔记的链接如下：
>
> [第十章-虚拟内存](docs/课内笔记/大二下/操作系统/笔记/易俊泉/第十章-虚拟内存.md)

## 10.1 Background（背景）

上一章的各种内存管理方法都有一个共性：要求**进程必须全部放入内存才能运行**。但是内存不够怎么办呢？

如果进程大于内存的容量或内存中同时运行多个进程，使用覆盖和动态加载可以缓解，但是需要程序员的额外工作。

解决办法：

- 从物理上扩充内存容量：再买几根内存条，但是受制于主板上的内存条接口数

- 从逻辑上扩充内存容量：通过操作系统四大属性中所谓「虚拟」的概念，把部分磁盘虚拟成内存，缓解内存不足的问题。

  > 回忆：操作系统的四大属性为并发、共享、虚拟、异步，详情请见第一章绪论

常规存储器的特征

- 一次性： 作业在运行前需要一次性的全部装入内存

- 驻留性：作业装入内存后，便一直驻留在内存中，直到作业结束。

正是由于一次性和驻留性，使得程序中**暂时不用的数据占用了大量的内存空间**，从而需要运行的作业无法装入内存。

实际上，一次性不是必须的：

- 程序中通常具有处理异常的代码，但这些代码很少执行
- 数组、链表和表通常都会预先分配比实际使用更大的内存（尤其是数组这种分配完就不能改变大小的）
- 程序的某些功能可能很少使用

由于局部性原理，其实只需要装载当前执行的代码附近的部分内容，就可以保证程序运行了；如果需要未加载的代码，动态从磁盘加载即可。

### 局部性原理

在一段时间内，程序的执行仅局限于某个部分；相应地，它所访问的存储空间也局限于某个区域内。

#### 原因

> 程序在执行时，除了少部分的转移和过程调用指令外，大多数仍是顺序执行的。
>
> 子程序调用将会使程序的执行由一部分内存区域转至另一部分区域
>
> 程序中存在许多循环结构，循环体中的指令被多次执行。
>
> 程序中还包括许多对数据结构的处理，如对连续的存储空间——数组的访问，往往局限于很小的范围内。

#### 局部性表现

局部性表现为： 时间局部性和空间局部性

##### 时间局部性

如果程序中的某条指令一旦执行，则不久的将来该指令可能再次被执行；

如果某个存储单元被访问，则不久以后该存储单元可能再次被访问。

产生时间局限性的典型原因是在**程序中存在着大量的循环操作**。

##### 空间局部性

一旦程序访问了某个存储单元，则在不久的将来，其附近的存储单元也最有可能被访问。 即程序在一段时间内所访问的地址，可能集中在一定的范围内。

其典型原因是程序是顺序执行的。

### 虚拟内存

虚拟内存是一种允许进程部分装入内存就可以执行的技术。内存管理一章中提到了逻辑地址空间和物理地址空间，二者在上一章中一般是大小相等的。而虚拟内存就是让逻辑地址空间大于物理地址空间。

虚拟内存依据为局部性原理 : 时间局部性，空间局部性 

使用虚拟内存时，程序会认为逻辑地址空间比实际物理地址空间大（多余的空间其实是磁盘上虚拟出来的）

必须允许页面能够被换入和换出

![image-20211104143034642](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211104143034642.png)

程序所能看到的内存空间为虚拟内存空间。当程序试图访问自己空间内的某块内存时，先通过内存表查找这块内存在物理内存中的位置。如果找到了，则直接从内存读取；否则从磁盘读取相应内容，并将其同时存储到物理内存中。

#### 虚拟内存离散分配

虚拟存储建立在**离散分配**的存储管理基础上。因此，其内存管理方式可以采用分页式或者分段式，但不能使用连续分配方式。

请求页式；在基本分页的基础上，增加了请求调页和页面置换功能后形成的页式虚拟存储系统。需要硬件和软件支持。

请求段式：和请求页式类似。

#### 特征

离散性:在内存分配时采用离散的分配方式，是虚拟存储器的**最基本的特征**。

多次性:一个作业被分成多次调入内存运行，即**在作业运行时没有必要将其全部装入，只须将当前要运行的那部分程序和数据装入内存即可**。是虚拟存储器最重要的特征。

对换性:作业运行过程中信息在内存和外存的对换区之间换进、换出。

> 此处的对换是以页面为单位的（而不是之前中程调度中以进程为单位），粒度更小

虚拟性:**从逻辑上扩充内存容量**，使应用程序所看到的内存容量远大于实际内存容量。

#### 好处

- 可在较小的可用内存中执行较大的用户程序

- 可在内存中容纳更多程序并发执行

- 是操作系统层面提供的支持，简化了编程操作， 不影响编程时的程序结构（与动态加载技术比较）

- 提供给用户可用的虚拟内存空间通常大于物理内存(real memory)

#### 需要解决的问题

:question:程序部分运行可以吗?

> 取页--将所需的部分装入内存

:question:发现程序不在内存时,如何将其装入后继续运行?

> 请求调页—缺页时，产生**缺页中断**（暂停用户程序执行，切换到系统态），将外存上的页调入内存，之后用户程序继续执行

:question: 内存无空间时怎么办?

> 页面**置换**(换的不是一个进程，而是一个页)--内存不足时，将哪些页换出内存

### 虚拟内存所需的两个功能

- 请求调页：用户程序访问的内容不在内存时，从磁盘调入内容
- 页面置换：内存完全满时，决定新调入的页替换内存中的哪一页

下面将详细说明这两个功能。



## 10.2 Demand Paging（请求调页）

### 页面调入策略

#### 预调页策略

主动的页面调入策略，即把那些预计很快会被访问的程序或数据所在的页面，预先调入内存。

预测的准确率不高（50%），**主要用于进程的首次调入**。也有的系统将预调页策略用于请求调页

#### 请求调页策略

当进程在运行中发生缺页时，由系统将缺页调入内存，**目前虚拟存储器系统大多采用此策略。**在调页时须花费较大的系统开销，如需频繁启动磁盘I/O。

:question:从何处调入页面

在虚拟存储系统中，**外存（硬盘）被分成两部分:文件区和对换区**。对换区（连续分配）的磁盘I/O速度比文件区（离散分配）要高。

> :one: 从文件系统中调入页面
>
> :two: 从交换区中调入页面：交换区没有创建磁盘系统，因此读写速度较快

UNIX 系统的做法:

对于从未运行过的页面，都从硬盘文件区(可执行文件)调入

对于被换出的页面，从对换区调入

> 在安装 Ubuntu 时，可以可选的在磁盘上创建一个「Swap」分区，这个分区就是对换区

对于共享页面，该页面可能已由其它进程调入内存，此时就无须再从对换区调入，直接从内存中使用即可。

每个作业有一个页表，还有一个与之对应的磁盘描述项

### 基本概念

请求调页中的硬件支持：

可以说：`请求分页存储管理=基本分页+请求调页功能+页面置换功能`

**1）页表机制**

它是在纯分页的页表机制上形成的，由于只将应用程序的一部分调入内存，还有一部分仍在磁盘上，故需在页表中再增加若干项，供程序(数据)在换进、换出时参考。在请求分页系统中的每个页表项如图所示：

![image-20211104150451591](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211104150451591.png)

> **状态位（存在位P）**：用于指示该页是否已调入内存，供程序访问时参考。
>
> **物理块号**：一般页表也需要记录的内容，记录本页在内存中的物理地址首地址
>
> **访问字段A**：用于记录本页在一段时间内被访问的次数，或最近已有多长时间未被访问，提供给页面置换算法选择换出页面时参考。
>
> **修改位M**：表示该页在调入内存后是否被修改过。由于内存中的每一页都在外存上保留一份副本，因此，若未被修改，在置换该页时就不需将该页写回到外存上，以减少系统的开销和启动磁盘的次数；若已被修改，则必须将该页重写到外存上，以保证外存中所保留的始终是最新副本。--->提高性能
>
> **外存地址**：用于指出该页在外存上的地址，通常是物理块号，供调入该页时使用。

**2）缺页中断机制**

请求分页系统中，每当所要访问的页面不在内存时，便要产生一缺页中断，请求OS将所缺页调入内存。与一般中断的**主要区别在于**：

- 缺页中断在指令**执行期间**产生和处理中断信号，而一般中断在一条指令**执行完后**检查和处理中断信号。

  这是因为缺页中断在指令执行期间，发现没有所需内存块时立刻产生，并需要被立刻处理，否则当前指令无法继续执行。

- 缺页中断返**回到该指令的开始**重新执行该指令，而一般中断返回到该**指令的下一条指令**执行。

  这是因为缺页会导致当前指令无法完成；缺页中断结束（页面被调入内存后），必须重新执行当前指令。

- 一条指令在执行期间，可能产生多次缺页中断。

缺页中断属于软件中断类的“故障”，是不可屏蔽的中断。

**3）地址变换机制**

在每一个页表的表项有一个有效- 无效位相关联，1 表示在内存，0 表示不在内存

![image-20211104151029617](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211104151029617.png)

:one: 查找页表来确定此次地址访问是否合法

:two: 如果不合法,则中止该进程; 否则如果有效但不在内存，即发生了缺页（页表有效位显示该位置无效）,则需要将其调入内存。发起缺页中断，陷入系统态。

:three: 所需页在外存，操作系统找到该页

:four: 找到一个空闲物理块，启动磁盘,把该页读入内存

:five:读磁盘结束后,修改页表的有效位，以指出该页已在内存中

:six: 重新开始执行刚才发生缺页中断的指令,这时它可以访问刚才调入的页



## 10.3 请求调页的性能

缺页中断中主要的动作包含：

> 处理缺页中断
>
> **从磁盘读入所需的页——最大的时间开销**
>
> 重新开始被中断的进程

### 缺页率

假定作业 Ji 共有 m 页，系统分配给它的主存块为 n 块，这里 m>n。（因此一定会发生缺页）

如果作业 Ji 执行过程中总的内存访问次数为 A , 成功访问的次数为 S，不成功的访问次数为 F(产生缺页中断的次数),则:

显然可以发现：A=S+F

**缺页率**: p=F/A （缺页次数占总访问次数的百分比）

缺页率是评价后续提到的页面置换算法的指标。缺页率越低越好。

**有效访问时间**：

EAT = (1 – *p*) x memory access \+ *p* (page fault overhead\+ [swap page ] \+ [restart overhead])

p: 缺页率

即有效访问时间 = 不缺页的概率 \* 内存访问时间 + 缺页概率 \*（查找页表 +交换页+重新执行指令时间）

这个公式和计组计算缓存加入后平均访问时间的公式很相似，相当于计算了访问时间的数学期望。



## 10.4 页面置换

当内存已经没有空闲空间，但是仍然有页面需要进入内存时，会发生页面置换。操作系统对于页面置换有多种选项：

- 终止用户进程（代价较大）

- 进行中级调度（交换部分进程到外存，降低多道程序的道）

  这种方法需要换出整个进程，代价仍然较大

- 换出内存中使用较小的页（一般采用此方法）

页面置换：找到内存中没有真正使用的一些页，将其换出到磁盘上。

需要找出一个令缺页率最低的置换算法。

具体步骤：

- 找到所需页在磁盘上的位置
- 如果内存仍有剩余空间，直接加载页到内存中，相当于一般的请求调页；否则，利用*页面置换算法*寻找内存中的某页，将该页换出到磁盘，再加载新页到内存中
- 更新页表

![image-20211104152959536](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211104152959536.png)

上方图片描述了这一步骤：先换出某个内存（并修改页表对应状态位为无效），再换入需要的页，再次修改页表的有效位。

如果没有空闲帧，需要两个页面传输，一个换出，一个换入。

可以通过记录修改位来降低额外开销。如果某页在读入内存后没有被修改过，就不需要换出此页到磁盘，直接覆盖即可

置换实现了逻辑内存和物理内存的划分—在一个较小的物理内存基础之上可以提供一个大的虚拟内存.

![image-20211104153315925](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211104153315925.png)

上图是请求调页+页面置换两个步骤连续的流程图。

> CPU 检索快表 TLB，相当于页表的高速缓存

## 10.5 页面置换算法【计算题】

页面置换算法负责决定需要换出内存页时，到底选择哪一页。

如果页面刚刚被换出又需要被调入，就会导致性能下降（本来可以不换出此页的）。因此，最佳的方法应当是「选择换出后，最长时间不会使用的页」。「最佳算法」实现了此要求。

主要评价标准：缺页率。使用置换算法后，缺页率越低越好

通过运行一个内存访问的特殊序列，计算这个序列的缺页次数，得到其缺页率

访问序列是

> 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5
>
> 7,0,1,2,0,3,0,4,2,3,0,3,2,1,2,0,1,7,0,1

### 最佳算法（OPT)

被置换的页**将是之后最长时间**不被使用的页

> 注意最长时间不被访问和之后被访问次数最少是不同的概念

![image-20211109164334301](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211109164334301.png)

缺点：「**你怎么知道？**」

在测试序列中，我们可以得知当前时刻之后哪一页最长时间不被使用；但由于现实中不可能预知未来，此算法无法用于实际。

### 先进先出算法 FIFO

换出最早进入内存的页面。

![image-20211109142833593](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211109142833593.png)

FIFO 算法的性能不好，因为它没有考虑页面的访问频率（局部性原理），只考虑页面进入内存的时间。

### 最近最久未使用 LRU

使用离过去最近的情况作为不远将来的近似，选择最近最少使用的页进行置换。

LRU 选择**最长时间没有使用的页**。

> 可以通过观察得到最久没有使用的页，或者用计组讲的计数器方法计算

最接近 OPT，是除了 OPT 外性能最好的算法。

![image-20211109164649965](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211109164649965.png)

实现该算法需要硬件支持，记录物理帧的使用情况，需要使用到计数器或者栈

> 每一个页表项 有一个计数器，每次页通过这个表项被访问，把记录拷贝到计数器中。当一个页需要置换时，查看计数器来决定置换哪一个页

### LRU 近似算法

想使用 LRU 但是没有足够的硬件支持的话，可以使用该算法

**访问位**：每个位都与一个位相关联，初始值为 0，当页被访问时设置为 1。

如果需要置换，优先换出置换位为 0 的页。不足：没有考虑到页面是多久之前访问的；上次访问太早的页面可能没有存储意义了。

解决方案：**二次机会(clock)**

如果将要（以顺时针）交换某页的访问位是 1，则

- 把访问位设为 0

- 把此页留在内存中

- 以同样的规则，替换下一个页，直到找到一个访问位是 0 的位或者轮完一圈

如果所有页的访问位都是 1，此算法就退化为 FIFO 算法。

![image-20211222160301633](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211222160301633.png)

==以下内容没有在网课中出现：==

**增强的二次访问**

不仅考虑页面的使用情况，还考虑置换代价

选择淘汰页面时，既要是未被访问的，还要是未被修改的页面。

实现：设置两位

>    访问位（A）， 修改位（M）
>
>    启动一个进程时，A、M置0
>
>    A被定期清零

内存中的所有页面被分成为四类:

> 第0类：无访问，无修改(A=0,M=0)
>
> 第1类：无访问，有修改(A=0,M=1)
>
> 第2类：有访问，无修改(A=1,M=0)
>
> 第3类：有访问，有修改(A=1,M=1)

OS首先寻找第0类页面，将找到的第一个页面淘汰；

若没找到，则找第1类页面，将找到的第一个页面淘汰，并将扫描过的页面的A位全部置为0；

若没找到，则指针回到开始位置，将所有的A位置为0。然后重复第一步。

### 其他算法

LFU ：最少使用算法：置换计数器值最小的一个页，即访问次数最少的页

MFU ：最常使用算法，认为：最小计数的页也许刚刚被换入和使用，所以置换计数器值最大的页

==以上内容没有在网课中出现==



## 10.6 页帧的分配 Allocation of Frames

如何给进程分配一定的空闲内存？需要关注以下两点：

1. 分配页数不少于足够进程运行的最少页数

   - 保证进程正常运行所需的最小物理块数

   - 若系统为某进程所分配的物理块数少于此值时，进程将无法正常运行(频繁发生缺页)

   - 这个数目取决于指令的格式、功能和寻址方式。

   比如，IBM 370 执行 SS MOVE 指令时，至少需要 6 页。

2. 常见的分配策略

   - 平均分配：每个进程获得的页数相同

     比如存在 100 个帧，5 个进程，那么每个进程都获得 20 个帧

   - 按比例分配：根据每个进程的大小比例来分配

   - 优先分配：根据进程的优先级分配

3. 固定分配：每个进程拥有的物理帧数量保持不变

   可变分配：每个进程拥有的物理帧数量可以随着进程需求发生变化。

某个进程结束后，其拥有的帧会释放给其他进程。

### 全局替换与局部替换

有空闲帧时可以从空闲帧链表中选择一个帧分配，当没有空闲帧可用时，从哪里分配帧？

**全局替换**

进程在所有的页中选择一个替换页面；一个进程可以从另一个进程中获得页面。

**局部替换**

每个进程只从属于它自己的页中选择被换出的页

局部置换时，分配给每个进程的帧的数量不变（换入的帧只能换入到自己换出的帧中）

全局置换时，进程的帧数量会增加，但是无法控制缺页率（被抢夺页的进程需要新页时，还需要抢夺其他进程的页，导致缺页率增加）

相对而言，**全局替换会带来较高的系统吞吐率**



固定分配+局部替换：每个进程分配相同数量的物理块，且采用局部替换，保证进程拥有的物理块数永远不变

缺点：难以确定进程需要的物理块数量；太少会导致频繁缺页，太多会导致 CPU/内存 利用率不高

可变分配＋全局替换：进程分配一定物理块，操作系统保存一个空闲物理块队列；当进程缺页时：

- 操作系统优先从空闲物理块队列中选择一块分配给进程
- 如果空闲物理块队列已空，从内存中选择一页调出，此页可能是任何进程的页

可变分配+局部替换：进程分配一定物理块，在运行时可以增加/减少自己拥有的物理块，但发生缺页时，只能选择自己进程中的某页换出。

如果某个进程频繁发生缺页，操作系统会额外分配一些物理块；如果某个进程的内存利用率较低，操作系统会剥夺一部分物理块。

没有固定分配+全局替换，可能是因为全局替换会导致各个进程物理块数目发生变化，不固定了。

## 10.7 Thrashing（颠簸/抖动）

上一节中提到，帧分配时必须为每个进程分配不少于其要求最小数量的帧。如果进程分配到的帧数量小于计算机体系结构所要求的最小数量，那么必须暂停进行执行。并将其置换出去，使其所有分配帧空闲。

为什么不允许这样的进程执行呢？

如果进程没有获得足够数量的帧，那么很快会出现缺页，此时需置换某个页，然而，其所有页都在使用，置换出去的页立刻又需要置换进来，因此，会不断的产生缺页。

**这种频繁的调页行为称作颠簸，也叫抖动。**

> 明确定义：**一个进程的页面经常换入换出，花在换页上的时间要大于进程执行时间**，则该进程处于颠簸状态

抖动：刚被换出的页很快又被访问，需重新调入，导致系统频繁地交换页面，以致大部分 CPU 时间花费在完成页面置换的工作上。这样会造成 **CPU 利用率低下**。

操作系统可能会发现 CPU 利用率下降，认为这是多道程序的道不足，增加新的程序进入内存，这又加剧了抖动。

:star2: **全局置换会造成和加剧颠簸；局部置换能限制系统颠簸，但是也会增加进程的有效访问时间，因此应该给进程足够的帧以从根本上防止颠簸**

颠簸的发生本质上是因为程序所需内存的和 > 物理内存的大小。

### 工作集

工作集思想可以用于确定程序运行最少所需的帧。

工作集理论是在 1968 年由 Denning 提出来的。它正是基于局部的假设。

基本思想：

> 根据程序的局部性原理，进程在一段时间内总是集中访问一些页面(活跃页面).
>
> 如果分配给一个进程的物理块数太少了，使该进程的活跃页面不能全部装入内存，则进程在运行过程中将频繁发生缺页
>
> 如果能为进程提供与活跃页面数相等的物理块数，则可减少缺页中断次数，且保证内存的利用率较高

工作集是指在**一段时间内**访问的所有页面。这个「一段时间」就是工作集窗口。

<font color="red">工作集窗口（Δ）</font>是指对于给定的访问序列选取定长的区间，落在工作集窗口中的页面集合称为工作集。工作集中包含的页面视为活跃的页面；操作系统应当给进程分配不少于工作集中包含页面数量的物理页。

总需求是指所有运行中进程的工作集大小之和。操作系统应当分配不小于总需求数量的页面。如果无法提供这么多页面，就可能出现抖动。

正确选择<font color="red">工作集窗口（Δ）</font>的大小，对存储器的有效利用和系统吞吐量的提高，都将产生重要的影响。

![image-20211222162835820](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211222162835820.png)



工作集合精确度与Δ的选择有关。

> 如果Δ 太小，则不能包含整个局部，仍然容易引发颠簸
>
> 如果Δ 太大，则可能包含多个局部，对内存需要太大
>
> 如果Δ 为无限大，则工作集合就是进程执行所需的所有页的集合

如果当前进程工作集所需页数的和大于物理内存大小，那么可能出现颠簸，操作系统需要暂停一个进程（降低多道的度），以防止抖动。

具体实现：

> OS 跟踪每个进程的工作集，并为其分配大于其工作集的物理块数。
>
> 如果还有空闲物理块，则可启动另外的进程。
>
> 如果所有进程的工作集之和超过了可用物理块的总数，则OS会选择暂停一个进程，该进程被换出，所释放的物理块可分配给其他进程。

其困难在于如何跟踪工作集合（一般采用定时器中断和引用位实现）

## 10.8 其他考虑

目前页大小由系统决定，用户程序无法控制；不过，在设计新的操作系统时，我们仍然需要考虑每个内存页面应当设置为多大。

> 页面大，则内碎片大
>
> 页面小，则页表占用的空间大
>
> I/O overhead（I/O开销）磁盘I/O时间中传输时间和数据量有关系，但它占的比例很小，而寻道时间和旋转延迟时间占了很大的比例。所以页面尺寸比较大会有利于减少磁盘I/O时间。 
>
> 减少I/O及内存的占用：要求页面尺寸小 ，采用小页，总的I/O就会降低，因为小页能够更精确的匹配局部
>
> 减少缺页率：要求页面尺寸大
>
> 总的趋势：**页面尺寸越来越大，这是由于CPU速度和内存容量的增长超过了磁盘速度的加快**（真的不考虑 SSD 么）
>
> TLB 命中率越高，性能越好；而 TLB 的命中率取决于大小，增加其大小即可增加命中率。
>
> 此外，也可以增加 TLB 范围（能通过 TLB 访问到的内存总容量），可以通过增加页大小来增加 TLB 范围。

即：

页面较小：内碎片小，但是页表占用空间大，I/O 时间长

页面较大：页表占用空间小，I/O 时间短，但是每次 I/O 的数量高，速度更慢，而且内碎片大。

I/O 时间主要决定于 I/O 次数而不是数据传输量，因此页面较大时，虽然数据传输量大，但是 I/O 次数很少，导致总体来看 I/O 时间还是较短的。
