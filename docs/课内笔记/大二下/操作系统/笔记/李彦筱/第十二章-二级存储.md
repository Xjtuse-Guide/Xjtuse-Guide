

# 第十二章 二级存储

> 易俊泉学长原始笔记的链接如下：
>
> [第十二章-二级存储](docs/课内笔记/大二下/操作系统/笔记/易俊泉/第十二章-二级存储.md)

## 12.1 磁盘结构

磁盘组：由若干磁盘组成，绕枢轴高速旋转，目前主流磁盘转速7200转/分

物理记录定位：

> 柱面（磁道）号：各盘面所有的读写头同时移动，并定位在同样的垂直位置的磁道上，这些磁道形成了一个柱面。由外向内是：0，1，2，……，L。（柱面号其实就是磁道号）
>
> 磁头号：磁盘的全部有效盘面从上到下依次编号：0,1,2,……,H。磁头号与盘面号是相对应的。
>
> 扇区号：将各盘面分割成若干大小相等的扇区，编号：0,1,2,3,……,n

磁盘设备是以一种逻辑块的一维大数组的形式编址的，这里的逻辑块是传输的最小单位。

逻辑块的一维数组映射到磁盘上一些相连的扇区。

> 0 扇区是最外边柱面的第一个磁道的第一个扇区，也就是首个扇区，一般用于存放主引导记录（MBR）。
>
> 数据首先都映射到一个磁道，其余的数据映射到同一柱面的其他磁道，然后按照从外向里的顺序映射到其余的柱面。

盘块的物理地址由柱面号、磁头号、扇区号三部分组成。

磁盘空间以盘块为基本访问单元，为方便使用，应将三维的盘块物理地址转换为一维的盘块号。

**三维地址到一维的转换**

设L，M，N分别为盘组的柱面数、盘面数、扇区数，B表示块号，则第i柱面、j磁头、k扇区所对应的块号B为：

  B=（ i×M ×N）+（ j ×N）+k，其中i=0，…,L-1; j=0,…,M-1; k=0, …, N-1

根据块号B也可以确定该块在磁盘上的物理位置.

> 柱面号: i=int (B, M ×N)
>
> 磁头号：j=int (mod(B, M ×N), N)
>
> 扇区号：k=mod ( mod (B, M ×N), N)

## 12.2 如何提高磁盘 I/O 速度（本章重点）

磁盘 I/O 速度的高低，将直接影响文件系统的性能。

提高磁盘 I/O 速度的主要途径有：

> (1)选择性能好的磁盘；
>
> (2)设置磁盘高速缓冲区；
>
> (3) 采用好的磁盘调度算法。

### 磁盘访问时间【计算题】

磁盘的访问时间和什么有关？

> 这段内容和计组的计算题几乎一模一样

寻道时间 + 平均旋转延迟 + 数据读取时间。其中，寻道时间和平均旋转延迟远大于数据读取时间。两者中，寻道时间长于旋转延迟。

#### 寻道时间

把磁头从当前位置移动到指定磁道（柱面）上所经历的时间，它与磁盘转速、移动的磁道数有关。

该时间是启动磁盘的时间 s 与磁头移动 n 条磁道所花费的时间之和，即 *T* s = *m* × *n* + *s*

式中，m 是—常数，它与磁盘驱动器的速度有关，代表磁盘上移动一条磁道需要花费的时间。

> 对—般磁盘，m＝0.2  
>
> 对高速磁盘，m≤0.1，磁臂启动时间约为2ms。

—般寻道时间将随寻道距离（n）的增大而增大

#### 旋转延迟时间

旋转延迟时间（Tr）是指定扇区移动到磁头下面所经历的时间，与磁盘转速有关 

$Tr=1/2r$  r为磁盘转速。公式即为磁盘旋转半圈所需的时间

如果磁盘旋转速度为5400 r／min，则每转一圈需要时间 11.1ms，平均旋转延迟时间 Tr 为 5.55 ms。

#### 数据传输时间

Tt是指把数据从磁盘读出，或向磁盘写入数据所经历的时间。
$$
T_t=\frac{b}{rN}
$$
b 为所读／写的字节数;

r 为磁盘以秒计的旋转速度；

N 为一条磁道上的字节数。

> 这段公式假设：磁头移动时，其扫过的数据都能被读取出来。

#### 总访问时间

$$
T_a=T_s+\frac{1}{2r}+\frac{b}{rN}
$$

寻道时间和旋转延迟时间，基本都与所读／写数据的多少无关，而且它通常是占据了访问时间的大头。

旋转延迟时间和数据传输时间很难优化，因此优化的目标通常是寻道时间。减少寻道跨越的道数，就可以优化时间

目前随着磁盘传输速率的不断提高，数据传输时间所占的比例更低。可见，适当地集中数据(不要太零散)传输，将有利于提高传输效率。



## 12.3 磁盘调度【计算】

操作系统有责任高效地使用硬件——对于磁盘设备，这意味着很短的访问时间和磁盘带宽。

> 磁盘带宽：计算磁盘访问速度的参数，是用传输的总位数，除以第一个服务请求与最后传输完成之间的总时间。

磁盘调度算法决定了如何响应多个磁盘访问请求，由于寻道时间是访问中最耗时的部分，磁盘调度算法主要决定访问磁盘各个磁道的顺序。

### FCFS 先来先服务

按照寻道序列的顺序依次寻道。

如下图所示，磁头总共移动了640个柱面的距离。

![image-20211118151142233](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211118151142233.png)

### SSTF 最短寻道时间优先

选择从当前磁头位置所需寻道时间最短的请求。（即选择距离当前磁道所在位置最近的位置读取）

SSTF 是 SJF 调度的一种形式；如果离当前磁头近的位置内不断插入等待进程。**有可能引起某些请求的饥饿。**

如图所示，磁头移动的总距离是236柱面。

![image-20211118151622285](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211118151622285.png)

对于 SSTF 算法，只要不断有新进程到达，且新进程所要访问的磁道与磁头当前所在磁道的距离较近，则新进程一定优先满足，而某些老进程则会发生“饥饿”现象。

SSJF 选择的每个请求都是寻道时间最短的，但是并不能保证平均寻道时间最短。

### SCAN 算法（电梯调度）

SCAN 算法：不仅考虑到欲访问的磁道与磁头当前位置间的距离，更优先考虑的是磁头当前的移动方向。算法所选择的访问对象应当是**与磁头当前的移动方向一致且距离最近的**。

要注意：**SCAN 算法必须到达磁道的一端才会返回，即使这端并没有请求**。

这种算法就像电梯接人一样的确定顺序算法。磁头不会因为访问某个地址改变运动方向，直到到达一侧尽头，才会改变运动方向。SCAN 算法可以防止 SSJF 出现的在小范围内反复扫描的情况，不会导致饥饿。

如图所示，磁头移动的总距离是236柱面。

![image-20211118151722932](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211118151722932.png)

### C-SCAN（循环扫描）

提供比扫描（SCAN）算法更均衡的等待时间。

磁头从磁盘的一段向另一端移动，沿途响应请求。当它到了另一端，就立即回到磁盘的开始处，在返回的途中不响应任何请求。

> SCAN 算法中，磁头返回时仍然会响应沿途的请求，只是会忽略不同方向沿途的请求。

把所有柱面看成一个循环的序列，最后一个柱面接续第一个柱面。

C- SCAN 算法仍然要求到达磁盘的一端才可以返回。

![image-20211118152236215](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211118152236215.png)

### LOOK 算法

也是SCAN算法的一种，磁臂在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，**而不需要移动到磁盘的一端**

![image-20211118152405765](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211118152405765.png)

**同样有C-LOOK算法**

![image-20211222212520283](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211222212520283.png)

### N Steps Scan 分步扫描算法

将磁盘请求队列分成若干个长度为N的子队列，磁盘调度按FCFS依次处理这些子队列。

每处理一个子队列时又按SCAN算法

对一个队列处理完成后，再处理其他队列

当处理某一子队列时，若又出现新的 I/O 请求，便将请求进程放入其他子队列。

当 N 取值很大时，算法性能接近于 SCAN 算法，当 N=1 时，算法成为FCFS算法。 

优点：能使 I/O 请求的等待时间不至于过长，不会发生饿死现象

### FSCAN 算法

是 N 步 SCAN 的简化。

只将磁盘请求队列分成两个子队列。

> 一个子队列是由当前所有请求磁盘 I/O 的进程组成的，按 SCAN 算法调度
>
> 而扫描期间新出现的请求进程，放入另一个等待处理的请求队列 
>
> 

## 12.4 磁盘高速缓存 disk cache

磁盘高速缓存的形式 

是利用内存中的存储空间，来暂存从磁盘中读出的一系列盘块中的数据。即高速缓存是一组在逻辑上属于磁盘，而物理上是驻留在内存中的盘块

两种实现形式：

> 一种是在**内存中开辟一个单独的大小固定的存储空间**，不受应用程序多少的影响；（专用缓存）
>
> 另一种是把所有未利用的内存空间变为一个**缓冲池，**供请求分页系统和磁盘I/O共享。（公用缓存）

数据交付方式——将磁盘高速缓存中的数据传送给请求者进程的方式。

> **数据交付**：直接将高速缓存中的数据传送到请求者进程的内存工作区
>
> **指针交付**：只将指向高速缓存中某区域的指针交付给请求者进程

置换算法：和内存 cache 的置换算法类似，通常是 LRU



## 12.5 磁盘管理

磁盘的常见功能如下：

- 存储文件
- 作为虚拟内存，进行交换
- 启动操作系统（引导）

低级格式化，或物理格式化——把磁盘划分成扇区，以便磁盘控制器可以进行读写

> 一般磁盘出厂时就已经完成低级格式化。

逻辑格式化：构建磁盘上用于辅助存储文件的结构。为了使用磁盘保存文件，操作系统还需要在磁盘上保存它自身的数据结构。也可以被称为“创建文件系统”。

### 启动分区

磁盘上存在 MBR 分区（新的电脑可能不用了），存储了启动代码和分区表等信息。开机后，BIOS 会读取磁盘的 MBR 分区，根据 boot code 和分区表找到实际的启动分区，之后从该分区启动。

### 坏块管理

在简单的磁盘上（比如 IDE 磁盘）：

坏扇区是手动处理的；MS-DOS 格式可以通过命令执行逻辑格式化，扫描磁盘、查找坏扇区。对于找到的坏扇区，它在 FAT 条目中写入一个特殊值，说明分配时不要使用该块。

在复杂的磁盘上（比如 SCSI 磁盘）：

可以使用例如扇区抹除等方法来处理坏块：

控制器在磁盘上维护一个坏块列表，该列表在出厂时的低级格式化过程中初始化，并在磁盘的整个生命周期中更新。

低级格式化会预留空间作为操作系统不可见的备用扇区，可以用备用扇区之一替换坏扇区。此替换过程对操作系统是透明的。

## 12.6 交换空间管理

交换空间——虚拟内存使用磁盘空间作为对主存的扩展。

交换空间可以在常规的文件系统中实现，或者更通常的情况是放在一个单独的磁盘分区里。

> 这个交换空间通常不会进行逻辑格式化，即是一块「生磁盘」

交换空间管理**追求的是访问速度，而不是存储效率**。

交换分区的大小通常取决于：

- 物理内存的容量
- 需要的虚拟内存容量大小
- 使用虚拟内存的方式

两种存储方式：

- swap space 作为一个文件存在于文件系统中，由文件系统进行管理：创建、命名、分配空间

  Windows 采用此方式，将交换空间存储在 C 盘根目录的一个不可见文件中。

- swap space 存在于一个单独的未格式化的分区中，这里没有文件系统或目录结构，由交换空间管理程序（swap space storage manager ）完成分配和回收。

  Ubuntu 在安装时可以选择性的划分一个磁盘分区作为 swap 空间，说明 Ubuntu 采用了此种方式。

  这种情况下，交换空间管理程序如何追踪交换空间哪部分被使用了呢？

  可以利用 swap map 记录每个交换区的块是否被分配。

  ![image-20241115103839229](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAMGZ1_9Ny8zMmNP4jMmcVqyt64eGEoAAi4TAAKnjAABV_3HtkXu_JuaNgQ.png)
  
  0 表示此块没有被分配，1 表示此块被 1 个程序使用，3 表示此块交换空间已被三个程序共享。

## 12.7 磁盘可靠性（RAID）

RAID 系统通过存储冗余数据，改善了数据的可靠性；同时，通过多磁盘并行读写，改善了存储的访问速度。

RAID：通过把多个磁盘组织在一起，作为一个逻辑卷提供磁盘跨越功能

- 通过把数据分成多个数据块，并行写入/读出多个磁盘，以提高访问磁盘的速度

- 通过镜像或校验操作，提供容错能力。

了解 RAID 可以提高性能和可靠性即可；如果很想了解不同等级的 RAID，可以看看计组磁盘那章的线上课

## 12.8 三级存储设备

三级存储的定义特征是低成本。通常，三级存储由可移动介质构成，包含软盘、光盘和磁带等设备。

三级存储的成本很低，但是性能比二级存储更差，可靠性更差。

## 12.9 题目

假设磁盘的每个磁道分成9个块，现有一文件有A，B，C，……I 共9个记录，每个记录的大小与块的大小相等，设磁盘的转速为27ms/r，每读出一块后需要2ms的处理时间，若忽略其他时间，试问：

1）如果顺序存放这些记录，顺序读取，处理该文件要多少时间？

2）如果要顺序读取这些文件，记录如何存放处理时间最短？

注意点：

1. 磁盘没法停下：每次处理的 2ms 中，磁盘都错过了下一盘块，因此需要再转一圈回来才能读取
2. 注意最后那个块读取完成后，仍然需要 2ms 后处理时间，别忘了……
3. 要加速读取，可以交叉存放数据（A F B G C H D I E），这样后处理的 2ms 内经过的是不需要处理的盘块，不用等磁盘转完一圈再读取下一块。



