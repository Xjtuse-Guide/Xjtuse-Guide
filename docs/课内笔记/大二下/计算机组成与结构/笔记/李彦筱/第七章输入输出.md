

# 第七章 输入/输出

>易俊泉学长的原始笔记链接如下：
>
>[chapter07 I/O](docs/课内笔记/大二下/计算机组成与结构/笔记/易俊泉/chapter07IO.md)

## KEY POINTS

1. 常见的外设有哪些

2. I/O 模块，为什么需要 I/O 模块、I/O 模块的功能

3. 编程式 I/O 的执行过程
4. I/O 设备的两种编址方式：存储映射式和独立式。二者的优缺点是什么？

5. 中断驱动式 I/O，过程如何？识别中断设备的四种方式分别是什么

6. DMA 是什么，为什么效率更高，可采用哪三种方式与 CPU 轮流占用总线：块传送、周期窃取、交替方式，具体如何实现？

7. I/O 通道，I/O 通道的概念、功能、两种分类、这两种通道最大传输速度的计算

![image-20211022114603362](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704188.png)

上图描述了处理器、内存和外设之间的关系。

外围设备种类繁多，它们：

- 提供不同数量的数据

- 速度不同

- 按不同的时序工作

- 数据传输使用不同的格式

大部分外设都比 CPU 和 RAM（主存）慢

外围设备不直接连接到系统总线 , 需要 I/O 模块

> 这是因为：1. 在 CPU 中直接集成如此多外设的控制程序是不现实的
>
> 2.外设速度一般很慢，将其直接连接到高速系统总线上会拖慢 CPU 和内存

**I/O 模块**

- 它上方连接到系统总线，下方连接到一个或多个外设。

- I/O 模块化架构旨在为系统提供一种系统化的方法来控制与外部世界的交互，并为操作系统提供必要信息，以有效地管理 I/O 活动。

## 外设

外设根据「受众」可以分为几部分：

**人类可读**

> 屏幕、打印机、键盘

**机器可读**

> 磁盘和控制器

**通信**

> 网络接口卡

常见设备的速度如下：

![image-20211022115523436](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704169.png)



![image-20211022115707831](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704171.png)

和存储器不同，外部设备框图只有控制线和数据线，没有地址线。

缓冲器和转换器是一体的，用于把外设特有的信号转换为 CPU 能理解的信号（双向转换）

### 键盘/监视器

这两者是最常用的输入输出设备。

键盘工作原理：A/D 转换

- 按下按键 -> 触发电信号 -> 字模式
- 字模式传输到 I/O 设备，被转换为 ASCII 码结构后进入 CPU

监视器的工作原理：D/A 转换

信息交换的基本单位是字符

### 磁盘驱动器

包含两部分：一是与I/O模块交换数据、控制和状态信号，二是用于控制磁盘的读/写机制

## I/O 模块

### 模块功能

I/O 模块的功能如下：

Control & Timing  控制与定时（控制外设）

通信功能（核心）：

CPU ~ I/O Communication	I/O 模块和处理器通信

Device ~I/O Communication	I/O 模块和设备通信

Memory ~ I/O communication	I/O 模块和存储通信（仅在支持 DMA 时存在）

Data Buffering	数据缓冲，更改码制为存储器能识别的；积攒数据后一次性交给 CPU

Error Detection	检错

控制从外设到处理器的数据传送包括以下几个步骤：

> :one: 处理器查询 I/O 模块，检查所连设备的状态
>
> :two: I/O 模块返回设备状态
>
> :three: 如果设备状态正常且就绪，CPU 通过向 I/O 模块发出命令，请求数据传送
>
> :four: I/O 模块获得来自外设的一个数据单元(8位或者16位)
>
> :five: 数据从 I/O 模块传送到处理器。有如下三种方法：
>
> - 程序查询式 I/O
> - 驱动中断式 I/O
> - DMA（直接内存访问）
>

#### I/O 通信操作（I/O communication）

**命令译码 command decoding**: I/O 模块接受来自处理器的命令，这些命令一般作为信号发送到控制总线。例如，一个用于磁盘驱动器的 I/O 模块，可能接受 READ SECTOR (读扇区)、WRITE、SECTOR (写扇区)、SEEK (寻道)磁道号和 SCAN (扫描)记录标识等命令。后两条命令中的每条都包含一个发送到数据总线上的参数。

**数据交换 data exchange**：数据是在处理器和 I/O 模块间经由**数据总线来交换的**。外设向 CPU 发送数据时，数据通常先存储在 I/O 模块的 Buffer 中，凑满之后一次性传输出去。

**状态报告**：由于外设速度很慢，所以知道 I/O 模块的状态很重要。例如，如果要求一个 I/O 模块发送数据到处理器( 读操作),而该 I/O 模块仍在处理先前的 I/O 命令而对此请求未能就绪，则可以用状态信号来报告这个事实。常用的状态信号有忙(BUSY)和就绪(READY)，还有报告各种出错情况的信号。

**地址识别**：正如存储器中每个字对应一个地址一样，每个 I/O 设备也有地址。这个地址 CPU 不会记录，由 I/O 模块记录。因此，I/O 模块必须能识别它所控制的每个外设的唯一地址 。另一方面，模块必须能进行设备通信(devicecommunication)

#### Data Buffering 数据缓冲

这是 I/O 模块的一个重要作用，用于协调 CPU/主存和外设间速度不匹配的问题。

- CPU/DRAM <-> I/O Buffer（位于 I/O 模块中）
- I/O Buffer <-> 外设

#### Error Detection 检错

I/O 模块需要负责检测外设的错误并向处理器报告。常见的错误包含：

- 硬件故障(纸张堵塞、磁盘坏道)

  这种持久性的错误需要通过 I/O 中断报告给 CPU，由操作系统告知使用者

- 传输错误(位错误、数据损失)

  I/O 模块通过奇偶校验，检查是否存在传输错误。如果有错误，这种错误不会被报告，I/O 模块会直接要求外设重新传输错误的数据。

### 模块结构

![image-20211027103008202](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704172.png)

> I/O 模块和 OS 第十三章讲的设备控制器是一个东西

一个 I/O 模块可以连接一个或多个 I/O 设备。

地址线、控制线是连接到 CPU 的。控制线说明当前需要读取还是写入内容。

I/O 设备的地址由 I/O 模块识别

数据线连接到数据寄存器和状态/控制寄存器。前面提到，数据缓冲涉及到的 Buffer 就是这里的数据寄存器组成的。

数据线将零碎的控制信息作为参数进行传输：比如奇偶页信息；含义明确的控制信号通过控制线传输

### I/O 模块决策

支持多个或单个设备

将设备属性隐藏或现实给 CPU

控制设备功能细节/留给 CPU 完成

> 控制细节一般由 I/O 设备完成

### I/O 形式

CPU 处理 I/O 存在三种方式：

- 程序查询式 I/O：CPU 完全掌握 I/O 过程，需要事无巨细的控制 I/O 传输的每个细节。目前很少见，只在部分单片机上出现
- 中断驱动的 I/O：发送传输命令后，CPU 就不管 I/O 了，等传输完成后 I/O 模块通过中断通知 CPU
- 直接内存访问（DMA）：I/O 一次完成多于一字节的单位（比如一次传输一块）后，再通知 CPU

## 程序查询式 I/O（Programmed）

对于程序查询式 I/O（原称为 编程式 I/O programmed I/O），数据在处理器和 I/O 模块之间交换，处理器通过执行程序来直接控制 I/O 操作，包括检测设备状态、发送读或写命令、以及传送数据

CPU 在发出 I/O 命令时等待 I/O 模块完成操作，会浪费CPU

![](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704173.png)

**执行过程**

:one: CPU 处理一条 I/O 指令

:two: 向 I/O 模块发送一个命令来执行它，并等待 I/O 模块就绪（持续检查 I/O 模块的某个寄存器）

:three: I/O 模块执行命令，然后在 I/O 状态寄存器中设置适当的位

:four: CPU 定期检查状态位，直到它发现操作完成

为了执行与 I/O 相关的指令，处理器发送一个指定具体 I/O 模块和外设的地址，并发送一条I/O 命令。当 I/O 模块被处理器寻址时，它会处理**四种 I/O 命令**：

> 控制命令、测试命令、读命令、写命令

当处理器、主存和 I/O 共享一条公共总线时，**编址方式**主要有两种：

**存储映射式** memory-mapped（和存储器统一编地址）

> 设备和内存共享地址空间
>
> I/O 看起来就像存储器 read/write
>
> 没有针对 I/O 的特别命令
>
> 通过地址码区分存储器和 I/O 接口
>
> 缺点：浪费了宝贵的存储地址空间；I/O 可能不需要那么多地址，但还是需要和存储器地址长度相同

**独立式** isolated

> 存储器和 I/O 分为单独的地址空间
>
> 需要 I/O 或存储器选择线，以指定当前需要访问是 I/O 还是 CPU
>
> 有 I/O 特殊命令：指令集不会太多
>
> 通过不同指令区分访问的是存储器还是 I/O 接口

统一编址下不需要输入/输出指令，可以使用访存指令直接访问 I/O 接口

![image-20211027111101075](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704175.png)

存储器-I/O 统一编址的过程：

- 把 AC 寄存器赋值为数字 1；随后，存储 AC 的内容到键盘上的 517 寄存器中。

  517 寄存器末尾为 1，代表当前需要开始阅读。很多指令集（比如 x86）不允许直接对存储器读取/写入，因此需要 AC 作为中介（先把待写入的内容写入 AC，再把 AC 写入  517 寄存器）

- 第二步，先把 517 寄存器的内容读取到 AC，再持续检查 Sign 是不是 0（Sign 是 517 寄存器的最高位，为 1 表示可读取，为 0 表示键盘信息不可读取），如果 Sign 是 0（没准备好），就跳转回 202，重新执行检测，相当于无限循环

  当 Sign 为 1 时，从 516 寄存器读取内容到 AC 中（516 寄存器是键盘输入的寄存器），读取完成

I/O 单独编址的过程（此步骤中省略了使用 AC 缓存的部分）：

- 发出开始 I/O 指令，设备编号为 5

  > 开始读取存储器使用其他指令，因此不用担心操作数 5 被识别成第五个存储器

- 发出 Test I/O（测试外设是否准备好），如果没有，就无限循环此指令；如果完成，就读取 I/O 的内容（到 AC 中）

可以看出，统一编址时，CPU 采用访问存储器的指令访问 I/O 设备（READ/WRITE），通过置位某些控制位来让设备工作；在分别编制中，CPU 采用单独的命令访问 I/O 设备（TEST，IN）

虽然 I/O 单独编址的步骤看起来更少，但实际上，两种方法的复杂度差不多。市面上既有使用 I/O 单独编址的计算机，也有使用存储器映射 I/O 的计算机。

**优势**

> 简单、处理器完全控制 I/O 设备

**缺点**

> 耗费 CPU：需要无限循环等待 I/O 设备完成操作

**解决方案**

> 使用中断机制

## 中断驱动（interrupt driven）I/O

处理器发送一个 I/O 命令到模块，然后去处理其他有用的工作，当 I/O 模块准备与处理器交换数据时，它中断处理器以请求服务，然后处理器执行数据传送，最后恢复原来的处理工作

![image-20211027112615844](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704176.png)

CPU 发出读取指令，然后干其他工作；I/O 模块从具体设备中读取信息，直到自身寄存器满后，向 CPU 发送中断信号。CPU 保存当前上下文，通过中断服务程序响应中断，并且从 I/O 模块取走数据，随后恢复上下文，继续执行中断前的程序

> 数据是 I/O 模块读取的，不是中断服务程序读取的；I/O 模块从外部 I/O 设备中具体读取数据，而中断服务程序仅仅从 I/O 模块中把数据读到主存中。

中断信号的发出由 I/O 模块自控。它自己完成的工作如下：

- 从 CPU 接受读命令
- 检测外设的状态，从外设读取数据并保存到自身的寄存器中。当寄存器满后，向 CPU 发出中断信号
- 等待 CPU 请求自己的数据，然后通过数据总线将数据传输给 CPU。

<font color="red">**中断处理过程**</font>

![image-20211027112835234](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704189.png)

上图描述了中断发生的过程与 CPU 如何处理中断。

> 中断允许信号：允许当前设备的中断被响应。当很多设备都发送中断申请时，同一时间只能同意一个设备的中断。
>
> PSW：Program Status Word，程序状态寄存器，和 PC 一样是最重要的寄存器之一。
>
> 在保存硬现场和软现场（存储 PC、PSW；存储其他寄存器）时，一般会关闭硬件上的中断开关，不允许保存现场时进行中断；不过，现场保存完成，中断服务程序开始执行时，中断开关会打开，允许更高优先级的中断打断当前中断

![image-20211027113524696](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704178.png)

### 中断源的识别

如何识别哪个模块发出了中断？有很多方法：

:one: 多条中断线

每个中断源和 CPU 间通过不同中断线连接，根据哪条线发来的信息，即可得知哪个模块发起了中断。

缺点：线太多了排不下（地址线数据线都复用，凭什么给每个中断源拉一根线？）

一般采用此方法时，最多拉 8 根中断线，利用层连等其他方式将 CPU 和其他中断源连接

识别优先级：每根中断线都对应一个中断优先级

:two: 软件轮询式（类似总线仲裁的计数器查询）

只有一根中断线，当 CPU 检测到一个中断时，进入中断服务程序，轮询每一个 I/O 模块来确定时哪一个模块产生的中断。

缺点：时间花费大

识别优先级：由于轮询由软件进行，因此软件可以通过改变中断轮询顺序，决定中断优先级

:three: 链式查询(硬件轮询)

所有 I/O 模块共享一根的中断请求线，一旦 CPU 检测到中断，中断许可信号就会从链上逐个往下传。当发起中断的 I/O 模块接收到 CPU 给的中断许可信号时，它就把一个中断向量放到数据总线上，说明当前应该使用哪个中断服务程序。

这种方法也被称为「向量式中断」，因为采用了中断向量

硬件轮询更快、但是对故障很敏感，且轮询顺序固定，因此各个模块的中断优先级是固定的。

识别优先级：离中断响应许可线越近的模块，优先级越高

:four: 仲裁式

模块必须占用总线才能发起中断，独占系统总线时，才发起中断。这保证了中断只有一个可能的发起者。当 CPU 向发起模块发送中断许可信号后，模块在数据总线上发送中断向量，指明当前使用的中断服务程序。

这种方式利用总线仲裁的方法来处理中断源之间的关系。

由于使用了中断向量，这种方法也属于「向量式中断」

识别优先级：谁在仲裁总线的优先级越高，中断的优先级就越高。（因为只有占用总线才能发起中断）

中断驱动必须保证处理中断所需的时间 < I/O 接口的数据寄存器被填满的时间，不然就一定会丢失数据……

## Direct Memory Access 直接存储访问

编程式和中断式的**缺点**

> 程序驱动式 I/O 需要占用所有 CPU 时间 
>
> 中断驱动的 I/O 仍需要主动 CPU 干预，尽管 CPU 使用效率高于程序驱动 I/O，但是传输率较低（I/O 传输所花费的 CPU 时间太长）
>
> 数据的传输必须通过 CPU，转移率有限，而且每个字都需要 CPU 处理
>
> 当传输大量数据时，DMA 是一种更高效的技术

### DMA 概念

既然从 I/O 读取的内容都需要放入主存，那为什么必须经过处理器读取呢？是否可以让 I/O 设备的数据直接传输到主存？

DMA 控制器从 CPU 接管 I/O，无需 CPU 干预就可以将数据块（大块数据）传输到内存或者从内存中获取数据。

> 其他某些书籍认为 DMA 属于一种 I/O 模块，具备 I/O 模块的某些功能；但我们使用的书中认为 DMA 就是 DMA，和 I/O 模块没有关系。

在数据发送前，传输结束后，CPU 仍然需要处理中断；但传输数据过程中，CPU 完全不需要处理中断。

对总线的使用优先级上：DMA>CPU

CPU 和 DMA 之间如何协调总线的使用呢？

:one: block transfer mode 块传输方式

当 DMA 传输数据完成后，CPU 才能使用总线。在读取大文件到内存中时比较有用。

缺点：DMA 传输时，CPU 无法访问主存，可能导致卡顿

:two: cycle stealing mode 周期窃取式

DMA 仅在 CPU 不需要时才使用总线，或迫使 CPU 暂时停止运行 

当 CPU 需要总线时，DMA 传输一个字的数据，然后必须释放总线，下一个周期不得使用总线；CPU 使用完总线后，DMA 才能再开始传输

> 如果 CPU 和 DMA 都在使用总线，二者必须交替传输（各自使用一个周期）
>
> 如果只有一方使用总线，则它不需要停顿，可以一直使用下去。

CPU 和 DMA 交替传输。

优点：CPU 读取数据时最多被耽误一个时钟周期

缺点：拖慢了 DMA 的速度

这种方法是用的最多的，也是书上主要介绍的。这种方法保证了 CPU 的速度，也没有太过减慢 DMA 的速度。

:three: ​transparent mode 透明方式

将时钟周期分为上升沿和下降沿，上升沿到下降沿之间 CPU 传输数据，下降沿到上升沿之间 DMA 传输数据。二者完全互不影响，但是控制电路比较复杂。而且，就算 DMA 不需要传输数据，CPU 仍然不能利用分配给 DMA 的的半个时钟周期。

### DMA 结构

DMA 结构如下：

![image-20211029101346115](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704190.png)

数据线传入待传输数据总量，存入 Data Count 中，也传入数据目标地址（放入内部的地址寄存器）

DMA 不用解析地址，直接将地址信号传给后面的 I/O 设备，让其进行判断。其控制信号中包含：

- DMA 请求信号（向 CPU/总线申请传输数据和通知传输完成）

### DMA 操作

**预处理**：CPU 通知 DMA 控制器：

读取还是写入；I/O 设备地址（放到 DMA 的地址寄存器）数据内存块的始地址；要传输的数据量 

通知后，CPU 继续开展其他工作

**数据传输**：DMA 控制器处理传输（逐字传输）

**后处理**：DMA 控制器在完成后**发送中断**

一块数据传输完以后才发送中断，不像中断驱动一个字中断一次

![image-20211029103138623](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704180.png)

上方的图片描述了 DMA 协助下的数据传送过程。

### DMA Transfer Cycle Stealing（DMA 周期窃取）

DMA 周期窃取式传输不是中断，CPU 不需要保存现场，只需要定期让出总线即可，比中断驱动式的传输好不少。

![image-20211029103840985](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704179.png)

上图描述了三种 DMA-CPU 总线占用方式下，传输内容的交错。

最后一部分的空格是因为透明模式下，CPU 只能在半个时钟周期中传输数据，即使 DMA 没有占用总线。

### DMA 配置

![image-20211029104043056](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704182.png)

I/O 传输到 DMA 占用一次总线，DMA 到主存占用一次总线。CPU 被挂起两次

![image-20211029104104606](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704183.png)

I/O 传输到 DMA 不再占用总线，DMA 到主存占用一次总线，CPU 挂起一次。不过，不同类型的 I/O 都需要一个 DMA。

![image-20211029104132284](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704184.png)

I/O 模块自身也有总线，I/O 总线统一接到 DMA 上，在保持上种方法的优点（只占用一次 CPU）的情况下，只需要一个 DMA 模块。CPU 还是仅需要在 DMA 和 主存传输时挂起一次。

最常使用第三种，CPU 只暂停一次

### 例题英文版，请直接看下一节

![image-20211029104756694](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704185.png)

定一秒的时间区级。题目的中文版下方就是。

### 例题

假设一台计算机的CPU时钟频率为500Mhz，其CPI为5(意味着平均执行一条指令需要5个时钟周期)。中断模式下，I/O设备的数据传输速率为0.5 MB/s，传输单元为32位。中断服务程序包含18条指令，中断服务的其他开销相当于2条指令的执行时间。请回答:

1）在中断模式下，CPU用于I/O传输的时间与总CPU运行时间的比值是多少?

2）假设设备的数据传输速率为5MB/s，采用DMA模式每次传输5000B块的数据，DMA预处理和后处理的总成本为500个时钟周期。CPU用于I/O传输的时间占总CPU运行时间的比例是多少?(假设DMA和CPU之间没有内存访问冲突)。

解决方案：计算一秒当中，CPU 花在 I/O 传输的时间有多少周期，除以 CPU 一秒内总共有多少时钟周期。（别算指令条数，不然很麻烦）

中断模式

> 在每个中断中，CPU用于I/O传输的时间= 5×18+5×2=100个时钟周期。
>
> **在一秒钟**,I/O设备传输0.5MB的数据和，需要中断时间= 0.5 MB / 32 = 0.5 MB / 4 B = 0.125 M。
>
> 中断成本=0.125M×100=12.5M时钟周期
> 
> 所需比例= 12.5M/500M=2.5%

DMA模式

> 在每个DMA中，CPU用于I/O传输的时间=500个时钟周期。
>
> 在一秒钟,I/O设备传输5MB的数据和，需要DMA处理时间=5MB/5000B=1K。
>
> DMA处理成本=1K×500=0.5M时钟周期 
> 
> 所需比例= 0.5M /500M=0.1%

## I/O 通道

**I/O 通道是拥有自己的处理器的 I/O 模块**。由于 I/O 通道也具有处理器，它可以执行 I/O 程序。

> I/O 程序存储在主存中

![image-20211226105141097](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704186.png)

操作 I/O 通道时，只需要给出需要读取的文件，传输块如何划分，I/O 通道就会读取并按要求完成工作，发给 CPU。I/O 通道之所以叫通道，是因为其和 CPU 由通道直连。

CPU 和 I/O 通道对内存的访问是完全独立了（除了二者访问同一内存的情况）。当二者访问发生冲突时，I/O 通道的优先级高于 CPU 的优先级。

### 工作原理

主 CPU 发送 I/O 命令，随后等待 I/O 通道和 I/O 设备准备好。发送命令中需要包含：

- I/O 通道号
- I/O 设备号
- 通道入口地址
- 数据长度

这样 I/O 通道才知道该寻找自己挂接的哪个 I/O 设备读取内容。通道长时间自主读取数据，中断次数非常少。

### I/O 通道类型

选择通道：类似单道程序，在任何时间只有一个 I/O 设备可以通过通道进行数据传输。因此，每个设备都需要在占用通道的时间内快速传输大量数据，这种通道一般挂接的都是快速设备。

通道容量：通道单位时间内传输数据的最大量。

选择通道的传输速度应当不低于其挂接设备中最快速的设备，这样才能服务好所有 I/O 设备。

多路通道：在任何时刻，可以有多个 I/O 设备同时利用通道传输数据。一般连接慢速设备，通过允许多个设备同时传输，提高总体传输速度。

字节多路通道通过轮换「同时」服务多个设备（每个设备传输一字节后传输下一个设备），和多道批处理系统类似。

多路通道和字节多路通道的传输速度应当不小于有其连接设备的传输速度之和。

块多路通道也采用轮换服务的方式，不过每个设备允许传输一块数据（而不是一个字节）

在所有 I/O 通道中，访问内存优先级如下：

选择通道 > 多路通道 > CPU