# 基础搜索方法

## 广度优先搜索(BFS)

广度优先搜索就是按照其他节点距离起始节点的距离从近到远来进行搜索。
主要思想就是从一个节点出发,先访问离这个节点最近的所有节点。
也就是先宽度遍历图；然后再访问这些节点的相邻节点,以此类推,直到遍历完整张图。

广度优先生成树：
利用广度优先搜索时节点被搜索到的顺序与每条边被经过时的顺序来生成的一棵树
这棵树的层序遍历结果与原来图的广度优先搜索结果是相同的

也可以理解为广度优先生成树去除了原本图里那些冗余的，会形成环的边，
同时保持了广度优先搜索结果不变。

```c++
#include <iostream>
#include <queue>

using namespace std;

// 图的邻接表表示
vector<vector<int>> adj; 

// 记录节点是否被访问
vector<bool> visited;

void bfs(int s) {
  queue<int> q;
  q.push(s); 
  visited[s] = true;
  
  while (!q.empty()) {
    int u = q.front();
    q.pop();
    
    // 遍历相邻节点
    for (int v : adj[u]) {
      if (!visited[v]) {
        visited[v] = true;
        q.push(v);  
      }
    }
  }
}

int main() {
    
  ...
  //根据实际问题初始化邻接表、访问数组 
  
  int start = ...;
  bfs(start);

  return 0;
}
```

## 深度优先搜索(DFS)

DFS (深度优先搜索) 是另一种重要的图搜索算法，它与BFS形成对比，主要思想是从一个节点出发，沿着路径向下遍历到不能再往下，然后回溯，再从另一个分支路径出发深度遍历图。

DFS类似于树的先根遍历或者二叉树的先序遍历

使用递归来实现的深度优先搜索：

```c++
#include <iostream>
#include <vector>
using namespace std;

vector<vector<int>> graph; // 图的邻接表表示
vector<bool> visited; 

void dfs(int v) {
  visited[v] = true; 
  cout << v << " "; // 访问节点v

  for (int u : graph[v]) {
    if (!visited[u]) {
      dfs(u); 
    }
  }
}

int main() {
  int n = 5; // 假设节点数为5
  graph.resize(n); 
  visited.resize(n);

  // 添加图的边
  graph[0].push_back(1);
  graph[0].push_back(3);
  graph[1].push_back(0);
  graph[1].push_back(2);
  graph[1].push_back(4);
  graph[2].push_back(1);
  graph[3].push_back(0);
  graph[4].push_back(1);

  dfs(0); // 从节点0开始dfs

  return 0;
}
```

深度优先生成树：类比于广度优先生成树，利用深度优先搜索时节点被搜索到的顺序与每条边被经过的顺序来生成的一棵树。
也保证了这棵树的先序遍历结果与原本图的深度优先搜索结果一致。

也可理解为深度优先生成树去除了原本图里的那些冗余的，会形成环的边，同时保持了深度优先搜索结果的不变。

# 补充

## BFS进阶

### A*算法

A*搜索算法是一种启发式搜索算法，他利用到了启发函数：

**启发函数** 是一个用来预估剩余代价的函数。

从A点BFS搜索到B点的最短路的过程中，对于传统BFS算法，每次都尝试访问同一层的节点，逐渐向外层扩散到B点，这样算法效率最差，因为在会搜索到很多冗余点。
所以我们可以用一个总花费来衡量当前所有待搜索的点，总花费越小的点越有可能在最短路上

我们对于已经搜索到的一个点C，定义它的总花费分为 g-cost 和 f-cost 
- g-cost 是一个真实值，是指起始节点A到C节点的最少花费值
- f-cost 可以是一个预估值也（当然可以是一个实际值）它可以表示当前节点到终止节点的预估花费，这个预估花费可以从启发函数求出

同时需要保证：预估花费一定是乐观估计，也就是它的值一定是小于等于实际值的。
只要保证是g-cost是乐观估计，那么最后的答案一定是正确的，这是由引理可证的。

我们每次在搜索时都搜索那些总花费最小的节点的后继节点，
当我们按照这个策略一直进行搜索，第一次搜索到终止节点B时，此时的搜索路径和搜索值就是最短路径和最短路径值
并且当第 K 次搜索到终止节点B时，此时就是第K短路径。

我们还可以使用A\*算法+Dijkstra算法来求第K最短路径，这里的难点显然在于求出第K短而不在启发函数。
使用Dijkstra算法我们直接可以将当前节点到终止节点的真实最短距离作为f-cost，也就是说此时f-cost是一个真实值，这也满足f-cost的定义要求。
之后维持一个优先队列来使用A\*算法，从而在第K次搜索到终止节点时得到第K最短路径。

## DFS进阶

### 迭代加深

当用DFS搜索时，会遇到答案大概率在搜索树的浅层，但是有些搜索树的分支会非常深。
这样如果直接使用DFS可能会使得时间开销很大，似乎使用BFS是个不错选择？

但是实际是BFS由于要保留上一层所有的节点信息，将它们维持在一个队列中，
所以当节点较多时空间开销太大，于是我们考虑使用DFS的迭代加深算法。

需要进行多次DFS，每次进行DFS前我们定义一个最大深度depth，一旦DFS超过这个最大深度我们就停止进行搜索
当搜完所有不超过最大深度的节点后如果还是没有找到目标节点，我们就增加最大深度的值重新再进行一次DFS搜索。
这样做确实可能会有部分节点被多次冗余搜索了，所以迭代加深只是在时间与空间之间寻找到一个平衡。

### IDA*算法

IDA\*算法本质是对 A\*算法的改进

- A*算法 = 启发函数 + 优先队列BFS
- IDA*算法 = 启发函数 + 迭代加深DFS

IDA*对启发函数的要求依旧是要乐观估计，同时引入了迭代加深中的深度限制

在无权图中我们设置参数来表示当前迭代深度，当迭代深度大于设置的最大深度时就或者在有权图中是花费限制，设花费限制为 l-cost

如果当前花费 g-cost + f-cost > l-cost
那么我们就停止当前分支搜索，立即从当前分支回溯。
如果DFS算法结束后依旧没有搜索到目标节点或者目标状态，那么就增大花费限制 l-cost 继续进行DFS搜索，直到搜索到目标节点。

IDA\*算法效率很不错，相比于A\* 算法的优势是代码更简单，并且由于不用维护二叉堆实现的优先队列，所以空间开销更小

### ɑ-β剪枝

ɑ-β剪枝是一种对博弈树的DFS深搜算法，在对博弈树或者说对抗树进行DFS搜索中通过ɑ-β剪枝剪枝可以大幅提高算法效率。

算法一般用来求双人零和博弈中的纳什均衡点，由于叙述过程较冗杂，建议大家参考一下博客：
https://zhuanlan.zhihu.com/p/65108398
