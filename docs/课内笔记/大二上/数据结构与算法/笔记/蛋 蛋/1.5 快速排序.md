# 5.快速排序

## 5.1 算法原理

快速排序（Quick Sort）的核心是“分治思想”：

对于一个整型数组，如果我们选择其中一个数（例如最右端的元素）作为基准（枢轴），那么剩下的元素分为：

- 大块（蓝块）：大于基准的元素
- 小块（红块）：小于基准的元素

*由于≥、≤的存在，如果需要的话，使用真蓝块（＞）和真红块（＜）表示严格大小关系，与此对应的红块（≤）和蓝块（≥）表示不严格大小关系，但这不是业界规范。*

我们遍历数组（除基准）与基准比较，可以用$O(n)$的复杂度遍历数组，把红块放一起，蓝块放一起，最后把基准元素放在红、蓝块中间，这样形成了三块相对有序的整体。

*注：对于双路快排，一定存在一个严格块和一个不严格块进行分区（如真红块与蓝块）*

```plaintext
2 8 5 2 3 7 4(基准) => 红 蓝 蓝 红 红 蓝 基准
红 红 红 基准 蓝 蓝 蓝
```

接下来，只要递归对左边的全红区再次这样排序，对右边的全蓝区再次这样排序即可。对于单个区域，平均情况下我们只考虑了整个区域的一半，时间复杂度是$O(log\ n)$！区域不断缩小直到每个区域长度为1，只需要排序n次，就能实现整个数组的完全排序，时间复杂度是$O(nlog\ n)$！

*存在问题*：

1. 如果基准没选好，剩下的元素都是一个颜色（都大于或小于基准），特别是针对右基准（右固定枢轴）的快速排序，如果数组高度有序，右基准几乎永远大于剩余元素，快速排序退化O(n²)；
2. 如果数组高度重复，等块（与基准值相同）将聚集不严格块，分区缩小极慢，快速排序也会严重退化。

**如何优化?**

解决基准极端的方法就是优化基准的选择：

- 三数取中：选择左、中、右三个元素的中位数；
- 随机枢纽：随机选取区间内的元素与最右边的元素交换，再进行右基准快排。

解决高重复数据集的方法是三路快排：

去掉不严格块，分为三个区域：小块、等块、大块，再对小块和大块区域分别快速排序。

## 5.2 代码实现

### 5.2.1 双路快排

快速排序针对区域分治处理，在代码中需要传入区域的开头与结尾；

由于不同的边界处理，一般会封装一个入口函数，但没有特别算法意义，手动指定也没关系：

```java
// 入口函数
public void sort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    quickSort(arr, 0, arr.length - 1);
}
```

在`quickSort`方法中对数组传入的区间进一步分区处理，其中`partition`方法进行了分区的直接操作，并返回了基准（枢轴）的索引`pivotIndex`，这样区间就分为了小块区间$[left, pivotIndex-1]$，基准（枢轴）$pivotIndex$，大块区间$[pivotIndex+1,right]$。

*`quickSort`的边界情况是传入的$left=right$，即区间只有一个元素，不用处理。传入的区间为空$left>right$也不用处理。*

否则再递归对小块区间和大块区间快速排序即可。

`partition`其中`i`指针用于遍历区间$[left, right-1]$，`low`指针维护的是真红块区间的最后一个位置。如果`i`指向的当前元素严格小于基准值，`low`指针后移，并把当前元素（蓝块）与`i`指向的当前元素互换（红块）。保证了`low`指向及之前的元素都是红块，`low`之外的元素都是蓝块（包括基准值，这里蓝块不严格大于）。

最后将`low+1`位置（蓝块的第一个位置）与基准互换即可，枢轴的索引即为`low+1`。

```plaintext
红 红 红 蓝 蓝 蓝 蓝 基准
   low↑  ↓互换    ↑i  ↑right
红 红 红 基准 蓝 蓝 蓝
```

本代码实现的是**右固定枢轴**、原地随机枢轴的优化，不需要该优化，随机枢轴选取的部分和`Random`相关部分可以直接删除。

```java
// 分治
private void quickSort(int[] arr, int left, int right) {
    if (left < right) {
        int pivotIndex = partition(arr, left, right);

        quickSort(arr, left, pivotIndex - 1);
        quickSort(arr, pivotIndex + 1, right);
    }
}

private static final Random random = new Random(); // 随机函数对象，静态化减少创建对象的次数

// 分区
private int partition(int[] arr, int left, int right) {
    // 随机枢轴选取
    int randomIndex = left + random.nextInt(right - left + 1);
    swap(arr, randomIndex, right); // 将右基准与随机一个元素互换

    int low = left - 1; // 维护真小块索引
    int value = arr[right]; // 基准值
    // 用i指针遍历区间
    for (int i = left; i < right; i++) {
        if (arr[i] < value) {
            swap(arr, ++low, i);
        }
    }

    // 最后数组结构如描述图，交换low+1位与枢轴
    swap(arr, low + 1, right);
    return low + 1; // 枢轴位置是真小块的后继
}
```

### 5.2.2 三路快排

三路快排意味着区间会分为三个区域分治，因此在分区`partition`中我们将区域分为三个（小、等、大），并返回两个索引（等、大），用数组封装$pivot\{小块末位索引，大块首位索引\}$。

分区后对小块区间$[left,pivot[0]]$和大块区间$[pivot[1],right]$递归快排。

在`parition`方法中，`i`遍历区间元素（除基准）$[left,right-1]$，`lt`维护真小块的右边界（闭区间）初始值$left-1$，`gt`维护真大块的左边界（闭区间）初始值$right$，当前元素比较后存在三种情况：

- 真小块：`lt`右移，交换当前元素与`lt`所指位置，交换来的元素索引≤i，已排序，i右移；
- 等块：不用交换，i右移；
- 真大块：`gt`左移，交换当前元素与`gt`所指位置，交换来的元素索引>i，未排序，i不移动。

需要注意，`i`自然维护了一个特性：如果有等块，他的前驱是等块区域的右边界：

```plaintext
红 红 Uk Uk 蓝 基准  Uk是等块    红 红 等 Uk 蓝 基准   Uk是蓝块    红 红 等 蓝 蓝 基准
 lt↑ i↑   gt↑       -------->           i↑           -------->           i↑gt
```

**为什么循环条件是$i＜gt$?**

通过`i<gt`的循环条件提前结束循环，不必到$right$：

设区间长度n，原本就要遍历n-1次（去枢轴）。如果当前元素是真大块，`gt`左移`i`不移，其实已遍历的元素+1了，只是移到了区间的后面。

```plaintext
[-1]  Uk Uk Uk 基准  Uk是蓝块    Uk Uk 蓝 基准 
lt↑   i↑      gt↑    ------->   i↑   gt↑ 
```

**基准元素移到哪里？**

在循环结束的时候，`lt`指向红块右边界，`i`和`gt`都指向蓝块的左边界，等块区间$[lt+1,gt-1]$。

而基准元素一定是等块，他将从数组的最右端向中间发起交换，**被交换元素将移动到数组的末尾**，而数组的右边是倾向大块的，所以用`gt`所指的大块元素与$right$互换最为保险，互换后`gt`后移。

如果没有蓝块，`gt`指向基准，基准自交换，依然有序。

```plaintext
红 红 蓝 基准     swap    红 红 等 蓝
    gt↑  ↑right  ----->         gt↑
```

代码实现如下：

```java
private void quickSort(int[] arr, int left, int right) {
    if (left < right) {
        int[] pivot = partition(arr, left, right);

        quickSort(arr, left, pivot[0]);
        quickSort(arr, pivot[1], right);
    }
}
// 分区
private int[] partition(int[] arr, int left, int right) {
    int lt = left - 1; // 维护真小块右边界索引
    int gt = right; // 维护真大块左边界索引
    int i = left; // 当前遍历元素
    int value = arr[right]; // 右基准值

    while(i < gt) {
        // 判断块类（小、等、大）
        if (arr[i] < value) {
            // lt+1位置的元素是等块，不必判断，i后移
            swap(arr, ++lt, i);
            i++;
        } else if (arr[i] > value) {
            // gt-1位置的元素被置换到i后还是待判断元素，i不用后移
            swap(arr, i, --gt);
        } else {
            // i是等块，后移
            i++;
        }
    }
 
    swap(arr, gt++, right);
    return new int[]{lt, gt};
}
```

## 5.3 快速选择算法

选择算法的目的之一是查找数组中的第k小元素，即查找排序后索引为$k-1$的元素（数组下标从0开始）：

对于快速排序，在分治操作下形成了$[红，枢轴，蓝]$三块区域，并且这三块区域的大小关系被确定。

如果红块区域的长度是$k-1$（即$pivotIndex=k-1$），那么枢轴就一定且只比数组的$k-1$个元素大。

即，**枢轴一定是数组中的第$pivotIndex+1$小（数组索引从0开始）的元素**。

否则需要进行如下判断：

- 枢轴索引＞$k-1$：目标元素在左侧，对左侧进行递归快速选择；
- 枢轴索引<$k-1$：目标元素在右侧，对右侧进行递归快速选择。

递归搜索的时候区间会进一步缩小，如果搜索区间只有一个元素$left=right$，该元素就是答案。

*快速排序的区间缩小下，不会发生区间为空的现象，查询区间只会向目标元素缩小，不用处理$left>right$。*

代码如下：

```java
private int quickSelect(int[] arr, int left, int right, int k) {
    if (left == right) {
        return arr[left];
    }
    int pivotIndex = partition(arr, left, right); // 与双路快排分区方法完全一致

    if (pivotIndex > k - 1) {
        return quickSelect(arr, left, pivotIndex - 1, k);
    } else if (pivotIndex < k - 1) {
        return quickSelect(arr, pivotIndex + 1, right, k);
    } else {
        // 枢轴索引 = k-1，即为第k小元素
        return arr[pivotIndex];
    }
}
```

## 5.4 复杂度分析

### 5.4.1 时间复杂度


| 排序算法 | 最好情况    | 最坏情况 | 平均情况    |
| -------- | ----------- | -------- | ----------- |
| 双路快排 | *O(n logn)* | *O(n²)* | *O(n logn)* |
| 三路快排 | *O(n logn)* | *O(n²)* | *O(n logn)* |

双路快排的最坏情况如下：数组有序（无枢轴选择优化）、极端枢轴（优化后几乎不会）、高重复率；

三路快排解决了高重复率问题，极端枢轴问题几乎不用考虑，在实践中快速排序已经臻于至善。

### 5.4.2 空间复杂度

快速排序需要递归栈空间，平均递归深度*O(log n)*，最坏递归深度*O(n)*，原地排序。