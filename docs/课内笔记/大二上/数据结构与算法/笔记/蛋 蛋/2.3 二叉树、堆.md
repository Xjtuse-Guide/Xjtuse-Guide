# 3.二叉树、堆

二叉树是一种每个节点最多拥有*左子树*和看*右子树*两个子树的有序树形结构，且左右子树不同构（不可交换）。

## 3.1 二叉树的ADT

二叉树具有以下特征：

- 根节点（root）：无父结点的顶层节点
- 叶子节点（leaf）：每个节点最多拥有一个左节点和一个右节点

二叉树具有以下分类：


| 结构分类   | 描述                                                                                         |
| ---------- | -------------------------------------------------------------------------------------------- |
| 完全二叉树 | 除最后一层外，其余每层节点数均为该层最大值（满节点）；最后一层节点从左到右连续排列，右侧可空 |
| 满二叉树   | 满二叉树是完全二叉树的“终极形态”，所有层的节点数达到最大值                                 |
| 平衡二叉树 | 任意节点的左、右子树深度差≤1，左右子树均为平衡二叉树                                        |
| 斜树       | 二叉树退化为线性链表                                                                         |


| 节点特性分类  | 描述                                           |
| ------------- | ---------------------------------------------- |
| 二叉搜索树BST | 左子树任意节点值‹当前节点值‹右子树任意节点值 |
| 堆            | 完全二叉树+父节点≤子节点（小顶堆）            |

## 3.2 二叉树存储结构

### 3.2.1 链式存储

链式存储是二叉树最常用的存储结构，使用*节点对象+指针*的方式关联父子关系，每个节点独立存储。

每个节点类包括以下部分：

- 数据域：存储节点值（可以多个，如整数、对象）
- 左指针(left)：指向左孩子节点（空null）
- 右指针(right)：指向右孩子节点（空null）
- [可选]父指针（parent）：指向父节点，适配向上场景，如三叉链表

```plaintext
        节点A（数据：1）
       /              \
左指针/                \右指针
     v                  v
节点B（数据：2）    节点C（数据：3）
   /    \              /
  v      v            v
节点D    节点E      节点F
(null)  (null)    (null, null)
```

### 3.2.2 数组存储

数组存储的核心是**通过下标映射父子关系**，依赖数学规律关联节点。该结构在完全二叉树中效率最优，非完全二叉树会造成空间浪费严重。

对下标从0开始的二叉树存储数组：


| $index$       | 当前节点下标   |
| ------------- | -------------- |
| $index×2+1$  | 左孩子节点下标 |
| $index×2+2$  | 右孩子节点下标 |
| $(index-1)/2$ | 父节点下标     |

如果需要`0`位空缺或存储其他数据（如size），会使用下标从1开始的二叉树存储数组：


| $index$      | 当前节点下标   |
| ------------ | -------------- |
| $index×2$   | 左孩子节点下标 |
| $index×2+1$ | 右孩子节点下标 |
| $index/2$    | 父节点下标     |

## 3.3 普通二叉树基本实现

### 3.3.1 链表实现

自定义二叉树的节点类，保证数据域、左右指针存在。

可增强扩展性使用泛型存储。

```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    public TreeNode(int _val) {
        val = _val;
        left = null;
        right = null;
    }
}
```

### 3.3.2 数组实现

堆维持严格的完全二叉树结构，二叉树的数组实现可参考3.4.3 堆的代码实现

## 3.3 二叉树的遍历

二叉树的遍历可以分为**深度优先DFS**（前/中/后序）和**广度优先BFS**（层序）。

### 3.3.1 深度优先遍历

深度优先按照根节点的访问时机可以分为：

- 前序遍历：根节点->左子树->右子树
- 中序遍历：左子树->根节点->右子树
- 后序遍历：左子树->右子树->根节点

#### 3.3.1.1 递归实现

通过修改访问方法与左右子树递归方法的相对位置改变遍历次序。

递归边界：当前节点为null的时候返回。

```java
// 前序遍历
public TreeNode preOrderRecursive(TreeNode root, List<Integer> result) {
    if (root == null) { return; }
    result.add(root.val); // 访问节点
    preOrderRecursive(root.left, result); // 递归左子树
    preOrderRecursive(root.right, result); // 递归右子树
}

// 中序遍历
public void inOrderRecursive(TreeNode root, List<Integer> result) {
    if (root == null) { return; }
    inOrderRecursive(root.left, result); // 递归左子树
    result.add(root.val); // 访问节点
    inOrderRecursive(root.right, result); // 递归右子树
}

// 中序遍历
public void postOrderRecursive(TreeNode root, List<Integer> result) {
    if (root == null) { return; }
    postOrderRecursive(root.left, result); // 递归左子树
    postOrderRecursive(root.right, result); // 递归右子树
    result.add(root.val); // 访问节点
}
```

#### 3.3.1.2 迭代实现

迭代实现通过栈模拟递归调用，避免栈溢出的问题。

*注意：前序遍历左节点后入栈、先出栈被访问，右节点先入栈、后出栈被访问。*

```java
public List<Integer> preOrderIteration(TreeNode root) {
    List<Integer> ans = new ArrayList<>();
    if (root == null) { return ans; }
    Deque<Integer> stack = new ArrayDeque<>(); // jdk推荐栈使用双端队列实现

    stack.push(root); // 根节点入栈
    while (!stack.isEmpty()) {
        TreeNode cur = stack.pop();

        ans.add(cur.val); // 访问节点
        if (cur.right != null) { stack.push(cur.right); } // 右节点入栈
        if (cur.left != null) { stack.push(cur.left); } // 左节点入栈
    }

    return ans;
}
```

中序遍历的实现思路是先将左子树所有节点压栈，直到叶子节点再弹出节点访问，然后处理弹出节点的右子树。

```java
public List<Integer> inOrderIterative(TreeNode root) {
    List<Integer> ans = new ArrayList<>();
    if (root == null) { return ans; }
    Deque<Integer> stack = new ArrayDeque<>();

    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
        // 左子树压栈
        while (cur != null) {
            stack.push(cur);
            cur = cur.left;
        }
        // 弹出当前节点并访问
        ans.add(stack.pop().val);
        // 遍历当前节点右子树
        cur = cur.right;
    }

    return ans;
}
```

后序遍历最简单的实现是按照前序遍历的方式访问根->右->左，最后反转结果次序即可。即后序遍历的结果是前序遍历的对称镜像。

另一种方法是标记位法，将栈弹出的节点不访问而是标记，再放回栈中，随后将左右子树入栈。等待其第二次弹出的时候，其左右节点已访问完，此时再访问该节点。通过标记的方式判断节点是否二次出栈。

*注意：同样存在左节点后入栈先出栈的特性*

```java
public List<Integer> postOrderIterative(TreeNode root) {
    List<Integer> ans = new ArrayList<>();
    if (root == null) { return ans; }
    // Object[]{节点: TreeNode，标记: boolean}
    Deque<Object[]> stack = enw ArrayDeque<>();

    stack.push(new Object[]{root, flase});
    while (!stack.isEmpty) {
        Object[] top = stack.pop();
        TreeNode cur = (TreeNode) top[0];
        boolean isVisited = (boolean) top[1];

        if (isVisited) { // 已被标记，二次出栈
            ans.add(cur);
        } else {
            stack.push(new Object[]{cur, true});
            if (node.right != null) { // 右节点先入栈，后出栈
                stack.push(new Object[]{cur.right, false});
            }
            if (node.left != null) { // 左节点后入栈，先出栈
                stack.push(new Object[]{cur.left, false});
            }
        }  
    }

    return ans;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
}
```

### 3.3.2 广度优先遍历

广度优先遍历是一种层序遍历，核心是通过队列FIFO实现层级顺序。

#### 3.3.2.1 迭代实现

每次访问队列弹出的节点后将其左右节点依次入队，实现层级顺序。

```java
public List<Integer> levelOrderIterative(TreeNode root) {
    List<Integer> ans = new ArrayList<>();
    if (root == null) { return ans; }
    Queue<TreeNode> queue = new ListedList<>();

    queue.offer(root);
    while (!queue.isEmpty() {
        TreeNode cur = queue.poll();

        ans.add(cur.val); // 访问节点
        if (cur.left != null) { queue.offer(cur.left); }
        if (cur.right != null) { queue.offer(cur.right); }
    }

    return ans;
}
```

## 3.4 堆

堆是一种特殊的完全二叉树，其必须满足每一个父节点与他的所有子节点都满足相同的逻辑大小关系。按照不同的逻辑大小关系分为：

- 大顶堆（大堆）：所有父节点都**大于**其任意子节点 => 堆顶（root）为最大值。
- 小顶堆（小堆）：所有父节点都**小于**其任意子节点 => 堆顶为最小值。

### 3.4.1 堆的ADT

jdk中无特定堆ADT接口，使用`PriorityQueue`类直接实现堆，其实现了`Queue`接口，故存在`offer`，`peek`等方法（默认小顶堆）。


| Heap操作方法                 | 描述               |
| ---------------------------- | ------------------ |
| `insert` / `add` / `offer`  | 向堆中插入元素     |
| `delete` / `remove` /`poll` | 移除并返回堆顶元素 |
| `peek`                       | 获取堆顶元素       |


| Heap辅助方法 | 描述                                 |
| ------------ | ------------------------------------ |
| `siftUp`     | 将下标指定位置的元素上浮直到符合条件 |
| `siftDown`   | 将下标指定位置的元素下沉直到符合条件 |

### 3.4.2 堆的存储结构

作为严格的完全二叉树，堆存储的最佳实践是数组。

其中下标 **i** 的元素，其左孩子下标 **2 \* i+1**, 右孩子下标 **2 * i + 2**, 父结点下标 **(i - 1) / 2**。

### 3.4.3 堆的代码实现

**实现类定义**

实现类框架如下，包括属性与初始化方法，其中可以允许在构造方法传参进行堆化。

要求堆中的元素必须实现Comparable接口，否则无法比较元素大小。

默认为小顶堆实现，在`PriorityQueue`优先队列可以通过传入自定义的比较器Comparator，比如反转比较器实现大顶堆。

```java
public class MyHeap<T extends Comparable<T>> {
    private T[] heapArray;    // 存储堆元素的数组
    private int size;    // 堆中当前元素的数量
    private static final int DEFAULT_CAPACITY = 10;    // 初始容量

    public MyHeap() { this(DEFAULT_CAPACITY); }

    /** 指定初始容量的构造方法 **/
}
```

**堆化操作**

一种堆化方法为，先初始化一个空堆。随后对数据集的每一个数据执行插入到堆的操作，在插入方法中会自动维持堆序。

另一种堆化方法为，通过在构造方法传入，直接堆化数据集。

如果传入为数组，直接复制该数组，随后从第一个非叶子结点开始下沉操作（下标>=size / 2的元素都为二叉树的叶子，无需下沉）。

```java
public MyHeap(T[] array) {
    if (array == null) { throw new RuntimeException(); }
    size = array.length;
    heapArray = (T[]) new Comparable[size];
    System.arraycopy(array, 0, heapArray, 0, size);
    for (int i = (size / 2 - 1); i >= 0; i--) {
        siftDown(i);
    }
}
```

**上浮操作/向上调整`siftUp`**

上浮操作通过将指定索引`index`的元素与其父节点比较校验后，进行向上移动，维持堆序。

循环的退出条件是当前元素成为根节点（index == 0）或者父结点比较校验不通过（小顶堆中为，当前元素*小于等于*父结点，堆序满足退出循环）。

否则，交换当前元素与父结点元素，此时当前元素与父结点满足堆序，将索引指向父结点继续上浮操作。

```java
private void siftUp(int index) {
    while (index > 0) {
        int parentIndex = (index - 1) / 2;
        if (heapArray[index].compareTo(heapArray[parentIndex]) >= 0) {
            break;
        }
        swap(index, parentIndex);
        index = parentIndex;
    }
}
```

**下沉操作/向下调整`siftDown`**

下沉操作通过将指定索引的元素向下移动，维持堆序。

下沉操作中，当前元素将与自己的子节点中最小值（小顶堆）交换以下沉维持堆序，并更新索引继续向下下沉。故方法中会优先判断左右子节点的存在性与大小，寻找是否有需交换的最小子节点。

```java
private void siftDown(int index) {
    while (true) {
        int leftChildIndex = 2 * index + 1;
        int rightChildIndex = 2 * index + 2;
        int mxIndex = index;

        if (leftChildIndex < size &&
        heapArray[leftChildIndex].compareTo(heapArray[mxIndex] < 0) {
            mxIndex = leftChildIndex;
        }
        if (rightChildIndex< size &&
        heapArray[rightChildIndex].compareTo(heapArray[mxIndex] < 0) {
            mxIndex = rightChildIndex;
        }

        if (mxIndex == index) { break; }
        swap(index, mxIndex);
        index = mxIndex;
    }
}
```

**插入操作**

插入操作会先进行简单校验，如果当前数组已满则扩容。

元素会先插入到堆的最后一个叶子节点，即数组的最后一个位置。随后对这个元素进行上浮操作，直到满足堆序。

```java
public void offer(T element) {
    if (element == null) { throw new RuntimeException(); }
    if (size == heapArray.length) { resize(2 * heapArray.length); }
    heapArray[size] = element;
    size++;
    siftUp(size - 1);
}
```

**弹出/删除操作**

堆的删除操作会弹出堆顶元素，并使剩下的元素保持堆序。

具体实现为，将堆顶元素与最后一个叶子节点元素交换，再删除最后一个节点，再对~被从最后调到~堆顶的元素进行下沉操作维护堆序。

最后，如果堆元素数量为数组长度的$ 1/4 $，缩小堆数组。

```java
private T poll() {
    if (isEmpty()) { throw new RuntimeException(); }
    T val = heapArray[0];
    heapArray[0] = heapArray[size - 1];
    heapArray[size - 1] = null;    // 帮助垃圾回收
    size--;
    if (size > 0) {
        siftDown(0);
    }
    if (size > 0 && size == heapArray.length / 4) {
        resize(heapArray.length / 2);
    }
    return val;
}
```

### 3.4.4 原地堆化

在算法题中，特定题目要求下使用原地堆化的方式可以减少复杂度，实现$O(1)$空间复杂度。

> 给你一个int[] gifts数组表示各堆礼物的数量，每一秒选择礼物最多那堆减少到开方。共k秒

原地堆化（最大堆）：

```java
private void heapify(int[] nums) {
    // 反向遍历：下标 ≥ size / 2 的元素均为二叉树叶子，无需siftDown
    for (int i = nums.length / 2 - 1; i >= 0; i--) {
        siftDown(nums, i);
    }
}
```

下沉方法，每次找左右孩子最大值交换，直到父节点最大 || 没有孩子：

```java
private void siftDown(int[] nums, int i) {
    int n = nums.length;
    while (2 * i + 1 < n) {
        int j = 2 * i + 1; // 左孩子下标
        if (j + 1 < n && nums[j + 1] > nums[j]) {
            j++; // 右孩子更大，更新指向
        }
        if (nums[j] <= nums[i]) {
            break; // 父节点最大，已满足堆序
        }
        swap(nums, i, j); // 交换节点下沉
        i = j;
    }
}
```

在该题目中调用原地堆化方法，手动实现弹出、插入操作，提取`0`位元素，插入堆顶后，对其使用下沉方法自动维护堆序：

```java
class Solution {
    public long pickGifts(int[] gifts, int k) {
        heapify(gifts);
        while (k-- > 0) {
            gifts[0] = (int) Math.sqrt(gifts[0]);
            siftDown(nums, 0);
        }
        long ans = 0;
        for (int x : gifts) {
            ans += x;
        }
        return ans;
    }
}
```

## 3.5 二叉搜索树

二叉搜索树（*Binary Search Tree,  BST*）的本质是二叉树，通过保持父子节点之间的比较逻辑关系，将二分查找的思想映射到树形结构，该树满足以下有序规则：

- 对于任意节点，左子树所有节点的值 < 该节点值 < 右子树所有节点的值；
- 通常不允许重复值，若需要修改其中一边为 ≤ 或 ≥ 即可。

*特征：中序遍历为升序序列*

### 3.5.1 二叉搜索树代码实现

**插入操作**

插入的核心是保持BST的有序性，新节点始终作为叶子节点插入，否则会破坏结构。

- `e.val < 当前节点值`：若左子树空，插入左子树，否则递归遍历左子树；
- `e.val > 当前节点值`：若右子树空，插入右子树，否则递归遍历右子树。

以下代码使用递归调用实现，以插入左子树为例：

- 若左子树为空，传入`root == null`，返回一个新节点，被上层节点设置为左节点；
- 若左子树不为空，`val`被当前节点独立处理，最后返回当前节点原地更新父子指向。

```java
public TreeNode insertBST(TreeNode root, int val) {
    if (root == null) {
        // 递归中, root 表示当前节点
        return new TreeNode(val);
    }
    if (val < root.val) {
        rooot.left = insertBST(root.left, val);
    }
    else if (val > root.val) {
        root.right = insertBST(root.right, val);
    }
    return root;
}
```

**查找操作**

由于 左 < 中 < 右的有序性，只需比较值进入对应子树递归查找：

```java
// 递归版
public TreeNode searchBST(TreeNode root, int target) {
    if (root == null || root.val == target) {
        return root;
    }
    if (target < root.val) {
        return searchBST(root.left, target);
    } else {
        return searchBST(root.right, target);
    }
}

// 迭代版，避免栈溢出，适合大数据
public TreeNode searchBST(TreeNode root, int target) {
    while (root != null && root.val != target) {
        root = target < root.val ? root.left : root.right;
    }
    return root;
}
```

**删除操作**

删除操作要求删除节点后维持BST有序性，对删除情况分类讨论：

- 删除叶子节点：直接删除节点
- 有一个子节点：用子节点替代当前节点
- 有两个子节点：能替代当前节点的有两个：左子树的最大（右）节点和右子树的最小（左）节点。获得其中之一的值复制到当前节点再删除被复制的节点。

```java
public TreeNode deleteBST(TreeNode root, int key) {
    if (root == null) { return null; }
    if (key < root.val) {
        root.left = deleteBST(root.left, key); // 进入左子树
    } else if (key > root.val) {
        root.right = deleteBST(root.right, key);
    } else { // 当前节点是要被删除的节点
        if (root.left == null && root.right == null) {
            return null; // 叶子节点直接给上层节点设置null指向
        } else if (root.right == null) {
            return root.left; // 单节点，返回左子节点给上层节点
        } else if (root.left == null) {
            return root.right; // 单节点
        } else {
            // 寻找左子树的最大（右）节点
            TreeNode successsor = findMax(root.left);
            root.val = successor.val; // 复制节点
            // 删除前驱节点，转化为无子或单子节点情况。
            root.left = deleteBST(root.left, successor.val);
        }
    }
}
// 辅助函数，查找树中的最大节点
private TreeNode findMax(TreeNode node) {
    while (node.right != null) {
        node = node.right;
    }
    return right;
}
```

## 3.6 二叉树的AVL平衡优化

在特殊数据集下，普通二叉树可能退化为链表。因此，通过特定的规则调整树的结构，确保树的高度始终维持在$O(logn)$级别的方法可以保证操作的高效性保持在$O(logn)$。

因此，平衡优化的本质是：动态调整树的结构，限制左右子树的高度差，避免某一子树的过度倾斜。

### 3.6.1 AVL树定义

AVL树是自平衡二叉树，遵循严格平衡策略：高度差严格限制。

AVL树的核心是**平衡因子**: $ 平衡因子 = 左子树高度 + 右子树高度$，要求对任意节点平衡因子绝对值≤1；当执行导致平衡因子违规的操作时，通过**旋转**修正平衡。

AVL树节点类：

```java
class AVLTreeNode {
    int val;
    int balanceFactor;
    AVLTreeNode left;
    AVLTreeNode right;
    // 为了方便，会给节点高度创建属性。出于学习目的，使用较为复杂的实现
    // int height;
    public AVLTreeNode(int _val) {
        val = _val;
        this.balanceFactor = 0;
        this.height = 0;
    }
}
```

**平衡因子的计算**

平衡因子依赖节点的高度：

```java
// 辅助方法：计算节点的高度差
private int getHeight(AVLTreeNode node) {
    if (root == null) { return 0; }
    int leftHeight = getHeight(node.left);
    int rightHeight = getHeight(node.right);
    return Math.max(leftHeight, rightHeight) + 1;
}

// 辅助方法：更新平衡因子
private int uploadBF(AVLTreeNode node) {
    int leftHeight = getHeight(node.left);
    int rightHeight = getHeight(node.right);
    node.balanceFactor = leftHeight - rightHeight;
    return node.balanceFactor;
}
```

**AVL树的失衡**

失衡只会由”插入/删除“操作触发，且失衡节点BF为(±)2；通过失衡节点及其子节点的BF可以判断失衡类型：


| 失衡类型 | 失衡节点BF | 重子数方向 | 重子数的BF | 特征             |
| -------- | ---------- | ---------- | ---------- | ---------------- |
| LL型     | 2          | 左子树     | 1          | 左子树的左子树重 |
| LR型     | 2          | 左子树     | -1         | 左子树的右子树重 |
| RR型     | -2         | 右子树     | -1         | 右子树的右子树重 |
| RL型     | -2         | 右子树     | 1          | 右子树的左子树重 |

### 3.6.2 AVL树的旋转修正

旋转的目标是将失衡因子恢复到{-1, 0, 1}；依据失衡类型需要的旋转类型为：*单旋转*（LL/RR型），*双旋转*（LR/RL型）。本质是通过调整节点之间的父子关系，重新分配子树的高度。

**单旋转**

*（1）右旋转：处理LL型失衡*

将失衡节点的左子树顶替失衡节点的位置，失衡节点下降为该位的右子树，原左子树的右子树划到失衡节点左子树下（BST有序性）。

示例图如下：

括号()标记的子树结构（高度、平衡因子）不变，星号*标记的为重子树

```plaintext
        8                                3
      /   \                            /   \
    3     (9)      右旋转           (1*)     8
  /   \            -------->               /   \
(1*)    (4)                               (4)    (9)
```

代码实现：

```java
private AVLTreeNode rightRotate(AVLTreeNode A) {
    AVLTreeNode B = A.left; // 左子树
    AVLTreeNode T2 = B.right; // 左子树的右子树
    // 调整父子关系
    A.left = T2;
    B.right = A;
    // 更新平衡因子
    updateBF(A);
    updateBF(B);

    return B; // 返回新根节点
}
```

*（2）左旋转：处理RR型失衡*

与右旋转对称，将失衡节点的右子树提升为新的根节点，失衡节点下降为新根左子树。原失衡节点右子树的左子树划到失衡节点的右子树（BST有序性）。

```plaintext
        8                               10
      /   \                            /   \
   (3)     10      左旋转             8     (12*)
          /   \     -------->       /  \
        (9)    (12*)               (3)   (9)
```

代码实现：

```java
private AVLTreeNode leftRotate(AVLTreeNode A) {
    AVLTreeNode B = A.right;
    AVLTreeNode T2 = B.left;
    // 调整父子关系
    B.left =A A;
    A.right = T2;
    // 更新平衡因子
    updateBF(A);
    updateBF(B);

    return B;
}
```

**双旋转**

双旋转是两次单旋转的组合，因为在LR/RL型失衡情况下无法通过一次单旋转恢复平衡，只能一次旋转后化为LL/RR型，再进行对应的单旋转。

*（1）LR型失衡：先左旋转左子树，再右旋转根*

```plaintext
        8                          8                            5*
      /   \                      /   \                       /     \
    3      (9)    左旋转        5*    (9)    右旋转         3         8
  /   \          ------->     /   \         ------->      / \       /  \
(1)    5*         左子树     3    (6)          根        (1) (4)   (6)  (9)
     /     \               /  \
   (4)     (6)           (1)  (4)   
```

*（2）RL型失衡：先右旋转右子树，再左旋转根*

```plaintext
    8                            8                              13*
  /   \                        /   \                         /      \
(3)    15       右旋转        (3)   13*        左旋转        8        15
     /   \    ------->           /   \       ------->     /  \      /  \
    13*  (18)   右子树           (12)  15        根       (3) (12)  (14) (18)
   /  \                               /  \
 (12)  (14)                        (14)  (18)
```

### 3.6.3 AVL树操作代码实现

**插入操作**

```java
public AVLTreeNode insert(AVLTreeNode root, int val) {
    if (root == null) { return new AVLTreeNode(val); }
    // BST规则插入位置
    if (val < root.val) {
        root.left = insert(root.left, val);
    } else if (val > root.val) {
        root.right = insert(root.right, val);
    } else {
        return root;
    }
    // 更新平衡因子、（可选）高度
    int balance = updateBF(root);
    // 失衡处理
    // 1.LL型 -> 右旋根
    if (balance > 1 && val < root.left.val) {
        return rotateRight(root);
    }
    // 2.RR型 -> 左旋根
    if (balance < -1 && val > root.right.val) {
        return rotateLeft(root);
    }
    // 3.LR型 -> 左旋左子树，右旋根
    if (balance > 1 && val > root.left.val) {
        root.left = rotateLeft(root.left);
        return rotateRight(root);
    }
    // 4.RL型 -> 右旋右子树，左旋根
    if (balance < -1 && val < root.left.val) {
        root.right = rotateRight(root.right);
        return rotateLeft(root);
    }

    // 未失衡，返回根节点
    return root;
}
```

**删除操作**

```java
public AVLTreeNode delete(AVLTreeNode root, int val) {
    if (root == null) { return null; }
    // 定位待删除的节点
    if (val < root.val) {
        root.left = delete(root.left, val);
    } else if (val > root.val) {
        root.right = delete(root.right, val);
    } else {
        // 找到待删除结点
        // 1.叶子节点 || 一个子节点
        if (root.left == null) { return root.right; }
        else if (root.right == null) { return root.left; }
        // 2.双子树
        // 寻找右子树最小（左）节点
        AVLTreeNode minRight = findMin(root.left);
        root.val = minRight.val;
        // 删除后继节点
        root.right = delete(root.right, minRight.val);
    }
  
    // 删除后若树为空直接返回
    if (root == null) { return null; }

    // 更新平衡因子
    int balance = updateBF(root);
    // 失衡处理
    // 1.LL型 -> 右旋根
    if (balance > 1 && root.left.balance >= 0) {
        return rotateRight(root);
    }
    // 2.RR型 -> 左旋根
    if (balance < -1 && root.right.balance <= 0) {
        return rotateLeft(root);
    }
    // 3.LR型 -> 左旋左子树，右旋根
    if（balance > 1 && root.left.balance < 0) {
        root.left = rotateLeft(root.left);
        return rotateRight(root);
    }
    // 4.RL型 -> 右旋右子树，左旋根
    if（balance < -1 && root.right.balance > 0) {
        root.right = rotateRight(root.right);
        return rotateLeft(root);
    }
  
    // 未失衡，返回根节点
    return root;
}
```

## 3.7 哈夫曼树

哈夫曼树（最优二叉树）是一类*带权路径最短*的二叉树，通过权重优先级构建树的结构，实现数据的高效编码。

### 3.7.1 哈夫曼树ADT

哈夫曼树的核心操作围绕树的构建和树的编码/解码：


| 操作                          | 描述                                   | 输入              | 输出                     |
| ----------------------------- | -------------------------------------- | ----------------- | ------------------------ |
| buildHuffmanTree(nodes)       | 由叶子节点构建哈夫曼树                 | 叶子节点列表      | 哈夫曼树根节点           |
| generateHuffmanCode(root)     | 基于哈夫曼树生成每个叶子节点的前缀编码 | 哈夫曼树根节点    | 编码映射表（权重->编码） |
| decodeHuffmanCode(root, code) | 用哈夫曼树解码二进制字符串             | 根节点+编码字符串 | 解码数据                 |

### 3.7.2 哈夫曼树的存储结构

哈夫曼树的构建核心是**贪心**+**优先队列**：

每次选取权重最小的两个节点合并为新的节点，直到只剩一个节点。

### 3.7.3 代码实现

**节点类**

哈夫曼树节点类定义：

```java
class HuffmanNode implements Comparable<HuffmanNode> {
    int weight;
    char data;
    HuffmanNode left;
    HuffmanNode right;
  
    // 叶子节点构造方法（权重+字符）
    public HuffmanNode(char _data, int _weight) {
        data = _data;
        weight = _weight;
        left = null;
        right = null;
    }
    // 非叶子节点构造方法（权重，由两个子节点合并）
    public HuffmanNode(int weight, HuffmanNode _left, HuffmanNode _right) {
        weight = _weight;
        left = _left;
        right = _right;
    }

    // 实现Comparable接口，适配最小堆
    @Override
    public int compareTo(HuffmanNode other) {
        return this.weight - other.weight;
    }
}
```

**构建哈夫曼树**

```java
public HuffmanNode buildTree(List<HuffmanNode> leafNodes) {
    if (leafNodes == null || leafNodes.size() == 0) { return null; }
    if (leafNodes.size() == 1) { return leafNodes.get(0); }

    // 创建最小堆，循环合并最小的两个节点，直到只剩一个节点
    PriorityQueue<HuffmanNode> pq = new PriorityQueue<>(leafNodes);
    while (pq.size() > 1) {
        HuffmanNode left = pq.poll();
        HuffmanNode right = pq.poll();

        // 合并新节点（无子符，权重为之和）
        HuffmanNode parent = new HuffmanNode(left.weight + right.weight, left, right);
  
        // 新节点入堆，继续合并
        pq.offer(parent);
    }
  
    return pq.poll(); // 最后剩下的即为根节点
}
```

**生成前缀编码**

```java
public Map<Character, String> generateCode(HuffmanNode root) {
    Map<Character, String> codeMap = new HashMap<>();
    if (root == null) { return codeMap; }
    // 递归遍历，初始为空字符串
    traverseTree(root, "", codeMap);
    return codeMap;
}

// 辅助函数：递归遍历树并记录编码
private void traverseTree(HuffmanNode node, String curCode, Map<Character, String> codeMap) {
    // 叶子节点：记录编码
    if (node.left == null && node.right == null) {
        codeMap.put(node.data, curCode);
    }
    // 左子树：路径加"0"
    if (node.left != null) {
        traverseTree(node.left, curCode + "0", codeMap);
    }
    if (node.right != null) {
        traverseTree(node.right, curCode + "1", codeMap);
    }
}
```

**哈夫曼解码**

```java
public List<Character> decode(HuffmanNode root, String code) {
    List<Character> result = new Arraylist<>();
    if (root == null || code == null || code.isEmpty) {
        return result;
    }
    HuffmanNode cur = root;
    for (char c : code.toCharArray()) {
        if (c == '0') { // 0 -> 左子树
            cur = cur.left;
        } else if (c == '1') { // 1 -> 右子树
            cur = cur.right;
        } else {
            throw new RuntimeException();
        }
        // 到达叶子节点：记录字符，重置根，准备解码下一个字符
        if (cur.left == null && cur.right == null) {
            result.add(cur.data);
            cur = root;
        }
    }
    return result;
}
```

### 3.7.3 复杂度分析

#### 3.7.3.1 时间复杂度


| 操作           | 时间复杂度 | 说明                            |
| -------------- | ---------- | ------------------------------- |
| 构造哈夫曼树   | $O(nlogn)$ | 对n个节点执行提取+合并+入堆操作 |
| 生成哈夫曼编码 | $O(n)$     | 递归遍历树                      |
| 解码           | $O(m)$     | m为编码字符串长度，遍历字符串   |

#### 3.7.3.2 空间复杂度

- 整体空间复杂度：$O(n)$，用于存储哈夫曼树节点和编码映射表；
- 递归空间：$O(logn)$，哈夫曼树为平衡二叉树。