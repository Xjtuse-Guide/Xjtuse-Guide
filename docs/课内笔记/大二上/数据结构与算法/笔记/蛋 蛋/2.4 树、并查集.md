# 4.树、并查集

二叉树是特殊的树：二叉树允许每个节点最多有两个子节点，而树结构允许若干子节点的存在。

若干树的集合构成一个森林（空树为空森林，1棵树即为单树）。

## 4.1 树的存储结构

Java无原生多叉树类，需自定义实现，最常用的是孩子兄弟表示法。

### 4.1.1 孩子链表

每个节点存储数据+子节点链表（适合节点度数不定）

### 4.1.2孩子数组法

每个节点存储数据+固定大小的子节点数组（适合节点度数固定k叉树，二叉树k=2）。

### 4.1.3 孩子兄弟表示法

将多叉树转换为二叉树存储，通过约束规范，对每一个节点：

- 左指针：指向该节点的第一个子节点
- 右指针：指向其下一个兄弟节点

## 4.2 树的基本代码实现

基于孩子兄弟表示法实现的多叉树类：

**节点类定义**

```java
public class TreeNode {
    int val;
    TreeNode firstChild; // 第一个子节点
    TreeNode nextSibling; // 下一个兄弟节点

    public TreeNode(int val) {
        val = _val;
        firstChild = null;
        nextSibling = null;
    }
}
```

## 4.3 树的遍历

基于孩子兄弟表示法，树的遍历可以分为：

- 前序遍历：根 -> 子 -> 兄弟
- 后序遍历：子 -> 兄弟 -> 根
- 层序遍历：按层次访问

### 4.3.1 树的前序遍历

遍历逻辑：先访问当前节点 -> 递归遍历第一个子节点 -> 遍历子节点的所有兄弟节点

代码实现：

```java
// 前序递归遍历
private void preOrderRecursive(TreeNode node, List<Object> result) {
    if (node == null) { return; }
    result.add(node.val);
    TreeNode child = node.firstChild; // 第一个孩子节点
    // 循环遍历兄弟链表
    while (child != null) {
        preOderRecursive(child, result);
        child = child.nextSibling;
    }
}
```

### 4.3.2 树的后序遍历

遍历逻辑：该递归遍历会先递归到子-兄弟链表进行访问，最后回退上一层的时候再访问父节点。

先递归遍历当前节点的第一个子节点 -> 遍历子节点的所有兄弟节点 -> 访问当前节点。

```java
public void postOrderRecursive(TreeNode node, List<Integer> result) {
    if (node == null) { return; }
    TreeNode child = node.firstChild;
    while (child != null) {
        postOrderRecursive(child, result);
        child = child.nextSibling;
    }
    result.add(node.data);
}
```

### 4.3.3 树的层序遍历

遍历逻辑：树的层序遍历基于队列实现，每次访问出队节点，并把出队节点的所有子节点入队，直到队列为空。

```java
public List<Integer> levelOrderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null) { return result; }
    Queue<TreeNode> queue = new LinkedList<>(); // 队列
    queue.offer(root); // 根节点入队
    while (!queue.isEmpty()) {
        TreeNode cur = queue.poll();
        result.add(cur.val);
        TreeNode child = cur.firstChild; // 第一个子节点
        while (child != null) { // 遍历入队兄弟节点
            queue.offer(child);
            child = chid.nextSibing;
        }
    }
    return result;
}
```

## 4.5 森林的存储结构

森林是m颗互不相交的树的集合（m=0为空森林，m=1为单棵树）。

基于孩子兄弟表示法，森林可以转换为二叉树存储：

1. 森林中的每棵树的根节点视为“兄弟关系”；
2. 用第一棵树的根节点作为二叉树的根

## 4.6 并查集的ADT

**并查集（Union-Find/Disjoint Set）**，是一种用于*管理集合合并与查询*的数据结构。

并查集的入门重点是理解“找根（find）”、“合并（union）”、“判断连通（isSame）”三大核心操作，在此基础上引入路径压缩、按秩合并优化。

并查集的ADT：


| 操作方法                              | 描述                                        |
| ------------------------------------- | ------------------------------------------- |
| `initialize(n)`                       | 初始化并查集，创建n个独立集合，每个元素独立 |
| `find(x)`                             | 查找元素x所在集合的根节点（同时路径压缩）   |
| `union(x, y)` /<br /> `merge(x, y)` | 合并元素x和y所在集合                        |
| `isSame(x, y)`                        | 判断两个元素是否在同一集合                  |
| `getSize(x)`                          | 返回x所在集合的大小                         |

其设计核心在于：

- *代表元/根*：每个集合的代表元素
- 双亲表示法：用数组`parent[]`存储每个元素的父节点索引，当`parent[x]=x`时表示*该节点是自己所在元素的代表元/根*。
- 路径压缩：`union`合并操作需要两次`find`，是复杂度的主要影响因子。通过路径压缩，**在查找的时候**完成，使树结构扁平化，让每个节点指向根节点降低查找成本。
- 按秩合并：通过`rank`秩表示树的高度，矮树合并高树。

**关于树的临时高度**：在`merge`操作中，会将from元素所在集合合并到to元素所在集合，实现是将from元的代表元的父节点不再指向自己而是to元素的代表元。此时，原from元素所在集合除代表元外， 元素都是间接指向现在的代表元（from -> x -> y），造成树高度增加，如果没有`find`操作更新指向，不断合并，树的高度可能会进一步增高。**这只是理论，实际树高极大多在1~2**

**关于路径压缩与按秩合并**：*两者并不存在联动，是独立的优化方向*，都可以单一使用；甚至路径压缩的时候不会更新集合的秩，但可能会降低树的高度，导致rank虚高（rank停留在历史的最高高度）！使得这里rank成为合并时的保守估计值。**但即使如此也不会造成困扰**，rank只会让合并方向不激增，仍旧发挥作用，最差也是正常合并。

*对于多数算法题和实践中，不存在合并远远大于查询的情况，路径压缩足够高效，按秩合并的优化效益并不明显，且有的时候需要手动指定合并方向。因此，手动合并方向的`merge`使用远高于倾向自动合并（如有按秩合并）的`union`操作。*

*因此在算法实践中，一般不定义`union`操作与秩记录数组，只保留`merge`操作。*

## 4.7 并查集的代码实现

并查集的实现模板：

```java
class UnionFind {
    private final int[] parent; // 代表元/父元
    private final int[] size; // 各集合大小
    private final int[] rank; // 各集合的秩（按秩合并优化）
    public int cc; // 集合个数

    public UnionFind(int n) {
        parent = new int[n]; // 初始化
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
        size = new int[n];
        rank = new int[n];
        Arrays.fill(size, 1);
        Arrays.fill(rank, 1);
        cc = n;
    }
  
    // 查找x的根，沿路元素最后都直接指向根（路径压缩优化）
    public int find(int x) {
        if (parent[x] != x) {
            // x不是集合的根，让x的父节点指向根
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
  
    // 判断x和y是否在同一集合中
    public boolean isSame(int x, int y) {
        return find(x) == find(y);
    }
  
    // 把x与y所在集合按秩合并
    public boolean union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX == rootY) { return false; }
  
        if (rank[rootX] < rank[rootY]) {
            parent[rootX] = rootY;
            size[rootY] += size[rootX];
        } else if (rank[rootX] > rank[rootY]) {
            parent[rootY] = rootX;
            size[rootX] += size[rootY];
        } else {
            // 两颗树的秩相等，合并后新树高度+1
            parent[rootY] = rootX;
            size[rootX] += size[rootY];
            rank[rootX]++;
        }

        cc--;
        return true;
    }

    // 把from所在集合合并到to所在集合中
    public boolean merge(int from, int to) {
        int x = find(from);
        int y = find(to);
        if (x == y) {
            return false; // 在同一集合中，不做合并。
        }
        parent[x] = y; // 修改from集合的根父节点指向
        size[y] += size[x]; // 更新集合大小
        cc--; // 合并后集合数量-1
        return true;  
    }

    public int getSize(int x) {
        return size[find(x)]; // 集合大小保存在代表元上
    }
}
```

## 4.8 复杂度分析

树的复杂度与二叉树没有本质区别，现分析并查集的复杂度。

### 4.8.1 时间复杂度

并查集的核心操作是：`find`查找根操作和`union` / `merge`合并集合操作，其中`union`操作包括两次`find`操作，故复杂度主要取决于`find`操作。


| 并查集优化 | find / union复杂度 | 说明                                                           |
| ---------- | ------------------ | -------------------------------------------------------------- |
| 无优化     | $O(n)$             | 在无约束的最坏情况下，合并操作使树高线性增长，最坏情况形成链表 |
| 按秩合并   | $O(logn)$          | 按秩合并下，树高增长速度不会超过$O(logn)$，无最坏情况退化      |
| 路径压缩   | $O(α(n))/O(n)$    | 路径压缩会拉平树结构，每次find后元素指向根，树高维持1~2        |

$α(n)$反阿克曼函数，近乎常数：

阿克曼函数A(m, n)是“快速增长”函数，反阿克曼函数是逆函数。其增长缓慢达到了：当n≤2^25565时，α(n)≤5，在实际使用中完全将其视作常数。

双优化下与路径压缩单优化无可观测差异，工程上优先使用路径压缩优化的并查集。

### 4.8.2 空间复杂度

并查集空间复杂度始终为$O(n)$，是空间高效的数据结构。

- 基础空间复杂度：$O(n)$，用于`parent`、`rank`、`size`，均为长度为n的数组。
- 优化空间复杂度：$O(1)$，几乎没有空间开销。