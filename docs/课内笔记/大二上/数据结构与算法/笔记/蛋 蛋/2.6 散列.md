# 6.散列

## 6.1 哈希函数映射

**散列**是通过**哈希函数**将任意的输入（键）映射到确定的输出（值），由此形成***键-值对***的常数级查找，这种映射的黑匣子就是哈希函数。

哈希函数的关键要素：

- 均匀分布：尽可能使得不同的输入能够得到不同的输出；
- 哈希冲突：如果不同的输入得到了相同的输出，哈希冲突必须解决。

哈希冲突的解决方案：

- 拉链法：冲突元素存入同一索引的链表/红黑树（HashMap主流方案，≥8红黑树），冲突下查找复杂度不再是常数级；
- 开放寻址法：冲突时按固定规则（二次探测等）寻找下一个空位置。

## 6.2 散列ADT

散列的本质是键值对（python中的字典），在Java中实现即为哈希表。

核心操作方法如下：


| 操作方法                      | 描述                           |
| ----------------------------- | ------------------------------ |
| `insert(k, v)` / `put(k, v)` | 插入键值对，若键已存在则更新值 |
| `search(k)` / `get(k)`       | 根据键查找对应值               |
| `delete(k)` / `remove(k)`    | 根据键删除键值对               |
| `isEmpty()`                   | 判断哈希表是否为空             |
| `size()`                      | 获取哈希表的键值对数量         |
| `clear()`                     | 清空哈希表                     |

*jdk中Object类拥有`hashCode`方法，所有类继承拥有，可以重写，作为hash值的判断比较，在需要比较hash的时候被调用。*

## 6.3 散列的存储结构

散列的存储核心是哈希表，底层依赖两种主流结构解决哈希冲突。

### 6.3.1 拉链法

拉链法的底层结构分为：

- 数组（桶数组）：每个元素是链表/红黑树的头结点
- 链表/红黑树：元素放入桶中，若已有元素，添加到链表/红黑树的尾部

### 6.3.2 开放寻址法

开放寻址法仅用数组作为存储载体，使用探测机制二次映射：

- 线性探测：依次往后找
- 二次探测：索引±i²
- 双重哈希：再用一个哈希函数映射

该方法无需额外空间，访问局部性好；但容易导致冲突元素聚集。

## 6.4 散列的代码基本实现

散列在Java中的主流就是哈希表`HashMap`，底层是拉链法。

**类定义**

在`HashMap`中，键值对通过定义实体类`Entry`封装。

同时我们设置负载因子属性，在元素过多的时候，对哈希表存储数组扩容。

```java
public class HashMap<K, V> implements Map<K, V> {
    private LinkedList<Entry<K, V>>[] table; // 哈希表，桶数组
    private int size; // 键值对数量
    private static fianl int DEFAULT_CAPACITY = 16;
    private static final floadt LOAD_FACTOR = 0.75f; // 负载因子阈值
    // 键值对实体类
    private static Entry<K, V> {
        K key;
        V val;

        Entry(K _key, V _val) {
            key = _key;
            val = _val;
        }
    }
    // 构造函数
    public HashMap() {
        table = new LinkedList[DEFAULT_CAPACITY];
        for (int i = 0; i < table.length; i++) {
            table[i] = new LinkedList<>();
        }
        size = 0;
    }
    // 哈希函数：计算键的哈希值，转化为数组索引
    private int hash(K key) {
        if (key == null) return 0;
        int hash = key.hashCode();
        return Math.abs(hash) % table.length;
    }
    // 辅助方法：扩容数组 -> 当负载因子≥阈值
    private void resize() {
        LinkedList<Entry<K, V>>[] oldTable = table;
        table = new LinkedList[oladTable.length * 2];
        for (int i = 0; i < table.length; i++)  {
            table[i] = new LinkedList();
        }
        size = 0; // 重置size，重新插入（长度改变，hash映射结果可能变化）
        for (LinkedList<Entry<K, V>> list : oladTable) {
            for (Entry<K, V> entry : list) {
                insert(entry,key, entry.val);
            }
        }
    }
}
```

**插入操作**

```java
public void insert(K key, V val) {
    // 检查扩容
    if ((float) size / table.length >= LOAD_FACTOR) {
        resize();
    }
    int index = hash(key);
    LinkedList<Entry<K, V>> list = table[index];
    // 遍历链表，若键已存在更新值
    for (Entry<K, V> entry : list) {
        if (entry.key.equals(key)) {
            entry.val = val;
            return;
        }
    }
    // 若键不存在，添加节点
    list.add(new Entry<>(key, val));
    size++;
}
```

**查找操作**

```java
public V search(K key) {
    int index = hash(key);
    LinkList<Entry<K, V>> list = table[index];
    for (Entry<K, V> entry : list) {
        if (entry.key.equals(key)) {
            return entry.val;
        }
    }
    return null;
}
```

**删除操作**

```java
public V delete(K key) {
    int index = hash(key);
    LinkedList<Entry<K, V>> list = table[index];
    for (Entry<K, V> entry : list) {
        if (entry.key.equals(key)) {
            V val = entry.val;
            list.remove(entry);
            size--;
            return val;
        }
    }
    return null;
}
```