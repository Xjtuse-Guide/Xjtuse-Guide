# 2.队列、栈

**注意，队列和栈都符合线性表的定义**：元素间一对一线性关系，但他们是受限的线性表。

队列和栈作为一种线性数据结构，受限在于：

- 队列：遵循先进先出（FIFO），先进入队列的元素先离开。
- 栈：遵循先进后出（LIFO），后进入栈的元素先离开。

*在jdk中，栈和队列不直接实现`List`接口，故与基本线性表单独讨论。*

## 2.1 队列的ADT

FIFO要求队列可以在队尾插入元素，队首删除元素。


| Queue 操作方法             | 说明                           |
| -------------------------- | ------------------------------ |
| `enqueue(e)` / `offer(e)` | 向队尾插入元素，队列长度+1     |
| `dequeue()` / `poll()`    | 删除并返回队首元素，队列长度-1 |
| `getFront()` / `peek()`   | 不改变队列结构，获得队首元素   |

在标准列表基础之上，如果允许双端插入、删除操作，我们称之为双端队列。

## 2.2 队列的存储结构

### 2.2.1 链表结构

标准队列的一个最佳实践是使用双向链表存储，通过头、尾结点访问队列的双端。

*jdk中`LinkedList`类实现了`List`和`Queue`接口，是标准队列的jdk实现；jdk中双端队列有特定接口`Deque`，常用动态数组实现`ArrayDeque`*

### 2.2.2 动态数组实现

基于数组的空间连续性可以很自然地维护队列顺序，但是经过插入、删除操作，显然队列的头索引不会一直维护在`0`位（否则每次删除都需要复制整个队列）。

因此，我们一般会维护：队首索引`front`，队尾索引`rear`，队列长度`size`，存储的数组结构长度`capacity`

为了防止索引越界，我们在索引运算中会对数组结构长度`capacity`取余。

一般队首或队尾索引之一不会直接指向而是指向前驱或后继位置，以此优化结构：


| 设计条件 | 索引直接指向               | 队首索引指向队首前驱       |
| -------- | -------------------------- | -------------------------- |
| 队首位置 | $front$                    | $(front+1)\%capacity$      |
| 空队列   | $front=rear$               | $front=rear$               |
| 满队列   | $(rear+1)\%capacity=front$ | $(rear+1)\%capacity=front$ |

## 2.3 队列的基本代码实现

### 2.3.1 链表实现

jdk中与双端队列`LinkedList`一致，本文中与1.3双端队列`DoubleLinkedList`一致，只需要实现对应的接口方法即可。

### 2.3.2 动态数组实现

基本数据结构都推荐使用泛型来增强代码的健壮性。

索引$index$移动需要特别注意：

- 后移：直接增加越界，采用取余实现循环$(index + 1) \% capacity$
- 前移：0直接减少为-1，需要预处理$(index-1+capacity)\%capacity$

由于双端队列覆盖了标准队列的功能，且功能扩展的实用性，此处代码实现双端队列。

**实现类定义**

```java
public class ArrayDeque<T> implements Deque<T> {
    private T[] queue; // 队列的数组存储
    private int front; // 队首前驱位置
    private int rear; // 队尾位置
    private int size;  // 队列长度
    private int capacity; // 数组容量（包括空前驱）
    private static final int DEFAULT_CAPACITY = 10; // 默认容量
  
    public ArrayDeque() {
        this.(DEFAULT_CAPACITY);
    }
    public ArrayDeque(int _capacity)  {
        capacity = _capacity;
        T[] queue = (T[]) new Object[capacity];
        front = -1;
        rear = 0;
        size = 0;
    }
}
```

**插入操作**

jdk中，`enqueue`的方法实现是`add`与`offer`，两者区别在于，添加失败的时候add方法抛出异常，offer操作不抛出异常。`remove`与`poll`同理。

本次代码基本实现中，不会特别实现异常设计，`offer`与`add`类方法没有区别，同理其他方法设计。标准队列的方法设计可以直接调用双端队列的方法。

`checkE`方法校验传入参数是否异常，比如空指针，

```java
// 队尾入队
public void enqueueLast(T element) {
    checkE(element);
    // 容量满扩容
    if ((rear + 1) % capacity == front) { resize(capacity * 2); }
  
    rear = (rear + 1) % capacity; // rear后移
    queue[rear] = element;
    size++;
}

// 队首入队
public void enqueueFirst(T element) {
    checkE(element);
    // 容量满扩容
    if ((rear + 1) % capacity == front) { resize(capacity * 2); }

    queue[front] = element; // 空前驱位直接修改  
    front = (front - 1 + capacity) % capacity; // front前移
    size++;
}

// offer方法 -> enqueueLast
public void offer(T element) { enqueueLast(element); }
```

**删除操作**

`checkQ`校验队列是否存在异常，比如队列为空，

```java
// 队首出队
public T dequeueFirst() {
    checkQ();
  
    front = (front + 1) % capacity; // front后移
    T element = queue[front];
    queue[front] = null; // 帮助垃圾回收
    // 如果队列太短缩容数组
    if (size < capacity / 4 && size > DEFAULT_CAPACITY) {
        resize(capacity / 2);
    }

    return element;
}

// 队尾出队
public T dequeueLast() {
    checkQ();

    T element = queue[rear];
    rear = (rear - 1 + capacity) % capacity; // rear前移
    queue[rear] = null; / 帮助垃圾回收
    // 如果队列太短缩容数组
    if (size < capacity / 4 && size > DEFAULT_CAPACITY) {
        resize(capacity / 2);
    }

    return element;
}

// poll -> dequeueFirst
public T poll() { return dequeueFirst; }
```

**查询操作**

对队首元素的获取需要注意空前驱的定义。

```java
// 获得队首元素
public T getFirst() {
    return queue[(front + 1) % capacity];
}

// 获得队尾元素
public T getLast() {
    return queue[rear];
}

// peek -> getFirst
public T peek() {
    return getFirst;
}
```

## 2.3 栈ADT

栈需要满足LIFO原则（last in first out），先入后出。


| Stack 操作方法 | 说明         |
| -------------- | ------------ |
| `push(e)`      | 将元素e入栈  |
| `pop()`        | 弹出栈顶元素 |
| `peek()`       | 获取栈顶元素 |

*在jdk`Stack`类已被弃用，其在jdk早期引入，基于`Vector`动态数组类实现，存在结构性设计问题。栈方法需求同时存在`Deque`接口中，jdk官方推荐使用Deque实现类来使用栈。*

栈与队列在实现上存在高度一致性。

## 2.4 栈实现

参考Deque实现，只需添加以下方法映射：


| 栈        | 队列              |
| --------- | ----------------- |
| `push(e)` | `enqueueFirst(e)` |
| `pop()`   | `dequeueFirst(e)` |
| `peek()`  | `getFirst()`      |

## 2.5 复杂度分析

### 2.5.1 时间复杂度分析

只分析循环数组实现的队列/栈，链表实现参考1.4.2 DoubleLinkedList时间复杂度分析。


| 操作         | 最坏时间复杂度 | 均摊时间复杂度 | 说明                                       |
| ------------ | -------------- | -------------- | ------------------------------------------ |
| `enqueue(e)` | $O(n)$         | $O(1)$         | 扩容复制数组$O(n)$，但频率低，均摊后$O(1)$ |
| `dequeue()`  | $O(1)$         | $O(1)$         | 仅修改指针，无需移动元素                   |
| `peek()`     | $O(1)$         | $O(1)$         | 直接访问指针                               |

### 2.5.2 空间复杂度分析

只分析循环数组实现的队列/栈，链表实现参考1.4.2 DoubleLinkedList时间复杂度分析。

- 基础空间复杂度：$O(n)$
- 额外空间复杂度：$O(1)