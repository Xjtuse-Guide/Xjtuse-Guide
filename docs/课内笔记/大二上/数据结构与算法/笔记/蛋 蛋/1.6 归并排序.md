# 6.归并排序

## 6.1 算法原理

归并排序（Merge Sort）的核心也是分治思想：

- 分（Divide）：将待排序的数组递归拆分为两个（近似）等长的子数组，直到长度为1；
- 治（Conquer）：将两个已有序子数组合并为更大的有序数组，递归向上合并。

拆到最小后，两个子数组每每合并，再合并，直到只剩一个数组。

减少时间复杂度的地方在于，将两个有序数组合并为一个有序数组的时间复杂度是$O(n)$；而只有一个元素的子数组（即最小子数组）天然有序，所以从最小子数组开始向上合并。

## 6.2 代码实现

与快速排序相同，先封装一个路口函数处理一下边界情况，再执行归并排序。

特别的，归并排序需要用到额外空间存储临时数据，可以在路口函数创建并传入，减少创建对象次数。

```java
public void sort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    // 临时数组，用于合并中存储数据，避免重复创建对象
    int[] temp = new int[arr.length];
    mergeSort(arr, 0, arr.length - 1, temp);
}
```

*边界：当区间为空（$left>rightleft>right$）或只有1个元素（$left=rightleft=right$），无需处理。*

**分治：**

`mergeSort`方法分治地将数组区间$[left,right]$分为两半，左子数组区间$[left,mid]$，右子数组区间$[mid+1,right]$。

递归的角度看，`mergeSort`将不断把数组区间一分为二，直到有序（最小子数组天然有序），然后通过`merge`方法合并两个有序数组，合并完成后向上返回，与另一个有序子数组合并。

两个有序数组的合并是减少时间复杂度的直接原因，该代码实现采取双指针临时数组法实现：

**合并：**

`merge`方法：合并两个**有序子数组**。

其中，`temp`数组用`left`和`right`映射出了一个区间用于存储已排序的元素，每次合并，`temp`的$[left,right]$区间的所有位置都会被两个子数组的元素覆盖，可以不断复用。

**双指针法：**

左子数组索引$[left,mid]$，右子数组索引$[mid+1,right]$，临时数组映射$[left,right]$。

用`i`指向左子数组第一个待排序的元素，`j`指向右子数组第一个待排序的元素，`k`指向`temp`中未排序的第一个位置，初始为$left$。

每次比较`i`、`j`这两个指向的元素，较小的那个元素加入`temp`数组，并将相应的指针后移一位。

这个比较循环的条件是两个指针都不超过边界（$i≤mid，j≤right$）。

当比较循环退出时，最多只有一个子数组还没遍历完，用追加循环最后遍历掉，逐个加入`temp`。

最后，`arr`数组没有变化，有序序列存在于`temp`之中，但是索引是一一对应的关系，拷贝回来即可。`merge`方法结束后，对于`arr`数组，传入参数指示的$[left,right]$区间有序。

```java
private void mergeSort(int[] arr, int left, int right, int[] temp) {
    if (left >= right) { return; }
    int mid = left + (right - left) / 2; // 求平均值，该写法防止数据溢出
    // 递归拆分左子数组
    mergeSort(arr, left, mid, temp);
    // 递归拆分右子数组
    mergeSort(arr, mid + 1, right, temp);
    // 左右子数组有序，合并
    merge(arr, left, mid, right, temp);
}

private void merge(int[] arr, int left, int mid, int right, int[] temp) {
    int i = left; // 左子数组指针
    int j = mid + 1; // 右子数组指针
    int k = left; // 临时数组指针，与合区间左端对齐
  
    // 双指针遍历左、右子数组
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++]; // 左子数组元素小，存入临时数组，相应指针后移
        } else {
            temp[k++] = arr[j++]; // 右子数组元素小，存入临时数组，相应指针后移
        }
    }
    // 将左子数组剩余元素存入（若左子数组剩余，右子数组一定不剩）
    while (i <= mid) {
        temp[k++] = arr[i++];
    }
    // 将右子数组剩余元素存入（若右子数组剩余，左子数组一定不剩）
    while (j <= right) {
        temp[k++] = arr[j++];
    }
  
    // 将临时数组形成的有序结果拷贝回原数组
    for (k = left; k <= right; k++) {
        arr[k] = temp[k];
    }
}
```

## 6.3 复杂度分析

### 6.3.1 时间复杂度

所有情况的时间复杂度都是*O(n logn)*，无论数组是否有序，都需要*log n* 层的拆分和*n*层合并。

### 6.3.2 空间复杂度

需要长度为n的临时数组`temp`存储合并结果，同时递归拆分需要栈空间深度*log n*，但临时数组是主要开销：

整体空间复杂度*O(n)*。