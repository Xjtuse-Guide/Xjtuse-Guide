# 5.图

## 5.1 图的ADT

图是一种**描述元素间多对对关系的非线性数据结构**，核心为“顶点/节点”和“边”。

数学定义：$G=(V, E)$，其中，V为顶点集合，E为边集合；

因此派生概念有：

- 度：无向图为顶点关联边数，有向图还依出入顶点分为“入度”和“出度”。
- 权重：边的附加信息，边拥有权重的图称为“带权图”，否则为“无权图”。

## 5.2 图的存储结构

图存储的本质是“记录顶点集合”和“记录边的关系”，核心方法分为邻接矩阵表示法和邻接表表示法。

### 5.2.1 邻接矩阵表示法

**原理**

用`V*V`的二维数组`graph`存储，其中`graph[i][j]`表示顶点`i`与`j`的边：

- 无权无向图：`graph[i][j] = 1`表示有边，`0`表示无边。*graph[i][j] = graph[j][i]*
- 有权有向图：`graph[i][j] = weight`表示边权为`weight`，∞表示无边。

**复杂度**

空间复杂度$O(V×V)$，对边的查询支持随机查询（直接访问数组元素）。

### 5.2.2 邻接表表示法

**原理**

用数组+链表/顺序表存储：

- 数组`adj`存储所有顶点；
- 列表`adj[i]`存储顶点`i`直接关联的顶点（或`<邻接顶点，权重>`对）

**复杂度**

空间复杂度$O(V+E)$，仅存储实际边，在稀疏图中高效。

遍历顶点的所有邻接边时间复杂度$O(degree(i))$，需要遍历`adj[i]`列表。

## 5.3 图的遍历

图的遍历主要是对顶点的遍历，主要分为：**深度优先遍历**和**广度优先遍历**。

### 5.3.1 邻接矩阵的遍历

邻接矩阵`matrix[n*n]`，记录数组`visited[n]`，访问结果`List<> result`

#### 深度优先遍历

深度优先遍历主要基于递归实现，访问当前节点后对下一个关联节点递归遍历。

```java
public void dfs(int cur, boolean[] visited, List<Integer> result) {
    visited[cur] = true; // 标记首元素
    result.add(cur); // 访问当前顶点
    // 遍历第i行矩阵，找到有相连的顶点，递归深度遍历
    for (int next = 0; next < n; next++) {
        if (matrix[cur][next] != Integer.MAX_VALUE && !visited[next]) {
            dfs(next, visited, result);
        }
    }
}
```

#### 广度优先遍历

广度优先遍历主要基于队列实现：访问出队元素，并将出列元素的邻接顶点入队，直到队列为空。

```java
public void bfs(int start, boolean[] visited, List<Integer> result) {
    Queue<Integer> queue = new LinkedList<>();
    queue.offer(start); // 首元素入队
    visited[start] = true; // 标记首元素已入队

    while (!queue.isEmpty) {
        int cur = queue.poll();
        result.add(cur); // 访问出队元素，第一个被弹出的是首元素
        // 遍历与cur相连的的顶点，标记后入队
        for (int next = 0; next < matrix.length; next++) {
            if (matrix[cur][next] != Integer.MAX_VALUE && !visited[next]) {
                visited[next] = true; // 标记该元素并入队
                queue.offer(next);
            }
        }
    }
}
```

### 5.3.2 邻接表遍历

邻接表`List<List<Edge>> adj`，记录数组`visited[n]`，访问结果`List<> result`；

其中`Edge`类可以是节点类`Edge.weight, Edge.target`，也可以是个`Object/int`数组`{权重，邻接节点}`。

#### 深度优先遍历

```java
public dfs(int cur, boolean[] visited, List<Integr> result) {
    visited[cur] = true; // 标记顶点
    result.add(cur); // 访问顶点
    // 遍历当前顶点的所有邻接边，找到未访问的邻接顶点，递归深度遍历
    for (Edge edge : adj.get(cur)) {
        int next = edge.target;
        if (visited[next]) {
            dfs(next, visited, result);
        }
    }
}
```

#### 广度优先遍历

```java
public void bfs(int start, boolean[] visited, List<Integer> result) {
    Queue<Integer> queue = new LinkedList<>();
    queue.offer(start); // 首顶点入队
    visited[start] = true; // 首顶点入队标记

    while (!queue.isEmpty) {
        int cur = queue.poll();
        result.add(cur); // 访问出队元素
        // 遍历邻接边，入队所有未入队的邻接顶点
        for (Edge edge : adj.get(cur)) {
            int next = edge.target;
            if (!visited[next]) {
                visited[next] = true; // 标记邻接顶点并入队
                queue.offer(next);
            }
        }
    }
}
```

## 5.4 Dijkstra 算法

### 5.4.1 算法原理

Dijkstra算法可从一个顶点出发，算出在有权图（权值非负）中到达其他顶点的最短路径。

***算法基本原理***

Dijkstra算法的本质是**贪心**+**松弛**：

- 贪心：每次优先处理距离起点最近的顶点
- 松弛：对于顶点`U`、`V`，他们互为邻接顶点，已记录他们到起点的最短距离为$u$和$f$，他们之间的边权值为$d$。显然，如果$u + d < f$，那么从起点到`V`的最短路径不再是原有的路径，而应该更新为绕道`U`的曲线救国路径。

贪心+松弛下：每次拿出来处理的`U`都是距离起点最近的顶点，那么之后处理的顶点距离一定都大于该值，即`U`被拿出来处理时，其最短距离已经确定，不可能更短了。

一般我们会维护：

- 距离表：记录当前所有顶点距离起点的最短路径
- 优先队列：维护当前距离起点距离最近的顶点

**初始**的时候，距离表除了起点到自身为0外，所有值都为∞，表示不可到达；优先队列进入起点。

*接下来，直到队列为空或找到目标点（如果有的话），退出循环。*


| 循环操作            | 描述             | 作用                         |
| ------------------- | ---------------- | ---------------------------- |
| 获得当前最近顶点`U` | 获取优先队列首位 | 基于该顶点，更新所有邻接顶点 |
| 更新邻接距离表`V`   | $u + d < f$      | `V`存在新的最短路径，更新    |
| 确认`U`最短路径     |                  |                              |

### 5.4.2 算法代码实现

由于矩阵表示法、邻接图表示法的不同，以及实现的多样化，Dijkstra算法实现也具有多样性。

出于目的的不同，还需要使用不同的辅助结构：

- 访问表：保证遍历的不可逆性
- 前驱表/后驱表：记录特定终点的最短路径上的每个顶点，便于回溯

> 示例：记有权无向图G=(V, E)，|V|=n，起点为A（start）
>
> 使用数组映射顶点，列表表示邻接表：`List<List<int[]>> adj`

**初始化**

初始的时候，只有A节点被访问，因此`dist`中，A节点到自身距离为0，其他所有节点的距离值均为无穷大（代码中设为整型的最大值`Integer.MAX_VALUE`）。同时，A节点进入优先队列等待处理其邻接节点。

```java
// 距离表
int[] dist = new int[n];
Arrays.fill(dist, Integer.MAX_VALUE);
dist[start] = 0;
// 优先队列 int[]{顶点索引，与起点当前距离}
PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[1] - b[1]));
pq.offer(new int[]{start, 0})

// 辅助结构
boolean[] visited = new boolean[n]; // 访问表
int[] prev = new int[n]; // 前驱表
Arrays.fill(prev, -1); // 初始化-1，无前驱
```

**循环**

每次循环中，从优先队列获取距离起点最近的顶点`cur`，进行如下处理：

从邻接表获取`cur`的所有邻居，基于此更新所有邻居的最短距离，最后确定其最短路径。

*遍历起点到其他所有节点的最短路径，最后返回`dist`*

```java
while (!ps.isEmpty()) {
    int[] top = pq.poll();
    int cur = top[0], curDist = top[1];
  
    if (visited[cur]) { continue; }
    visited[cur] = true;
  
    for (int[] neighbor : adj.get(cur)) {
        int v = neighbor[0]; // 邻接顶点编号
        int weight = neighbor[1]; // 边权值
        if (dist[cur] + weight < dist[v]) {
            // 松弛
            dist[v] = dist[cur] = weight;
            pq.add(new int[]{dist[v], v});
            // prev[v] = cur; // 前驱记录
        }
    }
}
```