# 4.希尔排序

## 4.1 算法原理

希儿排序（Shell Sort）是插入排序的优化版：

**优化目的**

在插入排序中，第`i`次遍历查找待插入元素的合适位置的时候，有序区查找指针`j`是逐个元素遍历的，即步长为1。

但是，有序区的元素顺序本身是有序的，假设有序区现在的范围是$[0,100]$，`j`遍历发现99位元素不是合理的插入位置，那么待插入元素的最终位置相较于98位，更可能出现在$[0,97]$中，而且可以进一步认为是$[0,96]$...$[0,45]$。

我们可以先让步长为一个更大的值，比如8，这样经过8步长的插入排序后，待插入元素将位于以最终位置为中心的一个模糊范围内，而8步长的向前遍历次数显著低于1步长。

此时，我们再对数组步长为1的插入排序，每次`j`遍历都只需要在模糊范围内遍历寻找，遍历次数远低于原先的全数组遍历。

*因此，使用更长的步长可以让元素更快地靠近最终位置。*

**优化方法**

对于大量的数据，可以在优化的基础上优化：

我们使用一个步长序列$\{1,a,b,...,m\}$，其中1<a<b<...<m，按步长m插入排序后逐步减少步长，直到步长为1的插入排序。

*因此，希儿排序的优化核心是优化步长序列/步长函数*：

- 最终步长必须为1，保证数组有序；
- 步长尽可能互质，减少重复排序；
- 步长降速适中，过慢增加轮次，过快降低分组排序效果。

一般使用基于数组长度的函数来定义步长序列：

- Shell原始步长：`gap = n/2, n/4, ..., 1`；
- Hibbard步长：`gap = 2^k-1, ..., 7, 3, 1`；
- Knuth步长：`gap = (3^k-1)/2, ..., 13, 4, 1`

## 4.2 代码实现

### 4.2.1 Shell原始步长

以Shell原始步长`gap`分组数组为若干区间，每次遍历要求元素落入区间中为止：

- 第一个gap区间$[0,gap-1]$为初始有序区

用`i`指向无序区的第一个元素（即待排元素），每次遍历使一个元素有序，无序区-1，逐步向后遍历无序区元素；

用`j`指向待插入元素应当插入的位置（区间），以步长`gap`（1）向前探索。

**为什么循环条件之一是$j ≥ gap$?**

待插入元素插入的不再是特定位置而是区间，`j`每次指向的是*不同的以gap为长度隔开的区间*。`j >= gap; j -= gap`条件下循环的意义是 **待插入元素不落在第一个区间，探测区间前移**。

满足循环条件进入循环，如果因为不满足`j >= gap`退出循环，则满足`j < gap`，元素将插入第一个区间$[0,gap-1]$，符合预期：*待插入元素比除了第一个区间外所有元素都小，这个待插入元素应当落在最小区间（第一个区间）。*

此外，边界$gap=1$情况下，插入排序条件`j > 0`与代码实现`j >= 1`本质是一个条件。

```java
public static void shellOriginalSort(int[] arr) {
    int n = arr.length;
    for (int gap = n / 2; gap > 0; gap /= 2) {
        for (int i = gap;i < n; i++) {
            for (int j = i; j >= gap && arr[j] < arr[j - gap]; j -= gap) {
                swap(arr, j, j - gap);
            }
        }
    }
}
```

### 4.3.2 Hibbard步长

对于复杂步长列表（递减），需要逆推增长公式，让`gap`从1一直增长到目标值。该过程复杂度小于$O(n)$，对最终排序效率影响微乎其微。

Hibbard步长逆推公式：$gap[k+1] = gap[k]*2+1$，边界是$gap*2-1≤n/2$。

```java
public static shellHibbardSort(int[] arr) {
    int n = arr.length;
    int gap = 1;
    while (gap * 2 - 1 <= n / 2) {
        gap = gap * 2 + 1; // 步长列表反向递推
    }
    for (; gap > 0; gap /= 2) {
        for (int i = gap; i < n; i++) {
            for (int j = i; j >= gap && arr[j] < arr[j - gap]; j -= gap) {
                swap(arr, j, j - gap);
            }
        }
    }
}
```

### 4.2.3 Knuth步长

```java
public static void shellKnuthSort(int[] arr) {
    int n = arr.length;
    int gap = 1;
    while ((gap * 3 + 1) / 2 <= n) {
        gap = gap * 3 + 1;
    }
    for (; gap > 0; gap /= 3) {
        for (int i = gap; i < n; i++) {
            for (int j = i; j >= gap && arr[j] < arr[j - gap]; j -= gap) {
                swap(arr, j, j - gap);
            }
        }
    }
}
```

### 4.2.4 希尔排序模板

基于上述三个代码实现，可以将希尔排序抽象为：步长寻找、步长递减、按步插入排序，三个步骤。

其中步长寻找、按步长递减是各个步长函数特有的，但是按步插入可以抽离为一个方法`gapInsertion`：

```java
public static void shellSort(int arr) {
    // 1.寻找初始化增量
    int gap = 1;
    while (gap <arr.length / 3) {
        gap = 3 * gap + 1;
    }
    // 2.步长递减
    for (; gap > 0; gap /= 3) {
        // 3.按步插入排序
        gapInsertion(arr, gap);
    }
}

// 按步长插入排序
private static void gapInsertion(int[] arr, int gap) {
    for (int i = gap; i < arr.length; i++) {
        for (int j = i; j >= gap && arr[j] < arr[j - gap]; j -= gap) {
            swap(arr, j, j - gap);
        }
    }
}
```

## 4.3 复杂度分析

### 4.3.1 时间复杂度

希尔排序的时间复杂度依赖步长序列，无精确解析解：

- 最好情况：*O(n log n)*，对于高效步长序列（Hibbard, Knuth）如果数组有序；
- 平均情况：*O(n²)*，*O(n logn)*；
- 最坏情况：*O(n²)*（Shell原始步长）/*O(n^(3/2))*（Hibbard）/*O(n log²n)*（Knuth）

### 4.3.2 空间复杂度

原地排序，辅助变量常数级，空间复杂度*O(1)*。