# 1.线性表

*线性表* ：由n个相同类型的数据元素，依据线性有序关系组成的有限序列。

线性表的本质是*有序、可重复、支持随机访问*的线性数据结构。

## 1.1 线性表ADT

Java中一般使用接口定义ADT，线性表对应接口为 ***List*** 。


| List 操作方法                  | 描述             |
| ------------------------------ | ---------------- |
| `insert(e)` / `add(e)`       | 向线性表插入数据 |
| `remove()`                     | 在线性表移除数据 |
| `replace(i, e)` / `set(i, e)` | 修改线性表数据   |
| `find(e)` / `get(i)`          | 在线性表查找数据 |

## 1.2 线性表存储结构

### 1.2.1 顺序存储结构

将线性表元素按逻辑顺序，依次存储在内存中连续存储空间中。

Java中一般采用**数组**，特别是动态数组实现，通过索引访问元素。

jdk实现：`ArrayList` 动态数组。

### 1.2.2 链式存储结构

使用结点的指针维护线性关系。

Java中一般定义`Node`节点类实现，依据节点类的实现不同，还划分单向链表、双向链表、循环链表。


| Node     | 实现                                           |
| -------- | ---------------------------------------------- |
| 单向链表 | 每个结点只有一个指向下一个结点的指针           |
| 双向链表 | 每个结点有两个指针，分别指向前驱结点和后继结点 |
| 循环链表 | 链表最后一个结点后继指针指向链表的头节点       |

jdk实现：`LinkedList` 双向链表

## 1.3 基本代码实现

### 1.3.1 ArrayList 动态数组实现

```java
public class MyArrayList<T> implements MyList<T> {
    private T[] list;
    private int size;
    private static final int DEFAULT_CAPACITY = 10;

    public MyArrayList() {
        list = new Object[DEFAULT_CAPACITY];
    }

    public void add(int index, T element) {
        rangeCheckForAdd(index);
        if (size == list.length) { resize(list.length * 2); }
        for (int i = size; i > index; i++) {
            list[i] = list[i - 1];
        }
        list[index] = element;
        size++;
    }

    public void add(T element) {
        add(size, element);
    }

    public T remove(int index) {
        rangeCheck();
        T element = list[index];
        for (int i = index; i < size; i++) {
            list[i] = list[i + 1];
        }
        list[size] = null;    // 帮助垃圾回收
        size--;
        return element;
    }

    public T set(int index, T element) {
        rangeCheck(index);
        T oldElement = list[index];
        list[index] = element;
        return oldElement;
    }

    public T get(int index) {
        rangeCheck(index);
        return list[index];
    }
}
```

### 1.3.2 LinkedList 单向链表实现

**实现类定义**

```java
public class MyLinkedList<T> implements MyList<T> {
    private static class Node<T> {
        T data;
        Node<T> next;
  
        Node(T _data) {
            data = _data;
            next = null;
        }
    }
    private Node<T> head;
    private int size;

    public MyLinkedList() {
        head = null;
        size = 0;
    }
}
```

**添加元素**

单向链表通过遍历链表找到对应节点进行元素添加，若无指定位置则遍历到最后进行添加。

```java
public void add(int index, T element) {
    rangeCheckForAdd(index);
    Node<T> newNode = new Node<>(element);
    if (index == 0) {
        newNode.next = head;
        head = newNode;
    } else {
        Node<T> prevNode = getNode(index - 1);
        newNode.next = prevNode.next;
        prevNode.next = newNode;
    }
    size++;
}

public void add(T element) {
    Node<T> node = new Node<>(element);
    if (head == null) {
        head = node;
    } else {
        Node<T> cur = head;
        while(cur.next != null) {
            cur = cur.next;
        }
        cur.next = node;
    }
    size++;
}
```

**删除元素**

获取到删除位置的前一个节点，将prev节点的next指针指向被删除节点的next指针，以在链表中跳过这个被删除的节点。

```java
public T remove(int index) {
    rangeCheck(index);
    T oldElement();
    if (index == 0) {
        oldElement = head.data;
        head = head.next;
    } else {
        Node<T> prevNode = getNode(index - 1);
        Node<T> oldNode = prevNode.next;
        oldElement = oldNode.data;
        prevNode.next = oldNode.next;
        oldNode = null;    // 帮助垃圾回收
    }
    size--;
    return oldElemenet;
}
```

**修改元素**

获取对应位置的节点后直接修改节点内部属性`data`即可。

```java
public T set(int index, T element) {
    rangeCheck();
    Node<T> node = getNode(index);
    T oldElement = node.data;
    node.data = element;
    return oldElement;
}
```

**查找元素**

元素查找主要基于链表的顺序结构，通过指定移动次数找到对应位置的节点。

```java
public T get(int index) {
    rangeCheck();
    return getNode(index).data;
}

public Node<T> getNode(int index) {
    rangeCheck();
    Node<T> cur = head;
    for (int i = 0; i < index; i++) {
        cur = cur.next;
    }
    return cur;
}
```

### 1.3.3 DoubleLinkedList 双向链表实现

**实现类定义**

定义一个内部节点类，包括存储数据与前后指针。

当链表为空时，`head`与`tail`均为空。

当链表只有一个元素时，`head`与`tail`指向同一个节点。

```java
public class MyDoubleLinkedList<T> implements MyList<T> {
    private static class Node<T> {
        T data;
        Node prev;
        Node next;
  
        Node(T _data) {
            data = _data;
            prev = null;
            next = null;
        }
    }
    private Node<T> head;    // 头节点
    private Node<T> tail;    // 尾节点
    private int size;    // 列表元素数量

    public MyDoubleLinkedList() {
        head = null;
        tail = null;
        size = 0;
    }
}
```

**添加元素**

不指定位置的元素添加直接添加在链表的末尾，更新新节点与尾节点即可。

如果是空链表，`head`指向null，需要特别更新。

```java
public void add(T element) {
    Node<T> node = new Node(element);
    if (tail == null) {
        head = newNode;
    } else {
        tail.next = newNode;
    }
    tail = newNode;
    size++;
}
```

当执行指定位置的元素添加操作时，更新发生在新节点、索引原指向节点、前驱节点。

如果是在头部插入，需要特别更新头节点。

```java
public void add(int index, T element) {
    rangeCheckForAdd(index);
    if (index == size) {
        add(element);
        return;
    }

    Node<T> nodeAtIndex = getNode(index);    // 原指节点 -> 后继节点
    Node<T> prevNode = nodeAtIndex.prev;    // 前驱节点
    Node<T> newNode = Node(element);
    newNode.prev = prevNode;
    newNode.next = nodeAtIndex;
    nodeAtIndex.prev = newNode;    // 更新nodeAtIndex前驱指针

    if (prevNode != null) {    // 不是在头部插入
        prevNode.next = newNode;
    } else {    // 在头部插入，更新头节点
        head = newNode;
    }
    size++;
}
```

**删除元素**

删除双向链表的节点，需要更新前驱节点的后继和后继节点的前驱。

```java
public T remove(int index) {
    rangeCheck(index);
    Node<T> oldNode = getNode(index);
    T oldElement = oldNode.data;
    Node<T> prevNode = oldNode.prev;
    Node<T> nextNode = oldNode.next;
  
    if (prevNode != null) {    // 处理位置不是头节点
        prevNode.next = nextNode;
    } else {    // 处理的位置为头节点
        head = nextNode;
    }

    if (nextNode != null) {    // 处理位置不是尾节点
        nextNode.prev = prevNode;
    } else {
        tail = nextNode;
    }

    oldNode = null;    // 帮助垃圾回收
    size--;
    return oldElement;
}
```

**修改元素**

获取对应位置节点直接修改其`data`属性即可。

```java
public T set(int index, T element) {
    rangeCheck(index);
    Node<T> node = getNode(index);
    T oldElement = node.data;
    node.data = element;
    return oldElement;
}
```

**查找元素**

基于双向链表的双向性，显然在查找部分可以根据索引与头、尾的远近来优化查找方向。

当查找位置靠近头节点（index < size / 2）时，从头节点开始遍历，否则从尾节点向前遍历。

```java
public T get(int index) {
    rangeCheck(index);
    return getNode(index).data;
}

public T getNode(int index) {
    if (index < size >> 1) {
        Node<T> cur = head;
        for (int i = 0; i < index; i++) {
            cur = cur.next;
        }
        return cur;
    } else {
        Node<T> cur = tail;
        for (int i = size - 1; i > index; i--) {
            cur = cur.prev;
        }
        return cur;
    }
}
```

## 1.4 复杂度分析

### 1.4.1 ArrayList时间复杂度

`ArrayList`使用连续内存空间存储元素，支持随机访问。但在插入、删除元素时需要更新后序所有元素。


| 操作        | 时间复杂度 | 说明                         |
| ----------- | ---------- | ---------------------------- |
| `add(e)`    | $O(1)$     | 数组扩容复杂度$O(1)$但频率低 |
| `add(i, e)` | $O(n)$     | 需要更新后续所有元素         |
| `remove(i)` | $O(n)$     | 需要更新后续所有元素         |
| `set(i, e)` | $O(1)$     | 直接定位索引修改元素         |
| `get(i)`    | $O(1)$     | 直接定位索引位置的元素       |

### 1.4.2 LinkedList和DoubldLinkedList时间复杂度分析

单向链表通过节点的`next`引用串联元素，不支持随机访问，只能从头遍历。

双向链表通过节点的`next`或者`prev`引用串联元素，同样不支持随机访问。可以根据索引位置优化，从头或者从尾就近遍历链表。

**在进行有节点维护的头、尾节点的操作时，时间复杂度为$O(1)$。**


| 操作         | 时间复杂度 | 说明                               |
| ------------ | ---------- | ---------------------------------- |
| `add(e)`     | $O(n)$     | 如果不维护尾元素，需要遍历整个链表 |
| `add(i, et)` | $O(n)$     | 最坏情况下同上                     |
| `remove(i)`  | $O(n)$     | 最坏情况下同上                     |
| `set(i, e)`  | $O(n)$     | 最坏情况下同上                     |
| `get(i)`     | $O(n)$     | 核心问题，只能遍历搜索整个链表     |

### 1.4.3 空间复杂度分析

三种数据结构的空间复杂度均为$O(n)$，所需存储空间随元素$n$线性增长。