# 1.冒泡排序

## 1.1 算法原理

冒泡排序（Bubble Sort）的核心思想是：

相邻元素两两比较，大元素后移（冒泡位元素越来越大，类似气泡上浮)，每轮遍历确定一个最大元素的最终位置；每次排序，确定两组有序大小顺序，即冒泡位的元素＞前面所有元素。

**能否优化？**

在一次冒泡中，如果两个相邻元素{a, b}没有发生交换，即$a＜b$，a与b、后缀已冒泡位的顺序已经满足有序，即一定有$a＜b＜...＜冒泡$，如果本次冒泡就此停下，后续如果有大于a、b的元素，自然能够继而冒泡过b。可以就此优化运行比较时间。

优化的核心是**强化继续冒泡条件是冒泡位＞前面元素**，如果不大于冒泡结束。

## 1.2 代码实现

用`i`控制n-1次遍历，指针`j`指定每次冒泡位，每次冒泡一个元素到最终位置，冒泡位与前面所有元素的整体大小有序；冒泡n-1次后，数组有序，i取值范围$[0,n-1]$。

交换使用`swap`方法，交换`j`与`j+1`位；第`i`次有i个冒泡位被确定，故`j`的最大遍历范围为$[0,n-i-1]$。

```java
public static void bubbleSort(int[] arr) {
    int n = arr.length;
    for(int i = 0; i < n - 1; i++) {
        boolean swapper = false;;
        for (int j = 0; j < n - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr, i, j);
            }
        }
    }
}
```

## 1.3 复杂度分析

### 1.3.1 时间复杂度

- 最好情况：*O(n)*，优化版数组有序情况下只需要1轮遍历；
- 平均情况：*O(n²)*；
- 最坏情况：*O(n²)*，数组逆序情况下需要n-1轮遍历，每轮n-i次比较。

### 1.3.2 空间复杂度

原地排序，空间复杂度O(1)。