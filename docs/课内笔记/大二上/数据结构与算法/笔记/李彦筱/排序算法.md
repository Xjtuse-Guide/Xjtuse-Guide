# 排序算法

> 作者：李彦筱
>
> 感谢学长 [yijunquan](https://github.com/yijunquan-afk) 的[软件工程笔记](https://github.com/yijunquan-afk/XJTUSE-NOTES)给我的启发。此笔记从二叉树开始的部分中使用了学长笔记中的部分图片以及文字。
>

## 本章节的目标

- 熟悉多种实用的内排序算法
- 对各种内排序算法进行比较
- 理解排序问题时间存在下限

## 排序的一般性定义

### 关键码

排序的依据。对于复杂的数据类型，其中可能包含多个可以被排序的基本数据类型属性；关键码就是实际进行排序的依据。

### 排序的定义

排序就是重排一组内容，使得**所有关键码保持不减的顺序**

> 除非特别说明，否则一般排序指的是**正向排序**

当关键码可以重复的时候：

例如，序列[1,2,3]的关键码序列为[2,2,1]。那么，以下两种排序过的序列都可以使得关键码顺序正确：

1. [3, 1, 2]
2. [3, 2, 1]

那我们怎么从这两个结果里选择呢？我们定义*对于具有相同关键码的记录的原始顺序不被改变的记录*叫**稳定排序**

按照这个定义，[3,1,2] 属于稳定排序，因为关键码同为2的1与2在结果中的顺序仍然保持一致；[3,2,1]不是稳定排序。

如果想要对关键码相同的元素按照其他关键码进行进一步排序，为了排序结果的正确，**必须在第一步使用稳定排序**的结果。

### 内排序与外排序

内排序：整个排序过程**不需要访问外存**即可完成

外排序：待排序的记录数量极大，以至于**无法在不访问外存的情况下完成**

本章仅包含内排序的内容。

### 排序算法效率的额外标准

由于很多排序算法的时间复杂度完全一样，因此，有必要加入一些其他的指标，来寻找它们之间的差别

一些指标包括：

- 关键码的比较次数

- 记录交换的次数

- 最坏时间分析与平均时间分析

  > 排序算法因为都比较简单，因此可以进行平均时间分析

- 空间分析

## 排序的分类

- 插入排序

  直接插入排序，希尔排序

- 交换排序

  冒泡排序，快速排序

- 选择排序

  简单选择排序

- 归并排序

- 基数排序



## 直接插入排序

假设有n个数据，第一个数据是有序的，第2个数据是需要检查的，后n-2个数据是无序的。直接插入排序一个个的从后侧的无序序列取元素，将取得的元素与有序序列的每一个元素比较关键码大小，找到应当插入的位置；随后，把这个位置及以后的元素全部后移一位，将取得的元素插入这个空位。

比如：42 15 34 | 16 | 20 93，假设16 是正接受检查的元素。

比较：34 < 16? false; 15 < 16 ? true，找到插入位置

交换：42 15 34（空） | 34 | 20 93 -> 42 15 16 | 34 | 20 93 

进行下一步：42 15 16 34 |20| 93 （改变正接受检查的元素）

### 直接插入排序的分析

最好情形：输入了一个递增的有序序列

比较次数：n-1

> 这是因为，每一个未排序序列的最靠前的元素在和有序序列的最后一个比较之后，立刻发现其已经有序，不再向前比较。
>
> 直接插入排序默认有n-1个无序元素和1个有序元素；因此只需要比较n-1次

交换次数：0

> 这是因为直接插入排序一旦发现每一个未排序序列最靠前的元素在和有序序列的最后一个比较之后，如果发现其已经有序（这个元素大于有序序列的最后一个元素），就不再比较也不进行交换。

最差情形：输入了一个递减的有序序列

比较次数：O(n<sup>2</sup>)

> n + (n-1) + (n-2) + ... + 1 = ((n+1) * n) / 2，大约为n<sup>2</sup> 级别。

交换次数：O(n<sup>2</sup>)

平均情形：**假设数据的大小排列每种出现概率相同**，取平均值作为平均情况：

比较次数：O(n<sup>2</sup>)

（因为 (O(n<sup>2</sup>) + (n - 1)) / 2 仍然在 O(n<sup>2</sup>) 级别）

交换次数：O(n<sup>2</sup>)

### 直接插入排序的近似最好情形

直接插入排序对于有序序列**只需要 n-1 的比较次数和 0 次的交换次数**。因此，它**对于近似有序序列的排序速度是所有算法（不止O(n<sup>2</sup>)这几个）里最快的**；

越小的序列越有可能出现近似有序情况，因此，**直接插入排序对小序列表现较好**

在后面可以看到，直接插入排序可以对递归的排序算法在小数据量时进行性能优化。

### 代码实现

```java
public void sort(Comparable[] comparables){
    // 直接插入排序默认第一个数据是有序的，其他 n-1 个数据是无序的。
    for (int i=1;i<comparables.length;i++){
        // 重复的比较当前数字和前一个数字；如果当前内容比前一个要小，说明当前内容应当排在前一个的前面，因此进行交换。
        for (int j=i; j > 0 && comparables[j].compareTo(comparables[j-1]) < 0;j--){
            comparables[j] = comparables[j-1];
        }
    }
}
```



## 冒泡排序

冒泡排序每次都从后向前的扫描一个序列。如果序列当中有两个元素的关键码是反序的，那么就交换这两个元素；否则就直接继续扫描。

每一次冒泡排序都会使得**当前序列中的最小值被排序到最前方**

6 4 3 12 | -> 6 4 3 | 12 -> 6 4 | 3 12 -> 6 | 3 4 12 -> | 3 6 4 12

一次排序完成后，无序序列中最小的值3被交换到最前方。

n 次排序之后，前方就会产生长度为 n 的有序序列。不过，冒泡排序其实只需要 n-1 次排序，因为排序了 n-1 个元素之后，最后一个元素一定是有序的。

### 冒泡排序的分析

严谨地说，冒泡排序分为两种：普通的冒泡排序和优化之后的冒泡排序。

优化之后的冒泡排序在**一趟完成后没有交换**时会直接结束。这是因为，交换发生在逆序元素存在期间；如果没有交换，说明已经不存在逆序元素了，即已经完成排序。

**最好情况：输入一个完全有序的序列**

未优化的冒泡排序：

比较次数：(n-1) * (n-1) （因为它不会在一次比较后自行停止）

交换次数：0

优化过的：

比较次数：n - 1（因为比较完一轮就知道有序了，停止了）

交换次数：0

**最差情况：一个逆序序列**

不管是哪种冒泡排序：

比较次数：O(N<sup>2</sup>)

交换次数：O(N<sup>2</sup>)

**平均情况**

比较次数：O(N<sup>2</sup>)

交换次数：O(N<sup>2</sup>)

这是因为最好和最差加起来除2仍然在 N<sup>2</sup> 内。

### 实现

```java
public void sort(Comparable[] comparables){
    for (int i=0;i<comparables.length-1;i++){
        boolean exchanged = false;
        for (int j=0;j<comparables.length - i - 1;j++){
            if (comparables[j].compareTo(comparables[j+1]) > 0) {
                exchanged = true;
                Comparable temp = comparables[j];
                comparables[j] = comparables[j + 1];
                comparables[j + 1] = temp;
            }
        }
        if (!exchanged){
            return;
        }
    }
}
```

此实现是一个优化过的冒泡排序：在一轮中没有交换时，排序会直接结束。

这个冒泡排序在每次扫描数据序列之后，会把最大的值放到数据序列的末尾。（更改第四行的for循环就可以做到把最小值放到数据序列的最前方）



## 直接选择排序

直接选择排序每一轮次从无序序列中选择当前的最小值，放在有序序列的最前。

对于一个长度为n的序列，直接选择排序需要进行n - 1次。（最后剩下的那个元素不需要排序）

举个例子：

5 3 4 12 -> 3 5 4 12 -> 3 4 5 12 -> 3 4 5 12 -> 3 4 5 12

由于它每次都选择无序序列的最小值，因此它需要**无序序列完整**才能开始，因此不具有在线性。不过，由于每次排序的结果都是最终顺序，因此它具有**部分性**。

### 直接选择排序的分析

**最好情况：输入一个完全有序的序列**

比较次数：O(N<sup>2</sup>)(n+(n-1)+(n-2)+...+1=n<sup>2</sup>级别）

因为每次排序完成后都会有一个元素跑到前面变成有序的，就不需要再扫描它了。

交换次数：0次

**最坏情况：**

比较次数：O(N<sup>2</sup>) (n * (n-1))

交换次数：O(N) (n - 1)

**平均情况：**

比较次数：O(N<sup>2</sup>)

交换次数：O(N)

选择排序的独特之处在于**其很少的交换次数**。但是，对应的代价是，在最好情况下选择排序**比较次数仍然在 O(N<sup>2</sup>) 中**。因此，它适用于**交换记录耗时很长**的场景。

### 实现

```java
public void sort(Comparable[] objs){
    for (int i=0;i<objs.length - 1;i++){
        int min_place = i;
        for (int j=i;j < objs.length;j++){
            if (objs[min_place].compareTo(objs[j]) > 0){
                min_place = j;
            }
        }
        Comparable temp = objs[i];
        objs[i] = objs[min_place];
        objs[min_place] = temp;
    }
}
```

## 三种 O(n<sup>2</sup>) 级别排序的比较

### 在线性

直接插入排序具有**在线性**：不需要得到所有的排序元素，就可以开始排序。

> 其他两种排序算法都不具有此特征

这是因为直接插入排序只关注目前被排序元素和已排好序的序列，对于等待排序的序列并不关心。因此，**直接插入排序**可以在仅仅已知部分元素的情况下进行排序。

但是，直接插入排序也有缺点：除非完成所有排序，否则**无法确定目前排序的结果是否正确**。举个例子，假如待排序序列的最后一个位置是最小的；这会导致只有排序到最后一个元素之后，排序序列才正确，在此之前，有序序列中的元素都过于靠前了一位。

### 部分性

直接选择和冒泡排序两种排序算法具有**部分性**：**即使只执行部分排序，排序结果也是对的**

直接选择排序的内循环每次执行时都会将未排序序列中的最小元素移动到最前方；因此，它在未完成执行时，前方的已排序序列已经是正确的。

冒泡排序的内循环每次执行时也会把未排序序列中的最小元素移动到最前方。因此，它在未完成执行时，前方的已排序序列已经是正确的。

直接插入排序只有在完成所有排序之后，结果才是正确的。因为它在每次排序时不检查整个序列，所以在完成排序之前，它的已排序序列是不稳定的。

### 稳定性

判断排序稳定性的特征：**是否出现了不相邻的元素之间的交换**

按照此特征，直接插入和冒泡排序是稳定的；简单选择排序是不稳定的。

这是因为：直接插入排序在移动元素时，**是一个一个相邻移动的**。

冒泡排序在交换元素时，也只**对相邻的元素做交换**。

简单选择排序**直接把无序序列的最小元素与有序序列的最后元素交换**。因此，它**跨过了多个元素交换**，因而是不稳定的。

### 原地性

原地性是指排序算法**是不是需要额外的空间辅助才能完成排序**

三种算法都在原来的数组中完成了数据的排序与交换；它们都不需要额外的空间。因此，它们全都具有**原地性**

（下面会说到的归并排序不具有原地性）



## Shell 排序（希尔排序）

希尔排序是一种**利用直接插入排序的最佳时间特性**的排序。它先把元素排序成**近似有序**的状态，并且在最后使用插入排序进行最后的整理，利用直接插入排序对近似有序序列的较好时间特性，加快排序速度。

由于希尔排序在不相邻的记录之间进行比较和交换，因此**它不具有稳定性**。它跨过多个元素进行记录的交换，是为了**让无序的元素尽快达到其正确的目的地**。

希尔排序**在正确的实现下**的最差时间花费在 O(nlogn) 内。也就是说，它的最差情形比上方的三种排序算法都好。

### 算法步骤

1. 把待排序的序列按照间隔 a 划分为 a 个子序列
2. 对每个子序列进行排序
3. 减小间隔 a ，然后再次进行1、2两步
4. 间隔为 1 的那次排序完成之后，排序过程结束

### 为什么希尔排序比直接插入排序要快？

直接插入排序在移动某个元素到指定位置的时候，需要一格一格的移动。比如，在序列： 5 | 2 | 3 | 1 当中，如果我们要把1移动到它正确的位置，需要把它和3，2，5依次交换，即需要三次交换；

希尔排序在移动某个元素到指定位置的时候，可以跨过一个元素移动。比如，在上面那个序列中，如果增量选择2，那么希尔排序实际上在对两个序列排序：5 | 3 和 2 | 1 ，1和2交换，5和3交换，得到了 3 | 1 | 5 | 2。在下一轮增量为1的排序当中，1和3交换，完成了排序。

可以看出，希尔排序时对元素的交换次数明显少于直接插入排序。这就是它快于直接插入排序的原因。

### 增量序列

增量序列是用来决定希尔排序应当间隔几个元素进行插入排序。虽然说序列是“增量”的，但实际上在使用中，我们是从大到小使用这个序列的。也就是说，插入排序的间隔先最大，再慢慢减小；当插入排序的间隔减小为1的时候，排序结束。

希尔排序在正确的间隔下的时间复杂度可以达到 O(N<sup>1.5</sup>)（如果使用了下面所说的高德纳序列）。

### 增量序列如何选择？

一般来说，选择如下增量序列是比较好的。这个序列叫做高德纳增量序列：

h<sub>1</sub> = 1, h<sub>i</sub> = 3h<sub>i-1</sub> + 1

即序列1，4，13，40，……

选择高德纳的增量序列时的 shell 排序称为**优化后的 shell 排序**

### 希尔排序的实现

这个希尔排序选择了1，3，9，27，81…这样的增量序列。

```java
public void sort(Comparable[] objs){
    int N = objs.length;
    int step = 1;
    // 得到增量序列的最大值
    while (step < objs.length){
        step *= 3;
    }
    // 进行增量大小不同的排序
    while (step >= 1){
        // 对当前增量下，每一组数据进行直接插入排序
        for (int start=0;start < step;start++){
            for (int i=start;i<N;i+=step){
                for (int j=i;j>start && objs[j].compareTo(objs[j-step]) < 0;j-=step){
                    Comparable temp = objs[j];
                    objs[j] = objs[j-step];
                    objs[j-step] = temp;
                }
            }
        }
        step /= 3;
    }
}
```



希尔排序证明了虽然有些排序算法是慢的难以让人接受的，但是我们可以利用这些算法的最好情形，创造一种速度更快的排序算法。



## 快速排序

快速排序字如其名，是在实践中一般最快的已知排序算法。该排序的平均运行时间为 O(nlogn)，而最差的运行时间为 O(n<sup>2</sup>)；它使用了**分治策略+递归**的优化策略。

注：一般把算法复杂度从 O(n<sup>2</sup>) 降低到 O(nlogn) 时，可以尝试使用分治+递归的方法进行优化。

### 算法的步骤

1. 如果当前记录序列的元素个数为0或者1，则返回

   > 这是递归的基准情形

2. 取 S 当中的任何一个元素 v，叫做**轴值**（pivot）

3. 把 S 中除了v的其他元素划分成两部分：元素大小上小于轴值的序列 L 和元素大小上大于等于轴值的序列 G

4. 递归的对 L 和 G 两个序列进行快速排序

5. 把 {L, v, G} 三部分拼接起来即得到排序结果。

### 轴值的重要性

轴值的大小是影响快速排序算法性能的重要因素：如果轴值过小或过大，那么为完成排序，递归次数会大大增加。

理想的轴值应当将记录序列 S 近似的分割成大小相等的两个部分；最不好的轴值会把记录 S 分解为一个空集和一个包含所有剩余元素的集合。

如果每次轴值选择都是最坏的情况（即每次都选择剩余数据中最小或最大的），那么快速排序的时间复杂度会来到最差的 O(n<sup>2</sup>)。

### 正确的选择轴值

- 使用序列固定位置的值作为轴值

  这种情况下，对于特定的序列，这种轴值选择非常糟糕；比如，如果你固定选择最开头的位置的值作为轴值，那么碰到逆序序列的时候会简直生不如死

- 使用随机数作为轴值

  随机数生成的时间代价太过于高昂，因此不宜使用

- 三值选中(zhōng)法

  取序列开头，中间，最后的三个位置的元素中，**大小在中间的那个值**作为轴值

  这种选择策略是比较恰当的，可以让排序在 O(nlogn) 的时间复杂度中

### 快速的序列分割方法

具体来说，如何把比轴值小的元素放到一个子序列，而比轴值大的放到另一个子序列呢？这一部分最小的时间复杂度有多少呢？

在快速排序的实现中，我们使用**双游标法**来进行序列的分割：

1. 在待分割序列的左侧和右侧分别设置两个游标 low 和 high。
2. 持续把 low 向右移动，直到其指向一个比轴值大的元素后停止
3. 持续把 high 向左移动，直到其指向一个比轴值小的元素后停止
4. 交换 low 和 high 指向的元素
5. 重复2～4的操作，直到 low 和 high 游标相遇时结束

可以看出，由于 low 和 high 走过的路程加起来是整个序列的长度，因此这个过程的时间复杂度在 O(n) 内。

### 快速排序的性能分析

假设快速排序n个数字需要 T(n) 的时间：

快速排序耗时包括：分割记录时间+递归调用子序列时间：

`T(n) = T(i) + T(n-i-1) + c*n`

T(i), T(n-i-1)：两个子序列排序所花的时间

c*n：分割记录所需的线性时间

#### 最坏情形

此时快速排序的轴值**总是选择最小值或者最大值**。因此，每次排序的耗时为：

- T(n) = T(1) + T(n-1) + cn 其中 T(1) = 0

累加得到：

`T(n) = T(0) + (n + n-1 + n-2 +... + 1) = T(n<sup>2</sup>)`

也就是说，快速排序在轴值选择完全不好时，需要 O(n<sup>2</sup>) 的时间来完成。

#### 最好情形

此时快速排序的轴值选择可以让两个子序列的长度相等（或者只差1）。因此，每次排序的耗时为：

- T(n) = 2 * T(n/2) + cn

累加得到：

`T(n) = T(0) +  (n + n/2 + n/4 + …… + 2 + 1)`

这说明快速排序在轴值选择较好的时候，需要 O(nlogn) 来完成。

### 快速排序的实现

```java
public void sort(Comparable[] objs){
    sort(objs, 0, objs.length - 1);
}

// 这一个函数用于寻找轴值
// 函数采用三值选中法寻找轴值，并且直接把这三个位置的元素按照大小排好序。
private int findPivot(Comparable[] objs, int start, int end){
    int middle = start + (end - start) / 2;
    if (less(objs[end], objs[middle])) {
        exchange(objs, end, middle);
    }
    if (less(objs[middle], objs[start])) {
        exchange(objs, middle, start);
    }
    if (less(objs[end], objs[middle])) {
        exchange(objs, end, middle);
    }
    return middle;
}

// 快速排序的递归函数
private void sort(Comparable[] objs, int start, int end){
    // 基准情形
    if (start >= end){
        return;
    }
    // 寻找轴值
    int pivot_index = findPivot(objs, start, end);
    // 划分数据序列为了两部分
    int pivotIndex = partition(objs, start, end, pivot_index);
    // 递归的对两部分进行快速排序
    sort(objs, start, pivotIndex - 1);
    sort(objs, pivotIndex + 1, end);
}

// 划分：把数据根据大于还是小于轴值划分到两侧。等于轴值的数据不需要移动。
private int partition(Comparable[] objs, int start, int end, int pivot) {
    int low = start;
    int high = end;
    // 把轴值放到开头去，在划分过程中不再动它
    exchange(objs, pivot, low);
    Comparable pivotValue = objs[low];
    while (low < high){
        while (low < high && objs[high].compareTo(pivotValue) >= 0){
            high--;
        }
        // 第一次执行到这里的时候，轴值会被覆盖。不过没有关系，我们保存了轴值的内容
        objs[low] = objs[high];
        while (low < high && objs[low].compareTo(pivotValue) <= 0){
            low++;
        }
        objs[high] = objs[low];
    }
    // 恢复被覆盖的轴值到两半数据序列的中间
    objs[low] = pivotValue;
    return low;
}

// 快捷操作函数，用来交换数组中两个元素的位置
private void exchange(Comparable[] objs, int i, int j){
    Comparable temp = objs[i];
    objs[i] = objs[j];
    objs[j] = temp;
}

// 快捷操作函数，用来判断两个Comparable对象的大小关系。
private boolean less(Comparable i, Comparable j){
    return i.compareTo(j) < 0;
}
```

### 提高性能的措施

1. 小心的选择轴值

2. 由于规模较小的时候，O(n<sup>2</sup>) 甚至小于 O(nlogn)，因此在数组大小较小（n < 10）的时候不再使用递归，改为使用 O(n<sup>2</sup>) 的排序算法，比如插入排序，进行小数组的排序。

   这么做除了时间复杂度之外还有一个原因：递归调用是比较昂贵的；而小数组占用了绝大多数的递归调用次数，因此，对于分割成的小数组使用 O(n<sup>2</sup>) 级别的其他排序算法是比较合适的。

   此外，这还带来了一个隐形的好处：避免了“三值取中”的选择轴值的方法在数据规模较小时出现的尴尬情况。

   如果你使用的O(n<sup>2</sup>)算法是插入排序的话，这种方法甚至还有一个好处：小数组比起大数组更有可能出现近似最好情形，也就是说排序快的概率更大

   进行这种优化了的快速排序称为**优化过的快速排序**

3. 将递归函数调用改为递推函数

   具体改写方法将在栈那部分提到。这种优化方式主要保证不会爆栈（



## 归并排序

- 分治的递归算法
- 适合用于链表形式存储的数据
- 速度较快的排序算法

### 算法步骤

1. 待排序线性表长度为 1 时，认为已经排序完成。（*基准情形*）

   否则，把线性表一分为二，分成两个长度相同的线性表。

   > 这个分割过程的时间复杂度在 O(n) 内

2. 对被分割成的线性子表分别进行归并排序（*递归调用*）

3. 将排完顺序的线性表合并为一个大的线性表

   合并过程：使用双游标法

   1. 在两个线性表的最左侧分别设置一个游标
   2. 如果左侧游标指向的元素小于右侧的，那么就把左侧的加入的合并线性表中，并将左侧游标增加；反之亦然
   3. 结束情况：当任何一个游标到达了自己线性表的最右侧；此时把另一个游标指向的以及其后的所有元素直接全部加入到合并线性表的最后

   由于两个游标没有回头路，走的总长度相当于新的线性表的长度，因此**合并过程的复杂度在 O(n) 内**

### 算法的代价分析

`T(n) = 2*T(n/2) + 2n`

**归并排序的时间复杂度在 O(nlogn) 内**

由于合并过程需要一个**和新的线性表长度大小一样的数组**，于是**归并排序有空间代价**：

使用数组时，**归并排序的空间代价在 O(n) 内**

使用链表时，**归并排序的空间代价在 O(1) 内**

由于归并排序以“完全不随机”的二分法分割线性表，因此，它并不存在所谓”最佳，最差，平均“情况；

**归并排序在任何情况下的时间复杂度都为 O(nlogn)**

### 归并排序的实现

```java
public void sort(Comparable objs[]){
    // 额外的，用来辅助归并排序的数组
    Comparable[] temp = new Comparable[objs.length];
    mergesort(objs, temp, 0, objs.length - 1);
}

private void mergesort(Comparable[] array, Comparable[] temp, int left, int right){
    if (left >= right) return;
    int middle = left + (right - left) / 2;
    // 递归的归并排序数据序列的两半
    mergesort(array, temp, left, middle);
    mergesort(array, temp, middle + 1, right);
	
    // 把数据序列的内容拷贝到临时数组里，用于复制
    for (int i = left;i <= right; i++){
        temp[i] = array[i];
    }
	
    // 双指针法合并两半数据序列
    int i1 = left, i2 = middle + 1;
    for (int curr = left; curr <= right; curr++){
        // 如果左侧线性表已经被添加完，就只添加右侧线性表的内容
        if (i1 == middle + 1) array[curr] = temp[i2++];
        // 如果右侧线性表已经被添加完，就只添加左侧线性表的内容
        else if (i2 > right) array[curr] = temp[i1++];
        // 如果左侧的元素小于右侧的，就添加左侧的
        else if (less(temp[i1], temp[i2])) array[curr] = temp[i1++];
        // 否则添加右侧的。
        else array[curr] = temp[i2++];
    }
}
```

### 提高性能的措施

- 修改递归函数为递推函数

  假设从一开始就拥有了 n 个长度为 1 的线性表（减少了划分所需的时间），然后只进行两两合并，两两合并，两两合并，……的过程，直到所有的线性表都被合成为了一个大线性表。

- 归并排序的思想引起的思考：*自然归并法*

  归并排序使用比较“稳妥”的方式确定有序性：任何一个长度为 1 的线性表一定是有序的。

  事实上，我们可以略微“过分”一点：在每次划分线性表时，改为从前向后扫描线性表序列，然后把每个已经有序的小片段划分为一个“有序“的线性表。比如，以下的数据序列可以被划分为三部分：

  12 13 4 5 7 15 11 16 -> 12 13 | 4 5 7 15 | 11 16

  这种划分方法称为自然归并法。

  自然归并法的难点在于**很难记住每段线性表的长度（左界和右界）**；可能需要额外的空间来存储这一信息。

- 对于短的线性表，使用直接插入排序替代递归过程

  这样优化过的归并排序称为**优化过的归并排序**（总感觉这句话很像废话）



## 三种使用分治策略的排序比较

### 时间比较

平均情况下，快速排序和归并排序快于 shell 排序：前者在 O(nlogn) 内，而 shell 排序在 O(n<sup>1.5</sup>) 内

（快速排序的最差情况不算在内：这玩意最差情况都到 O(n<sup>2</sup>) 内了）

### 空间比较

快速排序和 shell 排序适合于**使用数组存储的内存排序**

归并排序适合**外排序**和**使用链表存储的内存排序**

> 归并排序在对数组形式的内容排序时，需要额外的 O(n) 才能完成排序，因此内存占用会成倍的增长。归并排序对链表内容排序时，没有此问题。

### 稳定性

快速排序和 shell 排序不稳定；归并排序稳定

### 性能的波动性

快速排序和 shell 排序都存在最坏情况：

快速排序：轴值一直选择最小/最大值

shell 排序：增量序列选择非常差

归并排序不存在性能波动，因为它根本不包含任何随机因素。
