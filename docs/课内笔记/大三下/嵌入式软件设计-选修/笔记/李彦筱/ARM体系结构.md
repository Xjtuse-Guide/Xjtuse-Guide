# ARM 体系结构

ARM 的全称是 Acorn RISC Machine（也有说是 Advanced RISC Machine）。ARM 的基本结构就是 Acorn 公司设计的，不过公司主要盈利并不靠制造 CPU，而是靠售卖 ARM 结构的使用授权。由于授权较为便宜而且结构较好，ARM 架构目前已经成为嵌入式系统事实上的硬件体系结构标准。

本章节的主要内容包含：

- RISC 和 CISC 的区别（计组再现）
- ARM 体系结构的发展历史
- 典型的 ARM CPU 核的结构
- ARM 编程模型，主要包含寄存器和其他功能
- 内存和 I/O 方法

重要内容：

- ARM 流水线的设计
- 各个寄存器的结构与其操作

## 计算机体系结构

计算机体系结构的定义：从用户角度看到的计算机属性（也可以说是那些对程序员可见的系统属性），即计算机的逻辑设计，比如计算机有无某个指令、可见寄存器、存储器管理单元和异常处理模式。

> 下面的内容和计组 13 章《精简指令集计算机》差不多：包含 RISC 潮流的出现和 RISC 机的主要特性。

在 20 世纪 80 年代之前，计算机设计的主要趋势是增加复杂度，比如增加时钟频率、指令集指令的复杂程度，以便在单条指令中完成更多任务。

> ARM 处理器是 RISC 指令集处理器的典型代表，因此我们常常将 ARM 和 RISC 混用。

计算机体系结构不同，那么指令集不同，从而机器码不同。**体系结构、指令集和机器码之间存在较强的关联**。CISC 机的指令集长度是可变的；而 RISC 机通常采用固定长度的指令格式，例如标准的 ARM 指令为 32 位。

### CISC 体系结构

> Complex Instruction Set Computer，复杂指令集计算机

CISC 结构追求指令集的复杂化，让一条指令能完成更多工作，更加接近高级语言的指令。同时，CISC 结构的指令数量也很多。

CISC 系统存在的缺点：

- 由于指令数量太多，设计周期较长，资金消耗较多

- 20% 与 80% 的问题：80% 的功能（指令）使用率只有 20%，大部分功能都不常使用

- 指令复杂度太高，导致 VLSI（大规模集成电路）过于复杂，影响性能

- 软硬件的协同设计问题：硬件结构过于复杂，应用在嵌入式系统时性能过剩

### RISC 体系结构的特点

RISC 体系结构的特点如下：

1. 指令类型少：仅包含基本指令，很少有复合指令（一条指令做多件事）

2. 指令格式和长度固定：由于指令格式一定，流水线设计较为简单。

3. 优化编译效率高

4. 大多数指令单周期完成：指每条指令每段流水基本只要一个周期就能完成。

5. 分开的 Load/Store 结构的存取指令：计算时采用大量寄存器做缓存，完成后才将结果写回内存。在 ARM 架构指令集中，所有运算指令都只能选择寄存器地址作为操作数位置，需要添加 LOAD/STORE 指令才能从内存中读取/写入数据做运算。

   也就是说，不允许在运算指令的隐式的访问内存读取/写入数据，必须先写到寄存器中，再通过 LOAD/STORE 指令显式的读写内存。

6. 基于多个通用寄存器的堆操作：通过大寄存器组存储调用栈的局部变量，减少函数调用操作的时间。

优点：

- 芯片面积小（指令集简单，因此不需要复杂的控制电路）
- 开发周期短、成本低（指令集简单，因此设计相对简单）
- 容易实现高性能（流水线简单）

缺点：

- 代码密度低
- 不能执行已有的 x86 或者 x86-64 代码（那肯定的，体系结构都不一样了指令集肯定不同）
- 编译程序优化较为困难

> ARM 是第一个用于商业用途的 RISC 处理器，因此很多时候 ARM 和 RISC 的含义是等同的。

题目：

- RISC 架构提供给用户更多的指令集

  错误，RISC 架构的指令数量相对 CISC 更少。

## ARM 体系结构简介与发展

### ARM 简介

ARM 全名为 advanced RISC Machine。ARM 资金主要靠授权其他厂商使用 ARM 架构开发。

ARM 体系结构的特点：（和上面 RISC 机的特点类似）

- 具有大量寄存器，很多操作在寄存器中完成
- 存在专用的 LOAD/STORE 指令。
- 指令和寻址方式种类相比 CISC 更少，更加简单
- 统一和固定长度的指令格式可以简化译码
- 在同一体系结构中实现运算和数据处理

#### ARM 体系结构的特点

- **任一数据处理指令中都可以同时包含 ALU （算术逻辑单元）运算和移位操作**

  比如指令 ADD R0, R1, R2, LSL #2 表示计算 R0=R1+(R2 << 2)，即加法（ALU）和移位操作在同一指令中描述。

  左移两位其实就是在二进制数字右侧加两个 0，即把数字乘 4（在没有溢出的情况下）

  优点：节省一条指令的空间，加速执行，也可以减少访问寄存器的操作。

- 地址自动增加（减少）寻址模式优化程序循环

  比如：指令 `LDR R0, [R1], #4` 表示加载 R1 地址处的数据，然后让 R1+=4
  
  指令 `STR R2, [R3, #-4]!` 中，`!` 符号要求立刻计算 R3-4 数字指向的地址，然后将 R2 的内容放入新地址中
  
  这种语法也可以减少指令的数量，把“计算偏移位置+读写”两条指令合并为一条，可以加速读/写栈等操作的速度。
  
- 多寄存器装载和存储指令实现最大数据吞吐量

- 所有指令可以根据条件决定是否执行，提高指令的执行效率

  比如：

  ```
  CMP R0, #0
  ADDEQ R1, R1, #1
  ```

  指令的含义为：

  1. 比较 R0 寄存器的内容和立即数 0，即比较 R0 的内容是否为 0
  2. ADDEQ 是条件执行指令。仅仅当上方 R0=0 时，此指令才会执行。

### ARM 微处理器核

ARM 系列的最新版本为 armv9；目前手机常用的是 armv8 版本。

Cortex 系列：

- Cortex-A：适用于高端消费电子设备、网络设备等。它性能较好，实现了虚拟内存系统，在整数和浮点运算上表现较好
- Cortex-R：适用于高性能的实时控制系统
- Cortex-M：可以快速进行中断处理，适合具有高度确定行为和对成本比较敏感的设备。

## 典型的 ARM CPU 内核体系结构

ARM7TDMI 是一个比较常用的 ARM 内核。其框图如下：（了解即可）

![image-20250622113136518](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAIBC2ia9aNdGtCghJPCdb1qiawCE8fsAAIJHAACnTzZVEBI8-EkwNDjNgQ.png)

> 此内核采用冯诺依曼结构；更新的 ARM 内核大部分都采用哈佛架构了

- ALU：和常规的 ALU 逻辑基本相同
- 桶型移位寄存器；用于进行左移/右移等移位操作。通过交叉开关，可以在单周期内完成多位的移位，代价是电路很复杂。
- 高速乘法器：采用 32x8 的乘法结构，完成 32x32 的运算（通过对结果左移），因此速度很快

- 存储器访问：ARM7TDMI 的存储器采用了冯诺依曼结构（更新的 ARM 芯片采用哈佛结构了），因此其指令和数据共用一条总线。

- 寄存器：包含 37 个寄存器，其中存在 31 个通用寄存器和 6 个状态寄存器。
- 控制器：ARM的控制器采用硬接线的可编程逻辑阵列控制逻辑 PLA，其输入端有14根、输出端有40根，分散控制Load/Store多路、乘法器、协处理器以及地址、寄存器ALU和移位器。
- 浮点部件：可选的部件，加速浮点运算。

### 冯诺依曼架构和哈佛架构

冯诺依曼结构：

在存储和传输时不区分指令和数据，指令和数据传输采用相同总线，存储在相同的内存储器中。优点：结构简单。缺点：速度较慢，**且不能同时取指令和数据**（因为二者采用同一条总线，会相互冲突）。

哈佛结构：

在存储和传输时区分指令和数据，采用不同存储器存储、不同的总线传输指令/数据。结构较为复杂，但**不会出现指令-数据传输冲突**。

### 三级流水线：非常重要

ARM7TDMI 核采用流水线以加速指令的执行速度。流水线比较简单，只分为三级：**取指，译码和执行**。

取指：完成程序存储器中指令的读取，放入指令流水线

译码：指令被译码，为下一周期准备控制信号。此部分存在指令时，占用译码逻辑而不占用运算逻辑。

执行：实际运算/执行指令，需要占用运算逻辑。比如从操作数寄存器中读取内容，进行 ALU 运算，写回结果到寄存器中。

> 为什么一定是从寄存器中读取呢？因为前面 RISC 指令集的特点中提到，RISC 需要显式的 LOAD/STORE 指令才能访问内存，因此对内存数据运算时必须先通过 LOAD 指令读取内存内容到寄存器，再引用寄存器地址。

流水线阶段之间全部都是两两可重叠的。

ARM7TDMI 内核中的 R15 寄存器就是 PC 寄存器（程序计数器），PC 寄存器存放了即将被取指的指令的地址

> 注意每个指令的取指阶段完成后， PC 会立刻自增（这其实是计组的东西吧）
>
> 即在任意时刻，PC 指针对应指令在取指阶段，PC-4 的指令在译码阶段，PC-8 的指令在执行阶段，PC-12 的指令刚刚执行结束了。
>
> 注意 ARM7TDMI 是 32 位机，指令长度是 32 位，那么就是 4 字节，按字节寻址，因此每次 PC 自增是 4。
>
> Thumb 指令集是 16 位的，同样按字节寻址，因此每次 PC 自增是 2。所以，对于 Thumb 指令集来说，PC 指针对应指令在取指阶段，PC-2 指令在译码阶段，PC-4 指令在执行阶段。

LDR 指令与后续指令会产生控制冲突，因为 LDR 指令需要计算新地址的位置，导致其在执行阶段时，译码机构仍然无法释放，从而导致后续指令慢一周期。

![image-20250622114235717](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAIBDGia9aoHM6-NWjsyl21JEyeplZudAAIKHAACnTzZVPMl5plj9G3ONgQ.png)

同样，由于采用冯诺依曼结构，取数据和取指令会相互冲突。当 LDR 处于额外的访存周期时，其后面的指令无法进行取指操作，导致后续指令慢一周期。

> 可以看出，ARM 处理器流水线中，和计组讲解的流水线一样，也存在资源冲突和控制冲突。

预测跳转冲突问题：在预测跳转失败时，流水线需要清除错误预加载到流水线的内容，重新开始进行转移目标处的取指，因此会延迟几个周期。

#### 流水线的几种冲突

> 其实计组都讲过并且讲的内容一模一样

- 资源冲突：流水线上的两条指令使用同一组件（资源）导致的冲突，比如两条指令同时要求从数据/指令总线取数据（即访问同一个存储器），需要使用同一控制单元。

- 数据冲突：比如写后读冲突：在后续指令尝试读取一个寄存器的值时，前面的指令尚未完成结果的写回。

  指令层的数据冲突：一个指令所需的数据没有计算出来

  传输层的数据冲突：一个指令需要的寄存器内容还没有从内存中读取完成

- 控制流冲突：分支预测问题，比如执行条件转移指令时，必须等待此指令的执行阶段结束，求出条件是否为真，决定是否跳转，才能继续流水，因此会减慢流水线的速度。

  ![image-20250622114346682](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAIBDWia9a0LUSKfX1MSfUKaBl2raT3KAAILHAACnTzZVBjlkbaPa0czNgQ.png)

  > 图片中是预测跳转不发生；但实际跳转发生了，因此需要清除已经进入流水线的错误指令，重新启动流水线。

#### 流水线指令冲突的两个**主要原因**

- 寄存器冲突（寄存器被占用、读指令/数据时总线冲突，即资源冲突）
- 分支指令：分支预测失败（即控制流冲突）

如何解决冲突呢？

- 调整代码顺序：对于两条相邻的，需要访问同一寄存器的指令，选择一条不需要访问同一寄存器的指令插到他们中间，以在不减慢流水线速度的情况下，解决数据冲突。
- 合并循环：将两个循环合并为一个循环，减少条件检查的次数，从而降低控制流冲突（跳转）带来的影响

## ARM9TDMI 内核

ARM9TDMI 是 ARM7TDMi 内核的后续版本，它采用了哈佛结构：

1. 指令和数据分别存储在不同存储器中

2. 取指令和取数据采用不同的总线

   因此，哈佛结构中，不同指令的取指和取操作数可以在同一个周期内进行，不会导致流水线延迟。

冯诺依曼结构成本较低，且容易实现，但容易出现资源冲突（无法同时取操作数/指令）；哈佛结构成本较高，较难实现，且不容易扩展，不过速度较快，不容易出现资源冲突。

### ARM9 的流水线

ARM 9 的流水线由三级变为了五级。五个阶段分别为：

取指，译码，执行，访存和写回

> 和计组讲到的标准流水线一样
>
> 写回阶段其实是写回值到寄存器，而非写入主存

对于不需要访问主存的指令（比如 ADD 指令，其数据全部读取/写入到寄存器中），访存周期什么都不做即可。

优点：增加流水线段数可以减少多条指令的总执行时间，吞吐量更大；缺点是延时更大了。

- 随着流水线深度(级数)的增加，每一段的工作量被削减了，这使得处理器可以工作在更高的频率，同时改进了性能;
- 负面作用是增加了系统的延时，即内核在执行一条指令前，需要更多的周期来填充流水线;
- 流水线级数的增加也意味着在某些段之间会产生数据相关;

实际考试中主要还是考察三级流水线的操作。

## ARM 编程模型

此部分介绍一些 ARM 结构常见的寄存器，数据类型等知识。

### 数据类型

ARM 处理器一般支持 8 位-32 位的数据，有支持 8 位（字节）的处理器，有支持 16 位（半字）的处理器，有支持 32 位（字）的处理器。

有符号数和无符号数：有符号数采用其存储空间的最高位存储符号，其他部分用于存储实际数据；无符号整数可以采用全部的空间范围。

无符号数的范围是 0 到 $2^N-1$；有符号数的范围是 $-2^{N-1}$ 到 $+2^{N-1}-1$。由于 0 的存在，正负可表示的数字范围不对称，正数表示范围比负数少 1。

有符号数常常采用补码表示：当原先数字 >0 时，补码=原码；当原先数字 <0 时，补码=原码除符号位外按位取翻，再加 1。

注意：

- 所有的数据操作（比如 ADD）都对一整个字做操作（四个字节）

- LOAD 和 STORE 指令可以操作字节，半字或者字。

- ARM 指令的长度刚好是 32 位（一个字），Thumb 指令集的长度是 16 位（一个半字）

  > 因此提到过，每流一级流水线，PC+4/+2，因为指令长度是4字节/2字节。

### 处理器状态

ARM 处理器有两种状态：

- ARM 状态：以字（32 位）为单位进行数据操作
- Thumb 状态：以半字（16 位）为单位进行数据操作

![image-20250622134922101](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAIBDmia9bDOS96weGNWg3rfZZ_tE8yxAAIMHAACnTzZVLaN8tkYq9-pNgQ.png)

可以通过 BX 指令在这两种状态间切换，通过 BX 指令引用的寄存器地址最后一位是 0 还是 1 进行切换（0:切换为 ARM 状态，1:切换为 Thumb 状态）

### 处理器模式

处理器可能存在多种运行模式，比如用户态/系统态。在不同的模式下，逻辑寄存器（寄存器名称）映射到的实际寄存器位置可能不同。

处理器的所有模式如下：

| 模式          | 说明                           | 备注                                               |
| ------------- | ------------------------------ | -------------------------------------------------- |
| 用户（usr）   | 正常的工作模式                 | 不能直接切换到其他模式                             |
| 系统（sys）   | 支持操作系统的特权任务         | 与用户模式类似，但具有可以直接切换到其他模式等特权 |
| 快中断（fiq） | 实现高速数据传输和通道处理     | FIQ 异常响应时进入此模式                           |
| 中断（irq）   | 通用的中断处理                 | IRQ 异常响应时进入此模式                           |
| 管理（svc）   | 操作系统保护模式，处理软件中断 | 系统复位和软件中断（响应系统调用）时进入此模式     |
| 中止（abt）   | 用于支持虚拟存储器和存储器保护 | 用于 MMU 硬件中断                                  |
| 未定义（und） | 处理未定义的指令陷阱           | 未定义指令异常响应方法时进入此模式                 |

除了用户模式下，其他六种模式都称为“特权模式”。特权模式中，除了系统模式是用于运行特权指令之外，其他五个模式称为“异常模式”，即不是经常使用的模式。

异常模式中，很多逻辑寄存器映射到的实际寄存器不同，保证异常模式下的寄存器操作不会破坏某些用户模式使用的寄存器。

处理器启动时的模式变化：

先进入管理模式，以完成内存等组件的初始化；之后，处理器会在多种特权模式之间变化，以完成各个模块的初始化，比如配置各个模式下的 R13（SP）寄存器。此时不能进入用户模式。

初始化完成后，处理器进入用户模式，可以正常执行代码。

> 用户模式是指令运行时处理器的常态，即最常处于的模式。

### ARM 处理器的寄存器

ARM 具有 37 个 32 位的寄存器，每个寄存器在各种模式下对应的物理寄存器可能不同。

![image-20250507210903273](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAIBD2ia9bOFqLGGzD0Iqkyn9otCetf4AAIOHAACnTzZVAVBkl51uIyqNgQ.png)

上图表示了部分寄存器在不同模式下的不同分布。

37 个寄存器中包含：

- 1 个 PC 寄存器（上图中的 R15 寄存器），指示将要取的指令的地址

- 1 个 CPSR 寄存器（当前状态寄存器，程序状态字）

- 5 个不同的 SPSR 寄存器（状态保存寄存器）。从上面的图片中可以看出，除了用户和系统态外的五个异常模式每个模式都对应了一个不同的 SPSR 寄存器。可以用于存放特定于模式的数据，防止数据因为被模式切换而覆盖。

  注意 SPSR 寄存器是**特权模式下独有的**，**用户/系统模式下没有**。

寄存器的含义与用途如下：

- r0-r12：通用寄存器，可以存放各种数据。其中，r8-r12 寄存器在快速中断模式下有一个单独的版本 r8_FIQ。

- r13：保存工作状态的**栈寄存器**（sp），每个模式都有一个不同的 r13，可以防止数据相互覆盖。

  这个是栈，即可以存放多个数据，这些数据不会被覆盖，采用栈的进出形式。

  后面会提到，在函数调用嵌套时就会用到 r13 寄存器。

- r14：用来保护程序返回地址的链接寄存器（lr）。用于在函数调用时存放函数执行完成后的返回地址

  在跳转之前，把 PC+1 地址存到 lr 寄存器中；在函数调用结束时，把 lr 寄存器保存的地址恢复到 PC 中，即可继续执行调用前的代码。

  **除了用户和系统模式外，其他五个异常模式都有自己单独的 r13 和 r14**。

- r15：即 PC 寄存器

r0-r12 寄存器可以用于任意用途，因此常常被编译器用于优化常用变量的访问速度。

其中，r0-r7 寄存器称为未分组的寄存器，即所有处理器状态都共用同一个物理寄存器。在其他模式下修改这些寄存器的话，原本模式下这些寄存器的值就会丢失。

r8-r12 寄存器有两个分组，一个用于 fiq（快中断），一个用于其他状态。这样在快中断模式中的修改不会影响主程序的寄存器，缩短了快中断时保存/恢复寄存器值所需要的时间。

r13-r14 都各自具有六个物理寄存器，其中一个用于用户和系统模式，其他五个寄存器分别对应五个异常模式。

r14 寄存器可以用于保存函数调用时的返回地址，或者保存寄存器的状态。

在切换模式时，r13 寄存器可以用于保存 r0-r12 寄存器的当前值，避免在其他模式下被覆盖；在切换回当前模式时，从 r13 寄存器中提取 r0-r12 寄存器的存储值。

#### 多次调用问题

子程序调用的步骤如下：

1. 调用时，处理器会将返回地址（即调用指令的下一条指令的地址）存入链接寄存器（LR）中。
2. 将转移目标地址放入 PC，开始执行子程序
3. 子程序执行结束后，以 `mov PC, LR` 指令结束，将 LR 保存的返回地址放入 PC，继续执行过程调用前的指令。

在多层子程序嵌套调用时，如果在第二次以及之后调用时不保存 LR 的值，就会破坏之前存储的 LR，导致出现问题。图片实例如下：

![image-20250514194332233](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAIBEGia9bUyZZF167ewIwABVFvnNgv7CwACDxwAAp082VSQRTqbJGmpRDYE.png)

- 在 A 调用 B 时，A 的返回地址被存放到 LR 中

  返回地址通常是进行跳转的指令的下一条地址，即上图中 `BL Table1` 后面的寄存器。

- B 嵌套调用 C 时，B 的返回地址被存放到 LR 中，破坏了之前 LR 中存储的 A 的返回地址

- B 函数返回时，由于 LR 存放的内容实际是 B 的返回地址，会导致跳转到自身的中间部分，从而导致无限循环

解决方法：

1. 每次进行函数调用前，把 LR 当前的值压入栈（通常是 R13 寄存器）中
2. 每次完成函数调用，返回 LR 指向的地址后，从栈中弹出栈顶，写入 LR 中。

#### R14 寄存器与异常跳转

异常发生时，程序要跳转到异常服务程序，和子过程调用是类似的。不过，有些异常在返回时需要一个常数的偏移，即返回时可能返回到产生异常的本条指令/下一条指令/上一条指令。

这个常数偏移是在将 IR 内容写回 PC 时计算的。在写回前，先将 IR 的内容加一个常量。

一般 IRQ 中断的处理：由于中断可能发生在用户模式的子程序调用过程中，为了不破坏用户模式的 LR，中断开始时将返回地址**放在 R14_IRQ** 中（即 IRQ 模式下的 LR）；中断完成后，将 **R14_IRQ** 中的内容加上一个常量偏移（取决于异常类型）放到 PC 中，继续执行中断前的程序。

异常嵌套冲突：比如，在出现一个 IRQ 异常，并且允许处理 IRQ 中断（普通中断）时又发生了 IRQ 中断，那么之前中断处理程序遗留在 **R14_irq** 中的数据可能被新的 IRQ 中断破坏。（这个问题和嵌套子程序调用的问题一样）

因此，一般情况下，ARM 不允许 IRQ 模式下再次发生 IRQ 中断。IRQ 模式只能被 FIQ（快中断）模式打断。如果 IRQ 模式下发生了 IRQ 中断，新的中断会延迟到当前中断处理完后再被处理。

> 如果真的要嵌套中断的话，可以在每次中断开始前把当前 R14_IRQ 的内容压入 R13_IRQ 的栈；每次结束中断，跳转完成后弹出 R13_IRQ 的栈顶，恢复 R14_IRQ。

#### 程序指针 PC（R15）

PC 是程序指针（Program Counter），指向正在取指的地址。

在 ARM 状态下，由于采用三级流水线，PC（程序计数器）的值通常是当前执行指令的地址 + 8 字节。这是因为当一条指令在“执行”阶段时，流水线已经将下两条指令预取到了“译码”和“取指”阶段。PC 总是指向正在“取指”的指令地址。

当使用 STR/STM 指令保存 R15 时，需要注意我们实际要保存的地址很可能是是 PC-4 或者 PC-8 位置的地址。

> 记住指令在**执行**阶段才会保存 PC，而此时的 PC 已经走到了**下两条指令**处。

对 PC 寄存器的写入相当于执行了无条件跳转指令。由于 ARM 指令以一个字为边界，因此写入R15 的值最低两位通常为 0b00。具体的规则取决于内核结构的版本:

- 在ARM结构V3版及以下版本中，写入 R15 的值的最低两位被忽略，恒定为 00，因此跳转地址由指令的实际目标地址(写入 R15 的值)和0xFFFFFFFC相与得到;
- 在ARM结构V4版及以上版本中，写入 R15 的值的最低两位必须为 0，如果不是，结果将不可预测。

#### CPSR 和 SPSR

CPSR：程序状态寄存器，包含一些条件标志，中断使能标志，当前处理器模式等内容。

SPSR：程序状态保存寄存器。每种异常状态都有一个不同的寄存器。在进入异常时，SPSR 中保存 CPSR 的当前值，以便退出异常状态时通过其内容恢复 CPSR。

由于系统和用户模式不是异常模式，它们没有 SPSR 寄存器。

> SPSR 就是专门用来在各个异常模式下保存 CPSR 的寄存器。

CPSR 的格式如下：

主要分为三部分：条件码标识位，保留位（没有作用）和控制位。

![image-20250509175757518](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAIBEWia9bgB2euvtVyjwhcaKc89j87WAAIRHAACnTzZVCP1cvJDPtEHNgQ.png)

N（负标志位）：上一条指令计算结果为负：1；正/0：0

Z（零标志位）：上一条指令计算结果为 0：1；其他非零数字：0

C（进位标志）：加法出现进位：1；正常完成：0；

减法出现借位：0；正常完成：1

其他情况：保留之前的值不变

V（溢出标志）：加减法指令结果溢出：1；没有溢出：0；其他指令：保留之前的值不变

M4...M0 这五位表示 CPU 当前处于哪种运行模式。

### ARM 异常和中断

异常是指打断处理器正常运行，并且使处理器进入特权处理状态的事件。异常分为同步异常和异步异常。

- 同步异常：指令执行时引发的异常，比如运算时尝试除 0
- 异步异常（中断）：外部信号导致的异常，比如串口连接，复位键被按下等事件。

当几个异常同时发生时，就需要按照特定的次序处理异常。异常的优先级如下：

复位 > 数据异常中止 > FIQ > IRQ > 预取指异常中止 > SWI（软中断）或者未定义指令

SWI 和未定义指令处于同一优先级，是因为这两个问题不可能同时发生。SWI 是一条明确的指令引发的，而未定义指令是由于译码时无法识别操作码导致的，这两个问题不可能同时出现。

可以采用一条指令完成多寄存器的拷贝，从而实现一条指令恢复用户状态的变量：

`STMFD SP! (R0-R3, LR)` 表示将 R0, R1, R2, R3, LR 按照从右向左的顺序依次压到位置位于 SP 的栈中。因此，LR 的地址为 SP 地址，R3 地址为 SP-4, R2=SP-8，R1=SP-12，……

`LDMFD SP! (R0-R3, LR)` 会将 SP 栈中的内容依次弹出，并从左向右赋值给 R0, R1, R2, R3, LR，即栈顶内容给 R0，……。

> SP 栈就是 R13 寄存器，其是一个堆栈指针，可以用于保存每个模式下的局部变量

通过两条指令，可以一键实现多个寄存器在状态变换时的保存和恢复。

#### 进入异常

在异常发生后，ARM 内核会进行如下工作：

1. 将当前 CPSR 的值保存到对应模式的 SPSR 寄存器中

2. 将返回地址保存到对应异常模式下的 LR 寄存器中。该返回地址通常是异常发生时 PC 的值加上一个偏移量，确保异常处理结束后能返回到正确的位置。

3. 由于 CPSR 中有一些位标记了当前的 IRQ/FIQ 状态、内核工作状态，因此需要修改 CPSR 模式，使其符合当前发生的异常的类型。

   比如，强制设置执行状态为 ARM 状态（可选），禁止 IRQ 中断（防止中断相互打断），设置 MOD 位为异常模式中的一种。

   > 不用担心，这里修改会在异常执行结束后恢复（因为备份 CPSR 到 SPSR 了）

4. 强制 PC 从相关的中断向量处取指，开始执行中断的指令。

有些处理器要求必须在 ARM 模式下处理异常。即使这些处理器正运行在 Thumb 模式下，只要它遇到异常，就会自动切换到 ARM 模式做处理。因此，需要强制修改 CPSR 中的 ARM 状态。

#### 退出异常

当异常结束时，需要如下工作：

1. 将 LR 的值减去一个偏移量后存入 PC

   这个偏移量根据我们处理的异常不同而不同。比如，数据异常时可能要求从出现异常的指令重新执行，而有的异常可能要求从出现异常的指令的下一条继续。

   计算返回地址时需要考虑两点：

   1. 发生异常时 PC 寄存器的值是否已经更新

   2. 异常返回时，被打断的指令是否还需要执行。这个和异常类型有关：

      ![image-20250514202201772](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAIBEmia9buxqaWkvxf-5Q_su1zrMkJYAAISHAACnTzZVEnD51KYXb1nNgQ.png)

2. 将对应模式 SPSR 存储的值赋值回 CPSR（从而消除了进入异常模式时对 CPSR 的修改）

## 内存和 I/O

大端和小端：大端就是指数据的高位放在低地址空间，小端就是数据的低位放在低地址空间。

> 高地址空间是指左侧，低地址空间是指右侧。

大小端一般是对于占用多个字节的数据类型而言的（占用一个字节也分不出来）；比如 int 数据是四字节的，假设数据为 0x12 34 56 78（每两位 16 进制数是一字节），那么小端就是 78 放在地址 0，56 为地址 1，34 为地址 2，12 为地址 3；大端就是 78 放在地址 3，56 放在地址 2，……

![image-20250622122103437](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAIBE2ia9b6fnxgcmc8AAftAAAHor6rUBjMAAhMcAAKdPNlUzfDltWO5EWY2BA.png)

通常的 ARM 内存系统都是小端的，即数据的低位放在低地址空间。

混合端序：如果一个数字无法在单个存储单元（比如 32 位机的单个存储单元就是 32 位，即 4 字节）中存下，那么就需要占用多个存储单元。早期的 ARM 机中，一个双精度的字将以大端顺序存储，而每个字的各个字节将以小端顺序存储。比如：

0x11223344 55667788，则存储为: 

0x4(相对地址) [31~0] bit：55667788

0x0(相对地址) [31~0] bit：11223344

可以看出，每个地址单元内部采用小端序；由于 0x4（地址较高）的位置存储了数据的低位（55667788），因此多个地址单元中是大端序存储的。

### I/O 端口的编址方式

在计组中我们了解过，I/O 端口的编址方法分为两种：

- 存储器映射式编址：

  I/O 端口的地址和内存地址是统一编址的，即二者在同一个地址空间内。可以使用访问存储器的指令访问 I/O 端口。

  通过地址所在的区域区分地址标记的是内存区域还是 I/O 端口。

- I/O 映射编址：

  I/O 端口的地址格式和内存地址不同，有自己独立的地址空间。需要通过专门的 I/O 指令访问 I/O 端口。

  通过指令的类型（访存指令？I/O 指令？）区分指令访问的是存储器还是 I/O 设备。

ARM CPU 的 I/O 端口都是存储器映射编址的。
