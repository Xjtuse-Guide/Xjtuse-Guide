# 第三章作业

> 仅供核对答案参考，请不要直接抄袭。

1. 什么是合法的立即数，0x0000F200是否合法，为什么？如何判断合法的立即数？非法的立即数出现在ARM指令中是否一定会报错？为什么要定义合法的立即数，缘由是什么？

   合法的立即数是指 0-255 范围内的 8bit 数字循环右移 2N 位（即右移偶数位）得到的所有数字。0x0000F200 是合法的立即数，因为它是 0xF2 循环右移 24 位得到的结果。

   通过定义即可判断合法的立即数，即将数字左移 2N 位（N<4，再多就循环了），能够得到 0-255 范围内的数就是合法的立即数。

   非法的立即数出现在 ARM 指令中不一定会报错，因为 ARM 指令集存在 MOV- MVN 这样相反的指令，如果立即数的反码是合法的立即数，那么编译器会修改使用的指令，从而让立即数合法。

   定义合法的立即数是因为 ARM 指令的第二操作码部分存在长度限制：只能存储 8 位的底数+4 位的指数；超过此长度限制的立即数无法存放在指令本身中。

2. ARM针对第二操作数可用的移位方式有哪些？其中ASR和LSR有什么区别？

   移位方式包含 LSL（逻辑左移），LSR（逻辑右移），ASR（算术右移）、ROR（循环右移）、RRX（扩展为 1 的循环右移）。

   ASR 在右移时，将左侧数字填充为符号位；LSR 右移时，将左侧数字填充为 0。

3. 前变址偏移和后变址偏移的区别是什么？分别如何操作地址和数据变化？

   前变址偏移是在访问寄存器存储的地址前增加/减小地址；后变址偏移是在访问寄存器存储的地址后增加/减小地址，并一定更新寄存器中存储的地址。前变址偏移会取得偏移后地址的数据，并且可选的会修改寄存器中的地址（如果存在!号）；后变址偏移会取得偏移前地址的数据，并且一定会修改寄存器中的地址。

4. 描述堆栈寻址和块拷贝寻址中的四种不同情况分别表述的是什么意义？他们之间有何种对应关系。

   ![image-20250623222939456](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAIBTmicpCYPDg3E58zyAZkQPOQ7hwziAAKrGwACqw3oVHVGZ_zYwNU9NgQ.png)

   数据块操作中，IA 表示传送后地址+4，IB 表示传送前地址+4，DA 表示传送后地址 -4，DB 表示传送前地址-4；

   栈操作中，FD 表示满递增栈，ED 表示空递增栈、FA 表示满递减栈、EA 表示空递增栈。

5. ARM指令中的条件码是如何实现其功能的？与CPSR中的数据有什么联系？举两个不同的例子说明情况。ARM指令中后缀S有什么意义。如何实现ARM和Thumb之间的切换。

   ARM 指令中的条件码通过判断 CPSR 状态字对应的 N Z C V 状态实现可选的条件执行。条件码查看的就是 CPSR 的前四个状态字。比如：

   ```
   cmp r0, r1
   ADDeq r1, r1, #1
   ```

   就是 `if r0==r1 then r1+=1` 的翻译；`cmp r0,r1` 在 r0-r1=0 时将 CPSR 的 Z 位置设置为 1，ADDeq 条件码查看 Z 位置，由于为 1，那么就执行语句；

   ```
   TST r0, #0x01
   ADDeq r1, r1, #1
   ```

   判断 r0 的后四位是否为 0000，如果是的话就设置 Z 位置为 1，从而执行 addeq 语句。

   S 后缀用于强制指令更新 CPSR 中对应的条件标志位。

   ARM 和 Thumb 状态的切换可以通过 `BX` 指令实现。如果 `BX Rm` 中的地址 Rm 最后一位是 1，就表示切换至 Thumb 状态；如果是 0，就表示切换至 ARM 状态。

6. 切换ARM状态到IRQ模式应该如何通过MRS和MSR指令实现。

   ```
   MRS r0, cpsr
   BIC r0,r0,#0x1F
   ORR r0,r0,#0x12
   MSR cpsr_c,r0
   ```

7. 完成下列操作后R0的内容是什么

   ```
   MOV R1,#5
   ADD R0,R1,R1,LSL #3
   ```

   R1 存储内容为 5，那么 R0 = R1+R1\*2^3^=R1\*9=45

8. 将下面C语言转换为汇编语言

   ```c
   If (a==0 || b==1）
   c=d-e*7；
   else
   c=e-d*9;
   ```

   转换结果如下：（假设 r0-r4 对应 abcde）

   ```
   cmp r0, #0
   beq TRUE_STATEMENT
   cmp r1, #1
   bne FALSE_STATEMENT
   TRUE_STATEMENT: RSB r5, r4, r4, LSL #3（r5 = r4^3^-r4=7*r4）
   SUB r2, r3, r5
   b END
   FALSE_STATEMENT: ADD r5,r3,r3,LSL#3（r5 = r3^3+r3=9*r3）
   SUB r2,r4,r5
   END: nope
   ```

9. 将下面C语言转换为汇编语言

   ```c
   int main(void) {
     int sum = 0, num = 1;
     while (num <= 100) {
       sum += num;
       num++;
     }
     return 0
   ```

   转换结果如下：

   ```
   mov r0, #0
   mov r1, #1
   WHILE_LOOP:
   cmp r1, #100
   BGT END
   add r0,r0,r1
   add r1,r1,#1
   b WHILE_LOOP
   END: mov r0, #0
   mov pc,lr
   ```

10. 用汇编语言实现1到101之间所有奇数的求和。

    ```
    mov r0,r0,#0
    mov r1,r1,#1
    FOR_LOOP:cmp r1,101
    bge END
    add r0,r0,r1
    add r1,r1,#2
    b FOR_LOOP
    END: nop
    ```