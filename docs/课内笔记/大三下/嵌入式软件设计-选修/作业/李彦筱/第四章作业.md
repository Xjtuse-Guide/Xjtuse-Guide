# 第四章作业

> 仅供核对答案参考，请不要直接抄袭。

1. 如何利用伪操作定义一个完整的宏？在程序中如何调用？请举例说明

   定义格式：

   ```
   MACRO
   ${label} macroname {$para1{,$para2...}}
   （宏内容）
   MEND
   ```

   其中 \$label, \$para1 这些地方一般就这么写；macroname 替换为自己宏的名称；在程序调用时，使用

   `label macroname para` 的形式调用，其中 macroname 需要和宏定义的名称一致，label 和 para 的实际值会替换宏中所有的 ${label} 的内容。举例如下：

   ```
   MACRO
   $label LOOP $para1
   mov r6,#10
   $label.loop1
   mov r0,#$para1
   subs r6,r6,#1
   bne $label.loop1
   MEND
   ```

   调用格式如下：`AA LOOP 10`

2. 用汇编语言伪操作实现：

   ```c
   If ((a!=b) && (a-b>5)) 
   a=a+b;
   else
   a=a-b;
   ```

   实现如下：

   ```
   ; 假设 a 和 b 是已定义的全局汇编变量
   IF (a <> b) && ((a - b) > 5)
       a SETA a + b
   ELSE
       a SETA a - b
   ENDIF
   ```

3. 分析说明下段程序每句是什么意思，完成什么功能。

   ```
   AREA ChangeState, Code, READONLY
   LDR R0,=start+1
   BX R0
   start MOV R1,#1
   ```

   `AREA ChangeState, Code, READONLY`：声明一段汇编程序及其属性

   `LDR R0,=start+1`：伪指令，取标签 start 对应指令所在地址+1，存入 R0 中

   `BX R0`：跳转指令，由于 R0 存储地址的末尾是 1，BX 指令将处理器切换为 Thumb 状态

   `start MOV R1,#1`：此指令的标签为 start，作用是将数字 1 存入 R1 寄存器中。

4. ADR, ADRL和LDR伪指令各有什么特点和区别。实际操作中，分别会转化成什么样的ARM指令，如何进行运算？（结合上述伪指令的意义，理解课件的例子）

   三种伪指令都是用于地址读取的，用于获取某个标签对应的指令地址。区别在于，三种指令支持的读取地址范围不同（即伪指令-目标标签所在地址允许的差不同）

   ADR 指令会被翻译为单条 ADD/SUB 指令，通过 PC 相对位移得到标签位置的地址。

   ADRL 指令会被翻译为两条 ADD/SUB 指令，因此范围限制更大。

   LDR 指令将一个标签或者立即数放入寄存器中。编译器将尝试将其翻译为一条 MOV/MVN 指令，但如果立即数不合法，则将其放在文字池中，通过一条基于 PC 的 LDR 指令读取此常数。

5. 用汇编实现一个函数 add_two_numbers，在 C 中调用它，计算并返回两个整数的和。

   要求：C 代码传递两个参数（a, b），汇编函数返回结果。

   使用 ARM 寄存器传参（R0, R1）和返回值（R0）。

   ```
   汇编：
   ;add_two_numbers
   AREA SCopy,CODE,READONLY
   EXPORT add_two_numbers
   add_two_numbers
       ADD R0,R0,R1
       MOV pc,lr
       END
   ```

   C：

   ```c
   #include <stdio.h>
   extern int add_two_numbers(int a, int b);
   
   int main(){
     printf("3+4=%d", add_two_numbers(3, 4));
     return 0;
   }
   ```

6. 用汇编编写一个函数 enable_irq，在 C 中调用它来启用 ARM 处理器的 IRQ 中断。

   汇编：

   ```
   AREA Enable_irq,CODE,READONLY
   export enable_irq
   enable_irq
       MRS R0, CPSR
       BIC R0, R0, #0x80  ; 清除 I-bit (bit 7) 来使能 IRQ
       MSR CPSR_c, R0
       MOV PC, LR
       END
   ```

   C 语言：

   ```c
   extern void enable_irq();
   
   int main(){
     enable_irq();
     return 0;
   }
   ```

7. 有如下C程序，翻译成ARM汇编

   ```
   int fun(int x1, int x2, int x3, int x4,int x5, int x6)
   {
      return x1+x2+x3+4*x4+x5+2*x6;
   }
   ```

   翻译结果如下：

   ```
   AREA fun,CODE,READONLY
   export fun
   fun
     LDR r4, [sp, #0]      ; 从栈加载第5个参数 x5
     LDR r5, [sp, #4]      ; 从栈加载第6个参数 x6
     ADD r0, r0, r1        ; r0 = x1 + x2
     ADD r0, r0, r2        ; r0 = r0 + x3
     ADD r0, r0, r3, LSL #2; r0 = r0 + 4*x4
     ADD r0, r0, r4        ; r0 = r0 + x5
     ADD r0, r0, r5, LSL #1; r0 = r0 + 2*x6
     MOV pc, lr
   END
   ```

8. 编写一段ARM汇编程序来调用7题中的C函数fun

   ```
   AREA call,CODE,READONLY
   IMPORT fun
   ENTRY
   ; 假设 r0-r5 已经包含了要传递的6个参数值
   MOV r0, #1
   MOV r1, #2
   MOV r2, #3
   MOV r3, #4
   MOV r4, #5  ; 第5个参数
   MOV r5, #6  ; 第6个参数

   STMFD sp!, {r4, r5} ; 将第5、6个参数压栈
   STMFD sp!, {lr}     ; 保存返回地址
   BL fun
   ADD sp, sp, #8      ; 清理栈空间
   LDMFD sp!, {pc}     ; 返回
   END
   ```

9. 编写一段C程序来调用7题的汇编函数fun

   ```c
   #include <stdio.h>
   
   extern int fun(int x1,int x2,int x3,int x4,int x5,int x6);
   
   int main(){
     printf("%d", fun(1,2,3,4,5,6));
     return 0;
   }
   ```

10. 设计一段汇编程序完成数据块复制，数据从源数据区snum复制到目标数据区dnum，复制时，以8个字为单位进行。对于不足8个字的数据以4个字为单位进行。如果少于4个字不复制。（参考课件内的例子）

    ```
        AREA ARMex, CODE, READONLY
    NUM EQU 20
    ENTRY
        LDR r0, =src      ; 源地址
        LDR r1, =dst      ; 目标地址
        MOV r2, #NUM      ; 待复制字数
    Bcopy
        MOVS r3, r2, LSR #3 ; 计算可以复制多少个8字块 (r2/8)
        BEQ Cword         ; 如果为0，跳转到处理4字块
    Loop8
        LDMIA r0!, {r4-r11} ; 从源地址加载8个字
        STMIA r1!, {r4-r11} ; 存储到目标地址
        SUBS r3, r3, #1   ; 块计数器减1
        BNE Loop8
        AND r2, r2, #7    ; 获取剩余不足8字的字数
    Cword
        MOVS r3, r2, LSR #2 ; 计算可以复制多少个4字块 (r2/4)
        BEQ CEnd          ; 如果为0，结束
    Loop4
        LDMIA r0!, {r4-r7}
        STMIA r1!, {r4-r7}
        SUBS r3, r3, #1
        BNE Loop4
    CEnd
        B CEnd            ; 结束循环
    src DCD 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20
    dst DCD 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    END
    ```
    
11. 说明C语言调用汇编和汇编调用C语言在声明，调用，返回等需要进行何种操作？（结合本章课件最后几页的例子理解C和汇编互相调用的过程）

    C 调用汇编语言需要汇编语言通过 `export` 语句导出某个标签作为符号，C 语言中通过 `extern` 语句声明这个汇编函数的输入和输出。在调用时，C 语言按照一般函数格式调用，汇编语言中 r0-r3 寄存器是调用的前四个参数，其他参数在 sp 栈中；返回值放入 r0 寄存器，通过 MOV pc,lr 返回

    汇编语言调用 C 语言只需要汇编语言通过 `import` 语句导入 C 函数名对应符号，C 语言不需要操作；调用时，将前四个参数放到 r0-r3 寄存器中，其他参数放入 sp 栈内，通过 BL 指令调用函数；之后，从 r0 寄存器中取出返回值。