# 第三章——传输层

> 易俊泉学长的原始笔记链接如下：
>
> [[计算机网络]第三章——传输层](https://github.com/yijunquan-afk/XJTUSE-NOTES/blob/master/%E5%A4%A7%E4%B8%89%E4%B8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/chapter03%20TransportLayer/chapter03-transport-layer.md)

## 3.1 概述和传输层服务

传输层提供了两种主要的通信服务：**TCP** 和 **UDP**。

传输层协议为运行在不同主机上的<mark>**应用进程之间**</mark>提供了<mark>**逻辑通信( logic communication)**</mark>功能。

> 这种通信是**进程到进程**的通信，具有较高的精细度。

从应用程序的角度看，通过逻辑通信，运行不同进程的主机好像直接相连一样；实际上，这些主机可能位于地球的两侧，通过许多路由器及多种不同类型的链路相连。应用进程使用传输层提供的逻辑通信功能彼此发送报文，而无需考虑承载这些报文的物理基础设施的细节。

![image-20220403200600078](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAOyaJcEXM4XZuakZGLxgisSbDevP5UAAucZAALIgblUMdrDESsU92g2BA.png)

如图所示，传输层协议是在**端系统中实现的，而不是在路由器中实现的**。在发送端，传输层将发送应用程序进程接收到的报文转换成传输层报文段（segment）。实现的方法通常是将应用报文划分为较小的块，并为每块加上一个传输层首部以生成传输层报文段。然后，在发送端系统中，传输层将这些报文段传递给网络层，网络层将其封装成网络层分组（即数据报）并向目的地发送。

网络路由器仅作用于数据报的网络层字段；即它们不检查封装在数据报中的传输层报文段的字段。在接收端，网络层从数据报中提取传输层报文段，并将该报文段向上传递给传输层。传输层则处理接收到的报文段，使该报文段中的数据可供接收应用进程使用。

### 传输层概述

因特网网络层协议被称为 IP（网际协议），为主机之间提供了逻辑通信。IP 的服务模型是尽力而为交付服务（best-effort delivery service）。这意味着 IP 尽其“最大努力”在通信的主机之间交付报文段，但它并不做任何确保。特别是，它**不确保报文段的交付、不保证报文段的按序交付，也不保证报文段中数据的完整性**。因此，IP 被称为不可靠服务（unreliable service）。

每台主机至少有一个网络层地址，即所谓的 IP 地址。

在对 IP 服务模型有了初步了解后，可以总结 UDP 和 TCP 所提供的服务模型。UDP 和 TCP 的基本责任是：**将两个端系统间 IP 的交付服务扩展为运行在端系统上的两个进程之间的交付服务**。将主机间交付扩展到进程间交付被称为传输层的多路复用（transport-layer multiplexing）与多路分解（demultiplexing）。

UDP 和 TCP 还可以通过在其报文段首部中包括差错检查字段而<mark>提供完整性检查</mark>。进程到进程的<mark>数据交付和差错检查是两种最低限度的传输层服务，也是UDP所能提供的仅有的两种服务</mark>。特别是，与IP一样，UDP也是一种不可靠的服务，即不能保证一个进程所发送的数据能够完整无缺地(或全部!)到达目的进程。

关于 TCP 的详细讲解将在后续部分展开。

### 传输层的功能

1. 提供应用进程之间的逻辑通信（网络层提供主机之间的逻辑通信）。
2. 提供复用与分用。
3. 差错检测。
4. 提供无连接的或面向连接的服务。

### 两种传输层服务

- **TCP**：提供连接管理、拥塞控制、流量控制和可靠性控制。
- **UDP**：不可靠的“最佳努力”协议。

### 不提供的服务

1. **实时性**：不保证传输时间在特定时间内。虽然 UDP 协议“实时性好”，但它同样无法做出这种保证。
2. **带宽保证**：不能保证连接的带宽至少有多大。

## 3.2 多路复用与多路分解

将两个主机之间传输的数据送给正确的接收应用程序的过程称为**多路分解**。

> 一个进程有一个或多个套接字，相当于从网络向进程传递数据和从进程向网络传递数据的门户。
>
> 接受方中的传输层并没有直接将数据交付给进程，而是给了套接字。

两个主机之间可能有多个程序，两两连接，同时传输数据；**多路复用**是指多个程序同时发送数据时，报文不会混淆、弄错。

这种功能是传输层直接实现的，较为基础，TCP 与 UDP 都具有这两个功能。

传输层通过**==端口号==**区分接收每个数据段的应用程序。

![image-20220317153846421](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAOzaJcEbvFjk7iNKWxWqsWk0mNgBKYAAugZAALIgblUxFY9VhqB5ps2BA.png)

上图中的 M 就是指发送方端口号和接收方端口号。

> ==下面是多路复用/分解较为官方的定义；如果你在上面已经明白了这两个概念，就不用看。==

每个传输层报文段中具有几个字段。在接收端，传输层检查这些字段，标识出接收套接字，进而将报文段定向到该套接字。**将传输层报文段中的数据交付到正确的套接字的工作称为多路分解**（demultiplexing）。

> 类似于打开微信和qq，qq的消息不会给微信，微信的消息不会给qq

**在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（这将在以后用于分解）从而生成报文段，然后将报文段传递到网络层，所有这些工作称为多路复用（multiplexing）**

> 发送端进行多路复用；接收端进行多路分解
>
> 例如小明从邮递员收到新建，并通过查看收信人姓名而将信件交付给他的朋友时执行的就是多路分解；而当小美从朋友手中收集信件并交给邮递员时，执行的就是多路复用

**传输层多路复用的要求**

> :one: 套接字有唯一标识符（端口号）
>
> :two: 每个 segment 记录特殊字段（套接字的**端口号**）来指示所要交付到的套接字

端口号是一个 16 位的数，大小在 0\~65535 之间，0\~1023 范围之间的是周知端口号（如HTTP：80，FTP：21，telnet：23)，用户使用的端口号要大于1023：1024~65535

> 一般发送端的随机端口号都用 10000 以上乃至 30000 以上的端口号。

![image-20220317152250801](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAO0aJcEgolb_aFcx8npv9tvV03vZ2kAAukZAALIgblUCUgqahwLIik2BA.png)

一般情况下，源端口号可以是随机分配的，接收端的端口号是恒定不变的。

> 下面随便看看就行，不是很重要，也不难

### 无连接（UDP）的多路复用与多路分解

通常，客户端应用程序的端口号可以自动分配

此时，一个 UDP 套接字是由一个二元组标识的：<mark>目标 IP 地址和目标端口号</mark>。

报文段中的源端口号和源IP地址可以作为报文段回发时的返回地址使用

![image-20220315105623139](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAO1aJcElDW6nHEyz07r4m-FzB-zceYAAuoZAALIgblUcrDLb526Wqk2BA.png)

### 有连接的多路复用与多路分解

<mark>一个 TCP 套接字需要一个四元组</mark>

**源IP地址和目的IP地址，源端口号和目的端口号**

> 具有不同源IP地址和源端口号，但是具有相同目的IP地址和目的端口号的两个报文段会被送到不同的套接字中
>
> 从编程上看，TCP 的 socket 在 accept 成功（建立一个连接）后会返回一个新的 socket，需要通过这个新 socket 而不是原来的和发送端通信。
>
> 也就是说，接收端每建立一个 TCP 连接，都会生成一个新的套接字，且这些套接字的目的 IP-端口号都是完全一致的，只有源 IP/端口号可能不同。
>
> 这其实是由于 TCP 需要连接决定的；UDP 不需要连接就能发送数据，因此接收端完全可以同时接受多个发送端发送的数据；而 TCP 需要一对一连接，因此接收端对每个发送端连接都需要产生一个套接字，且每个发送端发送的内容只会到达接收端对应的套接字上。

![image-20220315105830413](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAO2aJcEpDa1Tn6NMwPkFYndP2-C4bYAAusZAALIgblUwvPUsx134Zo2BA.png)

## 3.3 UDP|User Datagram Protocol :用户数据报协议

UDP 的段叫数据报。

> 由于 UDP 和下一层网络层非常类似（太简单了），UDP 的数据名称既可以是传输层的“段”，也可以是网络层的“数据报”。

UDP 只具有传输协议能够做的最少工作：**多路复用/多路分解；差错检测**。几乎是直接跟 IP 打交道，几乎就是和 IP 协议等价。

> 上面这俩工作是传输层最基本的服务。
>
> 说实话，UDP 连丢包都不在乎，差错检测真的有必要么）

使用 UDP 时，在发送报文段之前，发送方和接收方的传输层实体之间没有握手，因此 UDP 被称为是*connectionless*

提供的是"best effort"服务，即尽最大努力。这意味着 UDP 的数据报：

- 可能出现任意数量的错误（不过可以检查出错误，但无法纠正）
- 可能丢包
- 可能乱序

<mark>**特征**</mark>

:one: **实现简单**：发送方、接收方没有连接状态，无需连接，因此*不需要缓存*。

:two: **数据段段头小**(8字节)，传输开销小，时延较短

> 这么小的段头里面甚至还包含 2 字节的保留空间

:three: **速度快**：不用拥塞控制之类的控制，因此速度很快

<mark>**典型应用**</mark>

Remote file server (NFS) 远程文件服务器（局域网内使用，不太丢包，所以常用 UDP）

Streaming multimedia 流式多媒体（UDP 实时性好）

Internet telephony 网络电话（同上，实时性要求较高）

Network management 网络管理系统（局域网，因此 UDP）

Routing protocol(RIP)（路由协议）

Name translation (DNS)（上一章讲过）

Multicasting （多播通信，发送端发送一份数据，多个接收端一起接收信息）

> 其实 IPv4 网络还不支持多播通信，IPv6 才支持呢；现在群聊采用仿多播通信，用 MCU 实现的

Real-time involved apps(RTP)实时传输协议（同样还是实时性要求高）

TFTP（简单 FTP 协议，采用 UDP）

DHCP 动态主机配置协议（自动分配 IP 地址，应用层协议；局域网使用不怕丢包，而且需要多播/广播通信）

以上基本是所有 UDP 协议的应用了。除了这些协议之外，其他的应用层协议大概率都用 TCP 协议。

### UDP 报文段结构

==**易考**==

**段头只有 8 个字节**：源端口号、目的端口号、长度、校验和 各自 2B

> 注意端口号是封装在段头里的

![image-20220317155726844](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAO3aJcEtLOHiTRSYNKhRP9W0z6EC-IAAuwZAALIgblUwevChTAt5bE2BA.png)



### UDP 校验和 checksum

UDP 检验和提供了差错检测功能。这就是说，检验和用于确定当 UDP 报文段从源到达目的地移动时，其中的比特是否发生了改变(例如，由于链路中的噪声干扰或者存储在路由器中时引入问题)。

不过 UDP 只能**检测错误，不能修复错误**。

**发送方**

:one: 将段内容视为 16 位整数序列（每 16 位分割一次，分割成多个数字）

> 0110011001100110
>0101010101010101
> 0000111100001111

:two: 对得到的所有数字相加，取**低16位**，再**按位取反**，得到校验和

> 取低 16 位主要是校验和字段一共 2 字节，就只有 16 位

> 相加得到 1100101011001010
>
> 按位取反得到 0011010100110101，这就是校验和

:three: 发送方将校验和 0011010100110101 输入 UDP 校验和字段

**接收方**

:one: 将段内容视为 16 位整数序列

> 0110011001100110
>0101010101010101
> 0000111100001111

:two: 对段内容相加，取低 16 位

> 相加得到1100101011001010

:three: 与 checksum 再相加，检查是否全为1（这里相加就是1111111111111111）

> 校验和按位取反了，因此加上所有数字的和就是全 1。

> NO -检测到错误
>
> YES -没有检测到错误

这种检错能力很弱，有差错也只能照样传送，不能修复。

非常难崩的是，网络层检验 UDP 数据报的时候，校验和一定是对的；要是有差错的话，数据链路层（网卡）就已经把包扔了。

> 所以据老师来说，UDP 的检验和是个完全多余的设计，因为自己这层（网络层）甚至都拿不到错误的包做校验，底下的数据链路层帮你校验完，出错就扔了。
>
> 很可惜，这个字段已经没法修改了；如果改这个底层协议，一大堆网络设备和应用程序都要完蛋）
>

注意：下方提到的的 GBN 协议和 SR 协议**不会在考试中考察**，可以仅做了解。不要把这两个协议的内容和 TCP 协议混淆了。

## Go-Back-N 协议（GBN）

 可靠性传输协议：可以通过传输层、网络层或者数据链路层实现。

可靠性的通信协议都需要做到：**接收端确认发送端的信息**。最简单的可靠性协议大概是这样：

- 发送端发送一个包
- 接收端收到这个包，根据包内容是否正确/是否收到发送回复
- 发送端根据回复，如果接收端收到了就发下个包，没收到就重发

这种协议的缺点是**太慢了**，每发一个包就需要 RTL 延迟，因为需要等待接收端的响应包到达才能发下一个包。

改进版的协议是 Go-Back-N（GBN），允许发送者在无需等待确认的情况下发送多个包，但未确认包的数量必须少于 N。



Go-Back-N (GBN)：允许发送方传输多个数据包而不等待确认，但未确认的数据包数量必须 <=N。如果未确认的数据包数量等于 N，那么必须等待接收端返回确认数据后，才可以继续发送。

![image-20250410151048658](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAO4aJcEt7MU8VFlxRgGGqJmbYBYxOcAAu0ZAALIgblUMF3o3n61emU2BA.png)

图中描述了一个“时间窗口”，形象的描述了“允许 N 个未确认的包”是什么样子的。

绿色表示接收端已经发送确认的包；黄色表示已经发送，但接收端未返回确认的包；蓝色表示未发送，但现在可以发送的包；白色表示由于窗口大小限制，现在不能发送的包。

> nexseqnum 指针分割了黄色和蓝色部分，即指向发送端下一个要发送的数据段
>
> send_base 指向整个窗口中第一个发送的数据段

蓝色的内容是发送端还可以发送的内容。黄色和蓝色的数量相加等于窗口大小（N）。

每个数据段的段头包含一个序号；序号从 0-$2^k-1$ 循环，其中 N = $2^k$（或者也可以说 k = $log_2(N)$）。这个序号是直接添加的，和段的状态没有关系。

### 定时器与超时

发送端设置了一个定时器，记录黄色分组中第一个包的发送时间；如果超时没有收到回复，那么就重传整个 N 窗口内的包。（包含黄色和蓝色，虽然蓝色还没发出去也谈不上“重传”）。

注意计时永远针对**最早发送的段**。

### 确认协议

GBN 协议始终对其接收到的**最后一个段进行确认**。比如，接收端接收到了黄色部分的前三个段，那么就只需要返回第三个段的段序号；发送端收到确认信息后，默认**前三个段全部正确收到**。

> 也就是不能单独确认后面某个段收到了，必须从前向后的确认。

即确认**最后一次正确收到的段的序号**。

GBN 协议属于滑动窗口协议的一种。当发送端收到确认信息后，如果确认了 x 段，窗口右移 x 位。

### 发送端的工作

GBN 协议中，发送端就只有三个工作：

- 应用层传输来数据后，需要**发送数据**

  如果发送窗口未满，那么直接封装数据为一个段然后发送，nextseqnum 右移一位

  如果窗口满了，设置一个“信号量”或者直接返回数据给应用层，告知自己窗口已满

- 收到接收端给出的 ACK 后，修改窗口大小

  右移 send_base 指针，重新设置窗口满信号量

- 窗口传输超时时，重新传输

  此时将 send_base 指针到 newseqnum 之间的一切黄色包重发一遍。

### 接收端的工作

> 注意这个协议是不允许乱序接收的

接收端先设置 expectseqnum=0（当前期待段序号为 0），然后：

- 等待接收数据。如果接受的数据序号和 expectseqnum 不等，那么直接丢弃；

  如果相等，那么发送 expectseqnum 这个段序号对应的 ACK 包，然后让这个 num 指针 +1

注意，每次发送 ACK 应答时，都需要发送 **正确收到的包中序号最大的**（最后收到的包）。

**即使收到错误的包，也需要返回 ACK，且返回的是最后一个正确收到的包的序号**。比如：

- 目前已经收到包 0 ，期待接收包 1，此时接收到了包 3，那么应当丢弃包 3，返回**包 0 的 ACK**（最后一个正确收到的包）

此协议接收端是没有缓存的。发送端存在缓存，这样在接收端丢包要求重传的时候，就不需要再找应用层要包内容了。

### 为什么要丢弃顺序不对的包？

如果不丢弃顺序错误的包的话，接收端就需要开辟缓存存储到达顺序错误的包，在其前方所有的包都到达后再传递给应用层。

假设接收端期待包 n，但到达了包 n+1，那么就需要在缓存中存储 n+1；如果包 n 后续真的到达了，那么就没有问题；但如果包 n 真的丢失了，发送方根据规则会重传包含 n 和 n+1 在内的所有包，这个缓存就没用了。为了节约缓存资源和简单起见，接收端就丢弃顺序不对的包了。

### GBN 协议总结

GBN 协议融合了 rdt 的几乎所有技术——不惜一切代价实现可靠性：

- 序列号

- 累计确认（确认包 n 收到相当于确认前方所有包均已收到）

- 校验和、发送缓冲区

- 超时/重传操作

TC P具有 GBN 的许多元素，但不是全部；TCP 是 Go-Back-N 和选择性重复协议的混合体。

缺点：

- GBN 协议的表现显著优于对等通信协议（每次发送后都需要等待接收方返回 ACK 才能发送下个段）
- 但在重传数据包时可能遇到性能问题。当延迟比较大的时候，GBN 可能错误地认为丢包发生了，然后重传整个窗口，然后由于延迟太大再次认为丢包了，然后接着重传，导致网络带宽的浪费。

## 选择性重复协议（SR）

Selective Repeat(SR)，即选择性重复，是指每次出现错误时，发送方仅仅重传错误的包，而非重传整个窗口。

SR 要求：

- 接收端单独确认每个收到的包（收到哪个包就确认哪个包，不能采用累计确认），且也需要确认乱序的包。

  接收端需要开辟缓存存储乱序到达的包。

- 发送端仅发送没有收到 ACK 的包

- 发送端为每个数据包都建立一个计时器；当某个包的计时器超时时，仅仅重传这一个包

![image-20250414081903584](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAO5aJcEumi65HSAhWbcB5V9SPJyIikAAu4ZAALIgblUbx4y_mYvSes2BA.png)

上图是 SR 协议的窗口样式。发送者和接收者的窗口大小都为 N。

发送端的窗口样式和 GBN 协议差不多，只是允许绿色（已经 ACK）和黄色（发送但未 ACK）乱序出现。send_base 指针指向第一个发送，但未被 ACK 的包。

接收端现在**存在缓存**，窗口通过 rcv_base 和 window_size 定义；rev_base 指针指向第一个**尚未收到的包**的位置。粉色内容为已经收到的乱序包，这些包需要被缓存，在其前方所有包都收到后再一起交给应用层。

### 发送端的工作

SR 协议中，发送端就只有三个工作：

- 应用层传输来数据后，需要**发送数据**

  如果发送窗口未满，那么直接封装数据为一个段然后发送，nextseqnum 右移一位

  如果窗口满了，设置一个“信号量”或者直接返回数据给应用层，告知自己窗口已满

- 收到接收端给出的 ACK(N) 后

  标记包 N 为已经收到，如果 N == send_base（N 是当前窗口编号最小的包），那么 send_base++，推进窗口向前一格

- 某个包传输超时时，重新传输

  此时仅仅重传计时器超时的包。当发送某个包或者重新发送时，重置这个包对应的计时器

### 接收端的工作

接收端收到数据包，且段在接收窗口内时：

- 发送 ACK(n) 消息确认接收
- 如果当前段顺序错误，那么暂时缓存此段，不做其他操作
- 如果收到顺序正确（n==rcv_base），那么向应用层传输此段和后续所有已收到且顺序正确的段，之后向右侧推进窗口一格（rcv_base++）

接收端收到数据包，但段在接收窗口左侧外部时：

- 此时说明这个包之前成功接受过一次，但 ACK 包被丢掉了；因此先舍弃此包（不然就给应用层重复数据了），再发送 ACK(n)，即使已经发送过 ACK(n) 包。

  重新发送 ACK 是因为前一个 ACK(n) 丢失了，发送端如果得不到响应的话，会一次次的重传这个包；因此需要再次返回 ACK(n)，让发送端不要再发了。

接收端收到数据包，但段在接收窗口右侧外部时：

一般情况下接收窗口是比发送窗口大且靠右的，不太会出现这种情况；此时忽略这个包就行，也不需要返回 ACK。

这种情况可能有两个原因：

- rcv_window < send_window，即接收窗口比发送窗口小
- 包序号是循环使用的，如果刚刚从最大值重置到 0，然后再收到了一个重复发送的，包序号为最大值的包，也会导致问题。这种情况下看似是在接收窗口右侧，实际上是在左侧（已经确认的包重复发送），按照上一种情况方法处理就行。

传输示例如下：

![image-20250414084111563](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAO6aJcEvpNZ0C7YQ5555jRvWx-oyGsAAu8ZAALIgblUVUHJ-Pab8_I2BA.png)

### SR 协议的困境（错误示例）

在包序号数量很小时，可能出现包序号相同，但包内容并不是期待的内容的问题。

![image-20250414084529313](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAO7aJcEwdpor8YSoAtAx09Tn0BOtDcAAvAZAALIgblUZF0B8RjJta02BA.png)

见图(a)，如果窗口大小为 3，发送端发送了 3 个包，接收端接收了三个包，但这三个包的 ACK 全部丢失；一段时间后，发送端重传 0 1 2 三个包，但是此时接收端会误认为包 0 是后续一轮的包 0，而非之前包 0 的重传。

为了解决此问题，要求**序号 > 2\*窗口大小**，即假设包序号长度为 k，那么需要满足 $2^k > 2\times N$。

## 3.4 TCP|Transmission Control Protocol 传输控制协议

据老师说，前面两个协议（GBN 和 SR）了解即可，从现在开始最好忘掉它们，免得和 TCP 协议混淆。

TCP 协议的内容必须掌握并记住。

### TCP 概述

<mark>**特点**</mark>

:one: 点对点：一个发送方，一个接收方(不能用于多播)

> UDP 支持点对多点（多播）通信，而 TCP 不支持。

:two: 可靠的、字节有序的流式发送数据：没有“报文边界”

> 虽然数据还是分多个段发送的，但各个段之间基本是连续发送的，所以说好像“没有边界”一样。

:three: 流水线式：TCP 拥塞和流量控制设置窗口大小

:four: 需要开辟发送和接收缓冲区

> 即发送端和接收端都需要开辟缓存。
>
> 接收端存在缓存，说明 TCP 协议和 SR 协议类似，都只会重传超时的单个包。

:five: 全双工数据 full duplex data：在同一连接中双向数据流，每端都可以发送/接收数据。(UDP也是)

MSS：最大段大小，为 **536 字节**，其中包含段头和数据部分。如果应用层扔了个几 MB 的数据给 TCP，TCP 协议就会把它拆成很多很多段依次发送。

> TCP 的段头为 20 字节，因此实际每个段最大数据承载量为 516 字节

<mark>三控一管</mark>：**连接管理、可靠性控制、流量控制、拥塞控制**

![image-20220403211900515](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAO8aJcE02w7VHaSX9HrhM0PLgG_hJYAAvEZAALIgblUijk9c1usA0o2BA.png)

上图中传输其实可以是双向的，不过只画了单向。

所谓的连接只是逻辑上的，发送方和接收方开辟缓存，设置变量，交换序列号

### 段文格式

仅从 TCP 报文段的首部是无法得知目的IP地址的。因此，TCP 必须告诉 IP 层此报文段要发送给哪一个目的主机（给出其IP地址）。**此目的 IP 地址填写在 IP 数据报（网络层）的首部**中。（而不是 TCP 层的段文中）。

段文中的段头字段可以说明此报文是 ACK 段文还是一般的数据段。

![image-20220315113207545](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPTaJcGLGbMkJMWC0E_G8wUlYP46JMAAgUaAALIgblUlN-lOM8iFzI2BA.png)

TCP 段头指的是前面五行，一共 <mark>**20 个字节**</mark>。因此，只有 **516 字节** 可以用于传输数据。

:one: 源端口号和目的端口号：各占 2B，共计 4B。

:two: **序列号**：TCP 是面向字节流的，传送时按照一个个字节传送，所以在一个 TCP 连接中传送的字节流需要编号，这样才能保证按序交付

> 例如，某报文段的序号从301开始，而携带的数据共有100B.这就表明本报文段数据的第一个字节的序号是301,最后一个字节的序号是400.显然，下一个报文段（如果还有）的数据序号应当从401开始，即下一个报文段的序号字段应为401,这个字段名也称为“报文段序号”。

序列号长度为 4B（32 位）

:three: **确认号** acknowledgement number：占4B。TCP是含有确认机制的，所以**接收端需要给发送端发送确认号**，这个确认号只需记住一点：若确认号等于N,则表明到序号N-1为止的所有数据都已经正确收到。

> 例如，B正确收到了A发送过来的一个报文段，其序号字段值是501,而数据长度是200B（序号501~700),这表明B正确收到了A发送的到序号700为止的数据。因此，**B期望收到A的下一个数据序号**是701,于是B将发送给A的确认报文段中的确认号设置为701.注意，现在的确认号不是501,也不是700,而是701.

确认号长度也为 4B（32 位）

:four: PSH 字段：这部分总共长度为 2B(16 位），用于存放一些标志位。

- Head Len：标头的长度，4 位。很可惜，目前网络上所有的 TCP 报文头部长度都是一摸一样的 20 位，因此这个字段其实一点用都没有。

- 保留字段：占 6 位。保留为今后使用，但目前应置为 0，该字段可以忽略不计。

- 紧急 URG:当 URG=1 时，表明紧急指针字段有效。它告诉接收端此报文段中有紧急数据，应尽快传送给应用层（相当于高优先级的数据）。

  其实也没有意义，从来都不用。谁家接收端收到数据段之后还会等等再给应用层吗）

- **确认比特 ACK**:只有当 ACK=1 时，确认号字段才有效；当 ACK=0 时，确认号无效。

  ACK=1 表示此段是一个 ACK 响应段（确认端）；ACK = 0 表示此段是一个传输数据的段

- 推送比特 PSH：TCP 收到推送比特置 1 的报文段，就尽快地交付给接收应用进程，而不再等到整个缓存都填满后再向上交付。

  和 URG 字段一样，没有任何人用。

- 下面三位都和**连接管理**有关

- 复位比特 RST：当 RST=1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。

  这个字段很少被使用，不过 GFW 非常喜欢用。

- 同步比特 SYN：同步比特 SYN 置为1,表示这是一个连接请求或连接接收报文（即三步握手中前两步发送的报文），后面的TCP连接会详细讲到。

- 终止比特 FIN：释放一个连接。当FIN=1时，表明此报文段的发送端的数据已发送完毕，并要求释放传输连接。

:five: **窗口字段**：占 2B。窗口字段用来控制对方发送的数据量，单位为字节（B).记住一句话：**窗口字段明确指出了现在允许对方发送的数据量**。例如，设 ACK 包的确认号是 701,窗口字段是 1000.这就表明，从 701 号开始算起，发送此报文段的一方还有接收 1000B 数据的接收缓存空间。

这个字段是有用的，在下面的“流量控制”模块中提到。

:six: 校验和字段：占 2B。校验和字段检验的范围包括首部和数据两部分。在计算校验和时，和 UDP 一样，只具有检查错误的功能，不具有校正错误的功能。实际上，多位错也可能导致校验和字段出现“伪正确”的情况。

这个字段也没有用处。和 UDP 一样，出现错误的数据段已经被网卡在网络层丢弃了，根本就不会传递给 TCP 层；所以 TCP 自己搓轮子实现一个校验其实没啥用。

:seven:  紧急指针字段：占 2B。从报文的开始到此指针指向的位置都会被视为紧急数据。当上方讲到的 URG 段为 1 时，就会使用此指针的内容。

和上方的 URG 段一样，现实中没有任何人用这个字段。所有的报文都被当作紧急报文处理。

---

分割线位置以上的内容就是段头的内容。

:eight: 选项字段：长度可变。TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP:“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 字节。”

很可惜，这个字段从 TCP 在网络上开始使用起，就从来都没人用过。MSS 全都是 536 字节。TCP 和 UDP 协议还真是屎山啊……

:nine: 填充字段：为了使整个首部长度是 4B 的整数倍。

后面就是 TCP 的数据内容了，最长 516 字节。

### 可靠性控制（重要）

即<mark>**丢包重传**</mark>

:one: **发送方**:

**重新发送丢失的片段**，未被正确接收前一直存在发送方的缓存区

需要开辟发送缓冲区（发送窗口）：开始指针：send_base（指向发送缓存的最左侧），窗口大小：n，下一个序列号：nextseqnum

> 当有数据需要发送时，检查 nextseqnum 是否有效，有效就将其封装成 TCP 的段发送，发送后将nextseqnum 右移，一直移动到 nextseqnum-send_base=N，此时窗口就满了，应用层再给数据就无法发送了。接收方确认数据收到，然后发送窗口右移。

![image-20220315114330990](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAO9aJcE40TS-P8eVrlZlK-SSQVTFDUAAvIZAALIgblUHgy3Jjw179s2BA.png)

:question: 如何知道段丢失了吗? 

> 接收方发送确认段序号
>
> 计时器时间到了还没收到确认信号就认为段丢了，重传

:question: 如何知道哪些部分丢失了? 序列号

确认机制采用累计确认：**接收到 ACK(n) 时，认为 n 前面的所有包都已经收到了**。

计时器采用**每个包对应一个计时器**，每个包分别计算超时时间。

:two: **接收方**:

<mark>对期望的那个段进行确认</mark>——返回的段序号是它**期待的那个段的段序号**。

> 这个可能比较奇怪：即使还没收到这个段，还是要发送期待的段的段序号。

需要开辟接收缓冲区：开始指针：rcv_base（指向的段序号就是接收方期待的段的段序号）以及窗口大小 N

![image-20220315115032358](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAO-aJcE86xMPz6x-rDa0au9TBqxb5YAAvMZAALIgblUkDhm5VYW4Kc2BA.png)

> 第一个灰色：rcv_base 指向的段序号就是接收方期待的段的段序号
>
> 紫红色：收到了这个段，没有差错，先缓存起来，但是不能送给应用层，如果送给应用层会乱序（不可靠），因为期待的那个段还没有到，到了一起送
>
> 第二个灰色：还没有收到，下一个期待的段
>
> 蓝色：空闲接收缓存

**示例**

初始序列号是**随机的**，并不是从 0 开始的。

后一个序列号=前一个段的序列号+前一个段的**数据域长度**

因此，TCP 序列号**不是连续的**

ACK：从另一端期望的下一个包的序列号。

![image-20220403223248634](https://telegraph-image-5ms.pages.dev/file/AgACAgUAAyEGAASIfjD1AAO_aJcE9wSESJsOIdZNXwU1oGRePg0AAmvMMRvIgblUzQyHICmTukcBAAMCAAN4AAM2BA.png)

> 上图中假设每次发送数据的数据域长度都是 1，即只包含图中的单个字母。

#### 算法表示

##### 发送端

发送端简化后的有限状态机如下：假设当前为单向数据传输；无流量，拥塞控制

只有一个状态：等待。当一个事件发生时，进行处理，然后状态继续迁移到等待。

四个事件会触发处理：

- 应用层有数据要传输
- 有发送的段超时
- 收到接收端的 ACK
- 收到三个一样的 ACK（快速重传）

![image-20220403231614360](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPAaJcFCqnHEEcR8B5dM2CUyQABTM_rAAL0GQACyIG5VPq9umczjGDqNgQ.png)

> 一定要记住，发送数据和重传时都需要**启动/重启计时器**。==大概会考==。
>
> ==说不定会考察让你画状态机==
>
> 记住在一个段序号为 y 的段计时器超时时，需要**重新计算计时器的超时间隔**。计算方法下面再说
>
> 收到三个相同 ACK 段的原因如下：接收端期待收到的段一直没有收到；但是期待段之后的两个段、前面的一个段都快速到达了，因此接收了三个相同的 ACK（值都是期待收到但一直没到的段）。
>
> 此时，接收端前面的段收到了（否则 ACK 值就不是这个段了而是前一个），后面的两个段也到了，那么这个端大概率就丢失了。发送端进行快速重传。
>
> 这里称为快速重传，是因为发送端在计时器超时之前就重传了。此时由于没有超时，不需要重新计算计时器的超时间隔。
>
> 收到确认号 y 时，窗口右移（认为前方的包都收到了），然后停止所有前方包的定时器。

快速重传功能是对 SR 协议的改进。

**快速重传**的解释如下：代表了轻度拥塞，超时是重度拥塞

![image-20220403230636835](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPBaJcFHN7UNIQ37tmN9UfJdKNNxXYAAvUZAALIgblUS8h0rFBLRWU2BA.png)

上图中虽然是收到了四个 ACK，不过实际上从收到第三个 ACK 开始就要求重传了。

收到三个 ACK 的时候，其实代表前一个段/后两个段都已经被接收了，总共三个段

<mark>**伪代码表示如下**</mark>

```c
/*发送端可靠性控制伪代码，要记住*/
/*假设发送方不受TCP流量和拥塞限制，来自上层数据的长度小于MSS，且数据传输只在一个方向进行*/
send_base = init_sequence number
nextseqnum = init_sequence number
loop(永远){
	switch(事件)
	事件:应用层有数据让TCP传输
        // 窗口大小没有到达上限
		if(nextseqnum-send_base<N){
			创建段序号为nextseqnum的段
			启动计时器
			将段发给IP层
			nextseqnum = nextseqnum +数据长度/*段序号是跳跃式的，下一个段序号=当前序号+当前报文长度*/
		}else{
			拒绝发送段
		}
	事件:段序号为y的段的计时器超时
        重传这个段y
        // 超时间隔应当根据网络的繁忙程度计算：网络越繁忙，超时时间应当越长。
		重新计算计时器超时间隔
		重启计时器
	事件:接收到ACK，字段值为y
        if(y>send_base){/*段在发送窗口内*/
            取消掉段y之前所有的段的计时器
            send_base = y/*窗口右移*/
        }else if (y==send_base){/*这里指的是y=send_base，接收端还没有收到y，但是在接收 y 后面的内容*/
          // y > send_base 是正常情况，因为 ACK 响应的是期待的段，你窗口最前端发送y=1、长度1的段，对方就会返回ACK=2。
          // y==send_base 才是不正常的，假如你发送了y=1，长度=1的字段，但对面在返回ACK=1，那么说明对方没接收到这段，不然就返回ACK=2了
          // y是不太可能小于send_base的，因为对面会一直返回期待的段的ACK。
            对ACK字段为y的计数器+1
          // 计数器值=3才重传可能是为了一定程度上容忍乱序
          // 乱序到达三个包才会导致对方发送三个相同 ACK，引发此包重传。乱序 1 个包只会返回一个 y==send_base的ACK，问题不大
            if(计数器的值==3){
                快速重传段y
                重启段y的计时器
                段 y 计数器的值清零
            }
        } else { // y<send_base，这种情况很罕见但是可能出现
            丢掉包，什么都不做
        }
}
```

##### 接收端

![image-20220315115032358](https://telegraph-image-5ms.pages.dev/file/AgACAgUAAyEGAASIfjD1AAPCaJcFHmyf_1t6DOIQaV_fiqQAAdQkAAJszDEbyIG5VE-dFHrCcvNxAQADAgADbQADNgQ.png)

> 第一个灰色：rcv_base指向的段序号就是接收方期待的段的段序号
>
> 紫红色：收到了乱序的段，没有差错，先缓存起来，但是不能送给应用层，如果送给应用层会乱序（不可靠），因为期待的那个段还没有到，到了一起送
>
> 第二个灰色：还没有收到，下一个期待的段
>
> 蓝色：空闲接收缓存

产生**ACK**

![image-20220315115032358](https://telegraph-image-5ms.pages.dev/file/AgACAgUAAyEGAASIfjD1AAPCaJcFHmyf_1t6DOIQaV_fiqQAAdQkAAJszDEbyIG5VE-dFHrCcvNxAQADAgADbQADNgQ.png)

| 编号 | 事件                                                         | TCP接收端动作                                                |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ①    | 有序的一个段到达，中间没有间隙，所有的其他段都被确认过了     | 做一个延迟，等待下一个段500ms，如果下一个段到来了一起确认，没有到来的话发送ACK |
| ②    | 有序到达一个段，中间没有间隙，有一个ACK在做延时              | 不能再做延时，立即发送一个ACK以确认两个有序段                |
|      |                                                              | 1 和 2 两种情况说明：最多积攒两个段一起发送 ACK。不能攒更多的 ACK 一起发送。 |
| ③    | 比期望序号大的报文段乱序到达（如紫红色部分）                 | 立即发送一个ACK，ACK为期待的段的段序号（rcv_base指向的段的段序号）而非当前接收到段的序号 |
| ④    | 到达一个段，这个段部分或全部的填满了间隔（即此段后面的段已被乱序接收） | 若该报文段起始点在低端，则立即发送ACK<br />如果是rcv_base指向的段（左边灰色的），则这个段变为红色，连同身后红色的段一起送给应用层，接收窗口右移到下一个期待的段（右边灰色的）；否则（图中右边灰色的），则这个段变为紫红色，返回一个ACK，ACK为期待的段的段序号（rcv_base指向的段的段序号）<br /><br />总之要补齐gap |
| ⑤    | 如果收到一个段位于窗口左侧                                   | <mark>将其丢弃（这种情况是老师上课补充的）</mark>，**也不发送 ACK**。 |

**举例分析如下**

![](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPEaJcFMpui-W26aEQH1P8B99HWPGcAAvYZAALIgblUUie_WrBS2bs2BA.png)

上图为一些常见出错的处理方法。第二张图含义是这样的：第一个包的 ACK 在到达前超时了，因此发送端重发了第一个包；接收端接收到多余的包之后返回 ACK，但不做其他操作。

全双工通信的话发送端和接收端都放一份上面的两种可靠性算法

### 流量控制 Flow Control

前面讲过，一条 TCP 连接的每一侧主机都为该连接设置了接收缓存。当该 TCP 连接收到正确、按序的字节后，它就将之前重传丢失的报文段放入接收缓存。相关联的应用进程会从该缓存中读取数据，但不必是数据刚一到达就立即读取。

事实上，接收方应用也许正忙于其他任务，甚至要过很长时间后才去读取该数据。如果某应用程序读取数据时相对缓慢，而发送方发送得太多、太快，发送的数据就会很容易地使该连接的接收缓存溢出。

> 接收端缓存溢出之后，溢出的内容就相当于白白传输了，还是要重新接受；因此，TCP 实现了流量控制，以能保证接收端缓存不会太大。

**TCP 为它的应用程序提供了流量控制服务，以消除发送方使接收方缓存溢出的可能性。流量控制是一个速度匹配服务，即发送方的发送速率和接收方应用程序的读取速率相匹配。**

TCP 通过让发送方维护一个称为**接收窗口 receive window（rwnd） **的变量来提供流量控制，接收窗口用于给发送方一个指示——**接收方还有多少可用的缓存空间**。接收缓存中的空闲空间。

![image-20220404100443212](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPFaJcFQRJtKB5gfBjWKuMOhrCrgxYAAvcZAALIgblUdB08vWHh-Pg2BA.png)

**TCP 段头中有一个字段表示接收窗口的大小。**此外，每个段的长度应当不大于 spare room 的大小（剩余的发送窗口大小）

假设主机 A 通过一条 TCP 连接向主机 B 发送一个大文件，主机 B 为该连接分配了一个接收缓存，并用 RcvBuffer 来表示其总大小，主机 B 上的应用进程不时地从该缓存中读取数据，有如下变量定义

> LastByteRead：主机B上的应用进程从缓存读出的数据流的最后一个字节的编号。（被读走的最后一个段序号）
>
> LastByteRcvd：从网络中到达的并且已放入主机B接收缓存中的数据流的最后一个字节的编号。（刚收到的段的段序号）

由于 TCP 不允许已分配的缓存溢出，下式必须成立：
$$
LastByteRcvd-LastByteRead≤RcvBuffer
$$
即已经位于缓存中，但尚未被应用层取走的数据的大小不能大于  RcvBuffer（缓冲区的大小）

接收窗口(空闲缓存)用RcvWindow（rwnd）表示，即**接收端缓存的剩余容量**：
$$
RcvWindow = RcvBuffer - [ LastByteRcvd - LastByteRead]
$$
主机 B 通过把**当前的RcvWindow值放入它发给主机 A 的报文段接收窗口字段**中，通知主机 A 它在该连接的缓存中还有多少可用空间。开始时，主机B设定 RcvWindow = RcvBuffer。

主机 A 轮流跟踪两个变量，LastByteSent 和 LastByteAcked，这两个变量的意义很明显。注意到这两个变量之间的差LastByteSent - LastByteAcked，就是**主机A发送到连接中但未被确认的数据量**。通过将未确认的数据量控制在值 rwnd 以内，就可以保证主机 A 不会使主机B的接收缓存溢出。因此，==发送端==在该连接的整个生命周期须<mark>**保证**</mark>：
$$
LastByteSent-LastByteAcked≤rwnd
$$
对于这个方案还存在一个小小的技术问题。为了理解这一点，假设主机 B 的接收缓存已经存满，使得 rwnd=0。在将 rwnd=0 通告给主机A之后，A 就不会向 B 发送内容了，B 因此也不会返回 ACK 包了。事实上，**TCP 仅当在它有数据或有确认要发时才会发送报文段给主机 A**。这样，主机 A 不可能知道主机 B 的接收缓存已经有新的空间了，即使主机 B 的缓存有空间了，A 也不知道。为了解决这个问题，TCP 规范中要求：**当主机 B 的接收窗口为 0 时，主机A继续发送只有一个字节数据的报文段**。接收方需要返回这些报文的 ACK 响应。**最终接收端缓存会腾出空间，此时返回的 ACK 报文里将包含一个非 0 的 rwnd 值**。

#### TCP 往返时间(RTT)和超时

TCP 连接的发送端在某段超时时有一个操作：重新计算超时间隔；那怎么计算呢？就是按照下方讲的内容来算

如何设置 TCP 超时时间间隔：**略大于一个 RTT**。

如果超时间隔太小：会导致频繁的重传。很多情况下其实接收端能够收到消息，但发送端超时就直接重传了

如果超时间隔太大：重传频率降低，但万一真的丢包了，那么需要更长的时间才会触发重传；在此之前，发送/接收端都会由于窗口大小限制被卡住，无法往下进行。

可以预测 RTT：

> SampleRTT（实际测量的RTT)：从段从发送端发送到 ACK 被发送端接收的时间。
>
> 假设段没有经过超时重传，且接收端接收后立刻发送 ACK 。
>
> SampleRTT 会因路由器拥塞和终端系统负载变化而变化，因此，我们希望估计的RTT“更平稳”，即求一个加权平均：

$$
EstimatedRTT_n = (1- \alpha)*EstimatedRTT_{n-1} + \alpha *SampleRTT
$$

> 即根据上一个预测的 RTT 和当前实际测量的 RTT，通过加权计算出当前预测的 RTT。

Exponential weighted moving average 指数加权运动平均；**给定样本的影响以指数速度递减**；α的典型值为0.125(右移三位，速度更快)

指数是指上一次预测值占比 0.875，上两次占比 0.875\*0.875，上三次占比 0.875\*0.875\*0.875...

moving 是指每次计算时都是用了上一次估计的 RTT，但是没有再用上两次了，相当于“参考窗口在滑动”一样。

![image-20220317173518154](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPUaJcGOy7q6GDy1Fznx6iTSClaeyIAAgYaAALIgblUIj-UNT75KrA2BA.png)

自适应超时时间设置：EstimtedRTT加上“安全margin”（Deviation）

$$
Timeout = EstimatedRTT + 4*Deviation\\
$$
其中，$Deviation_n = (1- \beta)*Deviation_{n-1}+\beta *|SampleRTT-EstimatedRTT|$

代入公式，可以得到：
$$
Timeout=(1-\alpha)EstimateRTT_{n-1}+\alpha SampleRTT+4*((1-\beta)Deviation_{n-1}+\beta |SamplaRTT-EstimateRTT_n|)
$$


β通常取 0.25；取 0.25 的好处就是乘法相当于右移两位，计算很快。

这个公式也可以用于预测接收窗口 rwnd 的大小。

实际当中，TCP 的流量控制并不常触发，因为只有接收端开始丢包（缓冲区即将占满）时才会开始流量控制。

### TCP 连接管理(重要)

<mark>连接的开启：三个握手</mark>

三次握手是为了交换初识序列号、开辟缓存等内容。

:one: 发送端(客户端)给接收端(服务器端)发送一个 SYN 段(在 TCP 标头中 SYN 位字段为 **1** 的 TCP/IP 数据包), 该段中也包含客户端的初始序列号(序列号Sequence number = J)。

> 同步比特 SYN:同步比特 SYN 置为1,表示这是一个连接请求或连接接收报文

:two: 接收端返回给发送端 SYN +ACK 段(在 TCP 标头中 SYN 和 ACK 位字段都为 1 的 TCP/IP 数据包)， 该段中包含接收端的初始序列号(序列号 = K)；同时使确认号Acknowledgement number = J + 1来表示确认已收到客户端的 SYN段(序列号 = J)。

> 第二次握手，接收端开辟缓存

:three: 发送端给接收端响应一个 ACK 段(在 TCP 标头中 ACK 位字段为 **1** 的 TCP/IP 数据包), 该段中使 确认号 = K + 1来表示确认已收到服务器的 SYN 段(序列号 = K)。

> 第三次握手，发送端开辟缓存

注意：

1. 三路握手中，发送端和接收端的发送包的序列号不同。发送 ACK 应答时，需要对对方的序列号做 ACK 应答。
2. 所有发送的包数据域长度都为 1（因此 ACK 都等于对方包的序列号 +1）
3. 第三次握手时发送端发送的包的 SYN = 0 而非 1。

![image-20220404103932103](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPGaJcFUrSCDFf8TxTDba8stS4wztUAAvgZAALIgblU_DIfuCNzX_k2BA.png)

一旦完成这三个步骤，客户和服务器主机就可以互相发送包括数据的报文段了。

**完成三次握手后，连接称为全连接；仅完成前两次握手时，称为半连接**。

**DoS 攻击**：半连接攻击(客户端永远不做第三个握手，没完没了发送连接请求，使服务器端不断开辟缓存，使服务器崩溃)

> DoS (Deny of Service，拒绝服务攻击），即由于服务器资源被耗尽，无法服务正常请求的客户端的问题。
>
> 很多台客户端对同一服务器发动的攻击叫 DDos（Distributed Deny of Service，分布式拒绝服务攻击）

<mark>连接的关闭：两次握手</mark>（四次挥手）

:one:客户端系统向服务器发送 TCP FIN 控制段

> 终止比特 FIN:释放一个连接。当 FIN=1 时，表明此报文段的发送端的数据已发送完毕，并要求释放传输连接。

:two:服务器接收到 FIN，返回 ACK。之后，服务器关闭连接，同样发送 FIN。

:three:客户端收到 FIN，以 ACK 回应。计时器定时等待

:four:服务器，接收 ACK，之后连接关闭，可以立刻释放资源

客户端在 timed wait （计时器超时，一般 30 秒）后才能真正关闭本侧连接，释放缓存。

> ![image-20220404103944641](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPHaJcFYl4zVxeL-GCYYOOUMf3jnyMAAvkZAALIgblUvtpEgSoVofM2BA.png)

### 拥塞控制 Congestion Control

拥塞指的是路由器拥塞：有太多的发送端发送数据，发的太快，导致路由器的缓冲区无法承受。

表现：丢包(路由器缓冲区溢出)；长延迟(在路由器缓冲区中排队)

#### 拥塞原因与代价（了解即可）

##### 情况一：两个发送端和一台无限大缓存路由器

![image-20220404105749800](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPIaJcFclfiRAuXqzu2ZlQhaDwsV3QAAvoZAALIgblU0pcDIv3ftxQ2BA.png)

$\lambda_{in}$：主机 A 和 B 中的应用程序以 $\lambda_{in}$ 字节/秒的平均速率将数据发送到连接中

来自主机 A 和主机 B 的包通过一台路由器，在一段容量为 R 的共享式输出链路上传输，路由器缓存无限大说明不会丢包。当两个包的发送速度大于路由器的交换能力时 $2\lambda_{in}>R$，就会产生拥塞。

![image-20220404110616504](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPJaJcFg4R-D0giM_PCWSTRDzjsY1gAAvsZAALIgblUnQpHUshIYEg2BA.png)

##### 情况二：两个发送端和一台有限缓存路由器

![image-20220404110627904](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPKaJcFk0ymFMQu0LOkoOx5ekEj5sUAAvwZAALIgblUMx1OJN3VoEo2BA.png)

此时，路由器的缓存是有限的，也符合实际情况，当包到达一个已满的缓存时会被丢弃，从而被发送端重传。

> 无限缓存的路由器不会丢包，即使拥塞也只会导致传输延迟。

$\lambda_{in}$：表示应用程序将初始数据发送到套接字中的速率

$\lambda_{in}’$：表示传输层向网络中发送报文段（**含有初始数据和重传数据**）的速率，也称为网络的供给载荷（offered load）

:one: $\lambda_{in}$ 较小时，$\lambda_{in}=\lambda_{out}$；当没有丢包时，$\lambda_{in}'=\lambda_{in}$

:two: 出现丢包重传，$\lambda_{in}'>\lambda_{out}（$$\lambda_{out}$ 只计算有效数据，即不计算丢包重传的内容，因此没有增大；而 $\lambda_{in}'$ 由于重传包增多而增大。

:three: 延时较大，会进行不必要的重传，实际有效资源只用到了一半（被垃圾包占用了）

![image-20220404111603005](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPLaJcFpMQ_FffL02YhOMaG23qztnMAAv0ZAALIgblUkDlx7ux6i7c2BA.png)

##### 情况三：4 个发送方和具有有限缓存的多台路由器以及多跳路径

![image-20220404111805019](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPMaJcFtiip9Aw3KNcvrRUDW8VWiyEAAv4ZAALIgblUmAWZ4i5h7KQ2BA.png)

对角间发送/接收包。无论在哪一个路由器丢包，都会造成资源浪费。

![image-20220404111954514](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPNaJcFyLAnZE1N0mY9B1BVZb4NWQMAAv8ZAALIgblUuZEuS8VsjrU2BA.png)

随着 $\lambda_{in}'$ 的增加（丢包重传的增多），真正传输数据的速率越来越低。

#### 拥塞控制方法分类

:one: **ATM 网络的拥塞控制**

ATM([异步传输模式](https://baike.baidu.com/item/异步传输模式/511955))的内核设备不叫路由器，叫 ATM 交换机（胖内核，瘦端系统，内核功能强大），由于胖内核功能较多，拥塞以后通知发送端——**网络帮助的拥塞控制**。有两种通知方法：

> 交换机反馈一个特殊包给发送端
>
> 交换机通知给接收端，接收端再通知发送端（用的更多）
>
> 注意 ATM 的包大小是固定的，为 53 字节；包大小较小是因为 ATM 网络主要用于实时语音通信，如果包太大的话延迟就会有点大。

:two: **因特网的拥塞控制**

因特网是瘦内核，胖端系统的网络，端系统功能强大（如DNS就放在端系统），路由器的功能尽量简单，拥塞了不通知发送端，靠端系统自行感知。

> 超时了说明网络重度拥塞（端到端的延时跟距离有关）
>
> 收到三个相同ACK（丢包）说明网络轻度拥塞——通常采用此方法

#### ATM的拥塞控制(过时了，了解即可)

ATM提供的四种业务：ABR、UBR、CBR、VBR

> :one: CBR :  Constant  Bit  Rate 主要用于实时语音通信; 保证一个固定的带宽，不会丢包,不需要拥塞控制.
>
> :two: VBR :  Variable  Bit  Rate 保证峰值带宽，不会丢包，不需要拥塞控制.
>
> :three:**ABR**:  Available  Bit  Rate 有效位率服务,主要用于视频服务; 可以保证一个最小带宽，不限制带宽上限，可能丢包，需要拥塞控制
>
> :four: UBR :  Unspecified  Bit  Rate 使用时有资源则使用,无资源则丢包,免费使用,无拥塞控制，用于视频通信

从上到下，网络质量依次从好到差。**只有 ABR 服务有拥塞控制**。

ATM 的通信数据单元称为信元( Cell )。信元大小为固定的 53 个字节。

> 头是5个字节（存访拥塞指示信息），数据域是48个字节
>
> 分为两种：
>
> :one: data cells:数据信元
>
> :two: RM (resource management) cells 资源管理信元：存访拥塞信息，通常每几十个数据信元放一个资源管理信元
>
> RM 信元用于存储是否存在拥塞等信息。
>
> ![image-20220404115003545](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPOaJcF2PIMek40SUvwMSsn3aAcLkcAAxoAAsiBuVQpp7BZ4Y82uTYE.png)

ATM 网络针对 ABR 的拥塞控制方法有三种

> :one: **CI 和 NI bits**
>
> CI  bit :  Congestion  Indication 指示拥塞是否出现。ATM 信元头中有一位即为CI 位,当发生拥塞时将 CI 位置1。发送端在接收到 CI 位置1 的信息后将会降低发送速率。
> NI  bit :  No  Increasein rate 告诉发送端不要再增加发送速率。代表网络即将进入拥塞或已发生轻度拥塞。
>
> 每 32 个信元中插入一个资源管理信元,交换机对资源管理信元中的 CI 与 NI 位进行置位,发送端根据这两位进行速率控制。
>
> :two: ER  Setting  (Explicit  Rate  Setting),明确速率设置
>
> 交换机根据可用带宽，设置资源管理信元的 EI 字段，告诉发送端可以多大速率发送数据.如果**经过多个交换机，EI 会取其中的最小值**。
>
> 这样可以保证发送端的发送速率小于最慢的交换机转发速度（瓶颈）
>
> :three: EFCI(Explicit  Forward  Congestion  Indication)明确转发拥塞指示
>
> 不发资源管理信元了！现在数据信元中的有一个位 EFCI，数据信元通过交换机时，如果拥塞则置此位为 1。

> 接收端通过统计 EFCI 位被置 1 的频率，和阈值比较即可看出过程中是否出现拥塞，如果出现则发送资源管理信元要求发送端降低发送速率。

#### TCP 拥塞控制（重要）

对于 TCP 中的拥塞，一共有两种判断

> 超时了说明网络重度拥塞（端到端的延时跟距离有关），即通过 RTT 的变化判断是否拥塞
>
> 收到三个相同 ACK（丢包）说明网络轻度拥塞——通常采用此方法

TCP 判断拥塞的方法其实就是检查是否发生了丢包。

**探测拥塞**

> 为了探测网络是否拥塞,   先发一个段探测一下,   如果这个段的确认信息正确返回，则没有问题； 下一个 RTT 开始时发送两个段,   如果还没有问题,   下一个 RTT 开始时发送四个段, ……，每个 RTT 发送窗口以2的倍数增加，经过若干次探测之后,  此时还没丢包，发送窗口不能再x2（否则会变的太大，可能导致拥塞）, 每个 RTT 开始时窗口大小 +1 （慢慢地增加，而不再快速增加）

发送窗口以 2 的倍数增加的过程叫**慢启动**,  经过若干 RTT 后 +1 过程叫做**拥塞避免**，这两个结合起来就是 TCP 的拥塞算法。

拥塞控制本质上控制的是发送端的发送窗口大小。

**算法中的重要变量**

> :one: 从慢启动到拥塞避免的分界线（RTT 增加速度的变化）用一个变量 threshold（阈值）表示
>
> :two: Congwin：拥塞窗口大小（拥塞控制时使用的发送窗口）

##### TCP慢启动

慢启动算法伪代码表示

```c
初始化：threshold=适当的值(10、20...不要太大)
初始化：Congwin=1
for(每个确认段)
	Congwin++ // 就是指 RTT 窗口二倍二倍的增加
until(丢包orCongWin>=threshold)
```

> :computer: 这里是说每收到一个对新的报文段的确认后，拥塞窗口就*2，第一轮收到1个确认，第二轮2个，第三轮4个，以此类推，按轮次加倍
>
> ![image-20220404121251789](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPPaJcF6t1jNDGTvKuFBr5MHmq47WcAAgEaAALIgblUVH2UwrJTmrI2BA.png)

##### TCP 拥塞避免

**Tahoe 拥塞避免算法伪代码**

```c
/*慢启动（*2 级别增加）结束*/
while (没有丢包) {
  每w个段被确认: // w 为拥塞窗口的大小
      Congwin++/*每确认 w 个包，RTT+1*/
}/*线性增加*/
/*丢包了*/
threshold = Congwin/2
Congwin = 1
// 丢包时，发送阈值降低为当前窗口 RTT 的一半（注意不是之前阈值的一半）
// 重置当前窗口为 1 并重进行慢启动
```

![image-20220404121844273](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPQaJcF-qCrMJbjekx_MgbW1ka3j-4AAgIaAALIgblU_jevoqmvK942BA.png)

轻度拥塞也会时发送窗口变为 1，显得不太合理。一旦发送窗口由于丢包降下来，就需要很长时间再升回去，就像十米高台跳水一样的波动。

**Reno 拥塞避免算法伪代码**

```java
/*慢启动（*2级别增加）结束*/
while (没有丢包) {
  每w个段被确认:
      Congwin++/*每个RTT，窗口+1*/
}/*线性增加*/
/*丢包了*/
threshold = Congwin/2
if(因为超时丢包){/*重度拥塞*/
    Congwin = 1
	进行慢启动/*回到慢启动*/
}
if(因为收到三个相同确认段丢包){/*轻度拥塞*/
    Congwin = Congwin /2 /*将窗口大小减半，回到while，不需要再次慢启动*/
}/*快速恢复*/
```

![image-20220404124733928](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPRaJcGC05Ro2fQNVFcyUhCcNYSQFAAAgMaAALIgblU10HuGc0ELOM2BA.png)

问题：如果又收到三个相同的确认段，此时应该再减半；如果在快速恢复状态下又出现了真正的丢包，那么就需要返回慢启动状态。

**两个算法的比较**

![](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPSaJcGHAABHI9UFhVHmDHauF4XhUSGAAIEGgACyIG5VCMUbAY34MeWNgQ.png)

Reno 算法的吞吐率更高，震荡率更小。

**发送端的窗口大小同时受流量控制（接收端缓存大小）和拥塞控制（丢包频率）影响**。一般我们取二者限制中最小的作为发送窗口。

##### 拥塞控制中的吞吐率

设 W 是丢包时的窗口大小（以段为单位）

> 当窗口大小是 W，吞吐率=$W/RTT$
>
> 当发生了丢包，窗口大小减少为W/2，吞吐率=$W/2RTT$
>
> 平均窗口大小为(W+W/2)/2=0.75W，平均吞吐率=$0.75W/RTT$
>
> yysy，这算的真是够粗略的）

如果知道丢包率 L，MSS 为最大段大小(可要可不要），平均吞吐率为
$$
\approx \frac{1.22MSS}{RTT\sqrt{L}}
$$

> 此公式的单位为“字节/秒”。我们可以删除分子的 MSS，不过这样得到的吞吐率单位就是“段/秒”了。

推导过程如下：

> 在拥塞避免期间，发送窗口大小从w/2变化到w(段)
>
> 第一个RTT，窗口大小=w/2
>
> 第二个RTT，窗口大小=w/2+1
>
> 第三个RTT，窗口大小=w/2+2
>
> ……
>
> 当丢包时，窗口大小=w/2+w/2=w
>
> 在此期间发送的段的总数(包数)：
>
> 一共发送了 $\dfrac{w}{2}+1$ 个段，每个段一般大小为 $\dfrac{w}{2}$，再加上 +1, +2, ..., +$\dfrac{w}{2}$ 的后缀。
> $$
> \frac{w}{2}(\frac{w}{2}+1)+(1+2+,...+\frac{w}{2})=\frac{3w^2}{8}+\frac{3w}{4}\approx \frac{3w^2}{8}
> $$
> 总共丢了一个包，丢包率为 1/(3w2/8)=
> $$
> L=\frac{8}{3w^2}\Rightarrow w=\sqrt{\frac{8}{3L}}
> $$
> 平均吞吐率则为（上面求过）
> $$
> \frac{3}{4}w/RTT=\frac{3}{4RTT}\sqrt{\frac{8}{3L}}\approx \frac{1.22MSS}{RTT\sqrt{L}}
> $$

##### 算法总结

TCP 拥塞避免算法：AIMD：additive increase, multiplicative decrease

> 线性增加，指数减少
>
> 每一个 RTT 增加一次窗口；每次丢包减少为原来窗口大小的1/2

<mark>这个算法具有四个特性</mark>（也称为 TCP 的四个特性）

> :one: 有效性：Effectiveness，总之就是说算法是正确的，有用的，不证明了
>
> :two: 收敛性：窗口大小锯齿性震荡，不过震荡会越来越小
>
> :three: 公正性：Fairness
>
> > 如果 N 个 TCP 会话共享同一条瓶颈链路，则经过一段时间的调整后，每个会话的链路容量都会调整为 1/N
> >
> > 如果一个用户建立了 N 个 TCP 连接，那么他的总带宽就是只使用一个链接的用户的 N 倍，这是不公平的。
>
> :four: 友好性：Friendliness
>
> > 如果 TCP 和 UDP 用户共同使用带宽。如果两者发送数据的速度>R(路由器最大交换能力)，TCP就会将发送速率减半，腾出资源给 UDP，最终 TCP 只能发送一个段，资源几乎都给了 UDP。
> >
> > 因此 TCP 和 UDP 同时占用带宽时，二者的带宽是不公平的。