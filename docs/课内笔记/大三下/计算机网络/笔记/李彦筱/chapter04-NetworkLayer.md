# 第四章——网络层

> 易俊泉学长的原始笔记链接如下：
>
> [第四章——网络层](https://github.com/yijunquan-afk/XJTUSE-NOTES/blob/master/大三下/计算机网络/chapter04%20NetworkLayer/chapter04-NetworkLayer.md)

网络层实现了**主机到主机的通信服务**，与传输层和应用层不同的是：在网络中的每一台主机和路由器都有一个网络层部分。（路由器不存在传输层与应用层）网络层是协议栈中最复杂的层次。

> 因此，网络层的数据报不包含端口号，因为网络层根本不关心要把消息传递到目标主机的哪个程序上。这是传输层该关心的问题（因此两个传输层协议，TCP 和 UDP 段头中都有端口号）

网络层提供的传输服务是不可靠的，它直接发送传输层塞过来的包，而不做任何可靠性控制。

> 回忆：传输层提供的是**进程到进程的通信服务**，会将消息送给主机上的对应程序。

## 4.1 网络层概述

### 4.1.1 网络互连

世界上有数以百万计的网络，要实现这些网络的互连是一件相当困难的事情，因为这些网络并没有统一的标准。而让大家都使用同一个网络也是不可能的，因为用户的需求是多种多样的，不可能有一种单一的网络能够适应所有用户。虽然网络不可能一样，但是可以想办法**使用一种协议让路由器连接的网络都遵守这种协议**，在这种情况下可以将互连起来的网络看成一个虚拟互联网络。

**虚拟互联网络也就是逻辑互联网络**，它的意思就是互连起来的各种物理网络的异构性本来是客观存在的，但是可以利用协议使这些性能各异的网络让用户看起来好像是一个统一的网络，。这种协议就是网络层重点讨论的IP。

将网络互连起来肯定需要一些中间设备(又称为中间系统或中继系统)，根据中继系统所在的层次，可以有以下4种不同的中继系统。

> 1)物理层的中继系统:中继器或集线器。
>
> 2)数据链路层的中继系统:网桥或交换机。
>
> 3)网络层的中继系统:路由器。
>
> 4)网络层以上的中继系统:网关。

当中继系统是中继器或网桥时，一般并不称之为网络互连，因为这仅仅是把一个网络扩大了，仍然是一个网络。<mark>互联网都是指用路由器进行互连的网络。</mark>

但是要注意，IP 数据报的首部中有一个“首部检验和”字段。路由器在转发数据报时，会重新计算首部校验和。如果发现校验和不匹配，说明数据报首部在传输中出现了差错，路由器会丢弃该数据报。因此，凡是能够成功交付给目的主机的IP数据报，其首部都是没有检测出差错的。

### 4.1.2 网络层的两个核心功能

网络层的作用是将分组（包）从一台发送主机移动到一台接收主机，为此需要两种重要的网络层功能：**路由选择**(确定哪一条路径)与**分组转发**(当一个分组到达时所采用的动作)，这也是路由器的主要功能

根据所需性能要求，可以采用适当的路由算法来构造路由表进行路由选择。不仅如此，该路由表还会根据从各相邻路由器所得到的关于整个网络的拓扑变化情况，动态地改变所选择的路由，以便得到最佳路由。

> :one:**路由选择: 是指确定分组从源到目的地所采取的端到端路径的网络范围处理过程。路由选择发生的时间尺度长得多（通常为几秒），因此通常用软件来实现**。如果子网内部使用数据报，那么对每一个进来的分组都要重新选择路径。如果子网内部使用虚电路，那么只有当创建一个新的虚电路时，才需要确定路由路径。
>
> :two: **分组转发：是指将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作。转发发生的时间尺度很短（通常为几纳秒），因此通常用硬件来实现。——路由器的核心功能**

:label: 用驾驶的例子进行类比，考虑旅行者所历经的从宾夕法尼亚州到佛罗里达州的行程。在这个行程中，那位驾驶员在到佛罗里达州的途中经过许多立交桥。我们能够认为**转发就像通过单个立交桥的过程**：一辆汽车从其道路上进入立交桥的个入口，并且决定应当走哪条路来离开该立交桥。我们可以把**路由选择看作是规划从宾夕法尼亚州到佛罗里达州行程的过程**：在着手行程之前，驾驶员已经查阅了地图并在许多可行的路径中选择一条，其中每条路径都由一系列经立交桥连接的路段组成。

:label: 路由表是**根据路由选择算法**得出的，而转发表是从路由表得出的。转发表的结构应当使查找过程最优化，路由表则需要对网络拓扑变化的计算最优化。在讨论路由选择的原理时，往往不去区分转发表和路由表，而是笼统地使用路由表这一名词。

### 4.1.3 连接建立

某些网络架构中（如 ATM 网络架构）的第三个重要功能——连接建立

在数据报流动之前，两端主机和中间路由器建立虚拟连接：路由器参与，仅在 ATM 网络中存在：

> 通过拨号建立逻辑上的连接，中间的交换设备参与连接建立，维护一些中间信息：有多少连接，带宽资源是多少。当一些数据包到达交换设备时方便直接转发。排队时间短。
>
> 也不会出现乱序的问题：路径固定

对于网络层来看，传输层的协议（TCP/UDP）是透明的。网络层只管在两台主机之间发送包，而不管包内容的含义和是否丢包。

### 4.1.4 网络层服务模型

![image-20220413103043536](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPVaJjDUoEvNr5akhhjUGY2JEcdwg4AAloWAALyaslUzUPMT2nrGGo2BA.png)

IP 网络不能保证上面四个质量中的任何一个，它保证不了带宽一定、不丢包，按序到达、实时性、安全性中的任何一个。

CBR 网络：保证恒定的带宽，可以保证不丢包、有序和实时性。

VBR 网络：保证最大带宽，可以保证不丢包、有序和实时性。

> 由于 CBR 和 VBR 网络不会丢包，也不会超分配带宽，网络带宽不会超过最大可承载带宽，因此不需要拥塞控制

ABR 网络：只保证最小带宽，如果发送速率超过最小带宽则可能丢包或者失去实时性。仍然可以保证按序到达

UBR 网络：不保证带宽、丢包和实时性，只能保证按序到达。

> 可以保证按序到达是 ATM 网络的固有特点；不管贵/便宜的服务都能保证按序到达。

### 4.1.5 虚电路 vc 网络

虚电路 vc 网络就是 ATM 网络。

从源到目的路径的行为很像电话线路。

> 在数据通信之前需要拨号，建立虚电路，通信结束后撤销(teardown)该虚电路; 
>
> 每个包包含一个虚电路号 (VC  identifier)，路由器按照此号寻找通信目标和转发路由器。
>
> 每个在源-目的之间的路由器都需要维持连接状态，并为这对正在通信的设备预留网络资源
>
> 通信之前就知道通信质量（带宽）如何

一个虚电路包括：

:one: 从发送端到接受端的路径

:two: 虚电路号，每条路径对应一个数字

:three: 沿路路由的转发表项

**每经过一个交换机，虚电路号就会改变一次;**

每个交换设备都会维护一个交换表，该表是事先确定好的。该表存储如下一个虚电路号等数据。路由器会根据当前包的虚电路号，决定其需要转发到哪个路由器中。

> IP 网络是通过 IP 地址确认转发目标的。

![image-20220413104014145](https://telegraph-image-5ms.pages.dev/file/AgACAgUAAyEGAASIfjD1AAPWaJjDVqCceAmGp7d7xAAB6XgQz__dAAJxyjEb8mrJVK_lqgpdEs7SAQADAgADeAADNgQ.png)

上图的转发表如下

| Incoming interface | Incoming VC # | Outgoing interface | Outgoing VC # |
| ------------------ | ------------- | ------------------ | ------------- |
| 1                  | 12            | 3                  | 22            |
| 2                  | 63            | 1                  | 18            |
| 3                  | 7             | 2                  | 17            |
| 1                  | 97            | 3                  | 87            |
| ……                 | ……            | ……                 | ……            |

> Incoming interface：输入从路由器的哪个接口到来
>
> incoming VC：输入是从编号为什么的虚电路线上来的
>
> Outgoing interface：输出应当转发到路由器的哪个端口中
>
> Outgoing VC：输出到什么编号的虚电路线上

路由器维护连接状态信息;；链路和路由器带宽资源可以分配到用户，即使用户没有使用资源，只是拨号了。

#### 信令协议

用于建立,维护,撤销 (teardown) 虚电路(VC)的协议，即拨号、挂断等操作需要的协议。

应用于:  **ATM**, frame-relay, X.25, **IPv6** ; 

**IPv4 中没有应用**

### IPv4 数据网络

1. 连接建立前没有初始化过程，不需要拨号等操作预留资源

2. 没有逻辑上“连接”的概念。网络层上，包的发送和接收就是直接进行的，不用建立端到端的连接。

3. 利用 IP 地址得到下一个要转发到的路由器

   注意：**同一目标发向同一个接收端的数据包可能采用不同路径做传输**。

## 4.2 路由器结构

![image-20220331151429700](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAP1aJjEcs64OdDKSCbxQZVBVoNYetUAAnIWAALyaslUavbKDpvAV142BA.png)

路由器的结构分为两大类：路由选择部分和分组转发部分

分组转发部分由三部分组成：**一组输入端口、交换结构和一组输出端口**

交换结构从输入端口接收到分组后，根据转发表对分组进行处理，然后从一个合适的输出端口转发出去。

路由器的两个功能

> :one: 运行路由算法/协议：RIP、OSPF、BGP：只有边界网关路由器才会运行 BGP
>
> :two: 将数据包从输入链路转发到输出链路

物理结构上，路由器内部是嵌入式计算机，而且没有硬盘，只有 ROM 和闪存。

### 4.2.1 输入端口

![image-20220502141010437](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPXaJjDZHS9IuPRHN4V_N87D-Cpb8cAAl0WAALyaslUJpGv-TNwJtA2BA.png)

最左边物理层、中间链路层、最右边网络层

### 4.2.2 三种交换方式

![image-20220413111007594](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPYaJjDcx5znbMO07oN38wneZNHkREAAl8WAALyaslUCmAirEPUsKg2BA.png)

:one: 通过存储器进行交换：输入端口通过系统总线将数据包放到内存里，输出端口再利用总线从内存中读走;

> 早期路由器采用这种方式,在CPU 的直接控制之下进行交换;
>
> **两次访问内存,两次使用总线**,效率低;
>
> 速度被内存带宽所限制(每个数据包需要经过2 个总线交叉口)\
>
> ![image-20220413111628025](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPZaJjDgCWRJzZXUIs9iUbKuPXOVmkAAmAWAALyaslUdUDZlwdlal02BA.png)

:two: 通过总线进行交换：任意输入端口的数据放到总线上，输出端口从总线上读取数据;

> 不需要使用内存做中介，数据发送到总线后直接发送到输出端口;
>
> 路由器性能多快取决于总线的带宽，目前可达 32 Gbps

:three: 通过交叉开关网络（crossbar）进行交换：这是一种更复杂的交换结构，由一个二维的开关矩阵构成，能够在多个输入和输出端口之间同时建立非阻塞的连接。

### 4.2.3 输出端口

![image-20220413111853360](https://telegraph-image-5ms.pages.dev/file/AgACAgUAAyEGAASIfjD1AAPaaJjDg_3CWdoBTeQRqItVoZVGcpcAAnLKMRvyaslUaLyd2HrsZn8BAAMCAAN4AAM2BA.png)

> 上图中的三层分别是网络层、数据链路层和物理层

当数据报从交换结构到达的速度快于传输速率时，需要缓冲。缓冲区开辟在网络层。如果输出端口的缓冲区满掉，同样也会丢包（不过很少见）。

调度原则：从队头选择数据报进行传输

输出端口改设置多大的缓冲区呢？有一个经验公式：（也不是很重要）

平均缓冲区大小 = “典型‘RTT（一般取 250ms）乘上链路容量 C。

比如，链路为 10Gbps 链路，那么应当保留 0.25 * 10 = 2.5 Gb 位的缓存。

如果有 N 个 TCP 流的话，可以取缓存大小为：
$$
\dfrac{C\times RTT}{\sqrt{N}}
$$

### 输入端口的阻塞

输入端口的阻塞是导致路由器丢包/延迟大的主要原因。那么输入端口为什么会阻塞呢？

主要原因：当交换结构的处理速率低于输入端口的接收速率时，输入端口的数据报就会堆积，导致阻塞。

> 因为输入端口（input port）要经过交换结构（switch fabric）才能到达输出端口；瓶颈常常存在于交换结构上。

**行头阻塞 Head-of-the-Line (HOL) blocking**：多个输入端口同时转发到同一个输出端口，不能同时发送，因此只能排队转发。因为每个时刻只能有一个数据包发送，其他数据包需要在队列里等待，因此阻塞了队列，使队列变长。可能会导致输入端口队列满，从而导致丢包。

> 能不能用其他端口均衡一下负载？很遗憾，每个输出端口都对应了特定的 IP 区段，因此每个数据报根据 IP 地址只有一个可去的输出端口，不能更改。

![image-20220413112438780](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPbaJjDkunbmDIB32YqDZ6CvmhNFAoAAmEWAALyaslUpzG4kEJpXQI2BA.png)

## 4.3 IPv4

### 4.3.1 概述

#### 因特网网络层

![image-20220413112736911](https://telegraph-image-5ms.pages.dev/file/AgACAgUAAyEGAASIfjD1AAPcaJjDlv4fYePX5vIzj6gPCHy-2AEAAnPKMRvyaslUsAmBgZxA8IIBAAMCAAN5AAM2BA.png)

网络层包含很多协议：

ICMP: 控制报文协议.用于差错报告，连通性检查.

IP:  Internet Protocol，IP 网络协议

网络层可以分为两个子层，其中多种路由协议与 ICMP 协议位于上面的子层，IP 协议位于下面的子层。

部分路由信息与 ICMP 报文可以直接封装在 IP 包中传输。

#### IPv4 网络特征

:one: 有数据直接发送,不需要在网络层建立链接.

:two: 不需要路由器维护状态.

:three: 当路由器收到数据报时,会将其中的网络部分取出,查路由表,对应哪个出口就转到哪个出口.

:four: 可以走不同的路径,因此可能后发的数据包比先发的数据包更早到达,可能出现乱序.

#### 转发表

主干网的路由器需要根据包的目的 IP 地址前缀不同，将其转发到不同 ISP 的子网中。

![image-20220413104951814](https://telegraph-image-5ms.pages.dev/file/AgACAgUAAyEGAASIfjD1AAPdaJjDnOWvtPuPCwVecWesahlFL3AAAnTKMRvyaslUFG34cmA0nBQBAAMCAAN5AAM2BA.png)

采用最长前缀匹配原则

![image-20220413105403155](https://telegraph-image-5ms.pages.dev/file/AgACAgUAAyEGAASIfjD1AAPeaJjDn0fPQe4q1bUWk2p6xccsBhkAAnXKMRvyaslU1PB4XHE11MgBAAMCAAN4AAM2BA.png)

![image-20220413105246695](https://telegraph-image-5ms.pages.dev/file/AgACAgUAAyEGAASIfjD1AAPfaJjDovSQylCcduTdBH4EX1A7GcQAAnbKMRvyaslUykTt9niFuacBAAMCAAN4AAM2BA.png)

第二个目的地址(DA)可以匹配接口2 (0011)和接口1(0011000),根据最长前缀原则,选择接口1

### 4.3.2 IP 数据包格式

![image-20220413112947228](https://telegraph-image-5ms.pages.dev/file/AgACAgUAAyEGAASIfjD1AAPgaJjDpb-SzVhHA_X9gPZ4Aw3E_OUAAnfKMRvyaslUfZ83Cv1-Y5wBAAMCAAN4AAM2BA.png)

IP 的首部也是 20 个字节（20B)，跟 TCP 段头一样。每行四字节，Options 行不使用，因此一共五行，总计 20 字节。

:one: version：区别是IPv4还是IPv6，通信双方的版本必须一致（4 位）

:two: head len：首部长（4 位）

:three: type of service：服务类型，IPv6 才有区别，IPv4 未启用（8 位）

> IPv6 网络中，服务类型可以指定数据包的优先级；IPv4 网络从来没用过此字段（之后也不会用）

:four: flags : 切片包时用的，被切片后，前方的包此位都是 1，最后一个包的此位为 0

> 分包之后，每个包仍然包含 IP 协议的包头，只是把数据域拆开了。
>
> 分包之后，中间路由器即使 MTU 足够装下原先的包，也不会主动合并包；分包会在接收端被合并

:five: fragmentation : 将包切片时用的，表示偏移量

> 切片: 将IP 包切分成若干个比较小的片,使之能够放到信元中.
>
> 网络链路层有MTU (最大传输单元),不同的链路有不同的MTU.
>
> 对于较大的数据包,如果MTU 装不下包,则会将其切分.
>
> 被切分的数据包,只有在接收端才会进行装配.

实践当中，很少有包真的被切片（除了 ATM 网络这种 MTU 只有 53 字节的恐怖网络）

:six: Time to live（TTL）：最多可转发的次数（存活时间）。每次经过一个路由器，TTL-1；当 TTL 等于 0 时，路由器在尝试转发时应当直接丢弃此包。

:seven: upper layer：表示此 IP 数据报封装的是哪个上层数据协议的内容，比如可以说明此数据报是 TCP 还是 UDP 协议发出的。

:eight: checksum (首部校验和)：该字段仅对IP首部进行差错检测。因为数据报每经过一个路由器，TTL等字段都会改变，所以路由器需要重新计算并更新首部校验和。这提供了一层保护，防止因路由器内存损坏等原因导致的首部错误。不过，总体来说意义不大。

:nine: 源 IP 地址、目的 IP 地址

### 4.3.3 IPv4 地址

IPv4 地址是“点分十进制”表示的，即用点分为四段，每段采用十进制表示。

IP 地址**跟网络接口对应**，不跟主机对应，路由器有许多接口也就有许多 IP 地址。

> 一般电脑只有一个无线网卡，因此 IP 地址是唯一的；不过，如果你插了两个网卡并且连接了两个网络，那么你就有两个 IP 地址了。

IP 地址分为两大段：**高位为网络部分，低位为主机部分**，这两半的长度是固定的，根据网段类型确定。

<mark>同一网段，IP 地址网络部分相同；不同网段，网络部分不同</mark>

> 如果同一网段网络部分不同的话，各个主机之间就不能相互通信了。

子网：子网就是网段。同一子网下通信无需经过路由器，不同子网下通信必须经过路由器。

> 区分一张网络图中有多少子网的方法：把所有路由器都删掉，剩下的机器分为了互不相连的几部分就有几个子网。
>
> 注意：删掉路由器后，路由器之间的连接**也算网段**。比如：
>
> ![image-20250424153935784](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPhaJjDp_9xISBZ-CTyFaBLn8EfbywAAmQWAALyaslUrmDhwYwCb1Y2BA.png)
>
> 下图中存在**六个网段**：223.1.9，223.1.8, 223.1.7 这几个只有路由器参与的 IP 段**也算网段**。

#### 地址分类

把整个因特网看作一个单一的，抽象的网络，IP 地址就是给每个连接在网络上的主机（或路由器）分配一个在全世界范围内是唯一的 32 位的标识符。一般将IP地址分为 A,B,C,D,E 类地址（E类地址不使用）。

四类 IP 地址如下：

![image-20220329102141882](https://telegraph-image-5ms.pages.dev/file/AgACAgUAAyEGAASIfjD1AAPiaJjDqgNrY6mirBxCIOE8n_AeNCcAAnjKMRvyaslUZAvgJ9zdUlgBAAMCAAN4AAM2BA.png)

> :one: A类地址高八位（最高一字段）是网络部分，其余是主机部分，最高位固定为 0
>
> > 可以指派的网络数为 $2^7-1$：网络地址全 0 为保留地址，“本网络”，网络号为01111111（127 开头）保留为环回地址，不能用于分配。
> >
> > 主机数最多为 $2^{24}-2$
> >
> > （少了两个地址是因为主机号全 0 和全 1 的地址都没法分配给主机）
>
> :two: B类地址高十六位字段是网络部分，其余是主机部分，最高位固定为10
>
> > 网路地址 128.0 开头实际上不指派，所以最少从128.1 开头开始，可以指派的网络数为 $2^{14}-1$
> >
> > 主机数最多为 $2^{16}-2$
>
> :three: C类地址高二十四位是网络部分，其余是主机部分，最高位固定为110
>
> > 网路地址 192.0 开头实际上不指派，所以最少从 192.1 开头开始，可以指派的网络数为$2^{21}-1$
> >
> > 主机数最多为$2^{8}-2$
> >
> > 内网常常采用 192.168.1 网段作为网络部分。
>
> :four: D类地址高三十二位为为网络部分，没有主机部分。网络部分最高位固定为1110
>
> > 多播通信时作为目的地址
> >
> > 多播：类似于微信的群聊

A，B，C 三类地址空间中，分别有一个网段是用于内部网络的：

A：10.0.0.0-10.255.255.255

B：172.16.0.0-172.31.255.255

C：192.168.0.0-192.168.255.255

#### 特殊IP地址

| 网络号 | 主机号       | 源地址或目的地址 | 含义/作用            |
| ------ | ------------ | ---------------- | -------------------- |
| 全0    | 全0          | 仅作为源地址     | 这个网络上的这个主机 |
| 全     | 特定的       | 目的地址         | 这个网络上的特定主机 |
| 全1    | 全1          | 目的地址         | 受限广播地址         |
| 特定的 | 全1          | 目的地址         | 直接广播地址         |
| 特定的 | 全0          | 都不是           | 网络地址             |
| 127    | 不是全1或全0 | 源地址或目的地址 | 环回地址             |

> :one: 这个网络上的这个主机：IP为 0.0.0.0，只能在和 DHCP 服务器通信获取 IP 地址时发送。毕竟你要获取 IP 的时候还没有 IP，那么发送端地址就只能填个特殊的了）
>
> :two: 这个网络上的特定主机：属于A类地址，用于向同一网络上的某个主机发送报文。
>
> :three: 受限广播地址：IP为255.255.255.255，<mark>用于定义在当前网络（不是整个互联网）</mark>。会向本地局域网中的其他主机发送分组，路由器会阻拦其传播到局域网外。
>
> :four: 直接广播地址：主机号全1，路由器使用这个地址把一个分组发送到一个特定的网络上的所有主机，所有主机都会收到具有这种类型的**目的地址**的分组.
>
> :five: 环回地址：用于自我测试，属于A类地址。向任意这类地址发送的所有数据都会发送到本机的对应端口。不过 127.0.0.0 和 127.255.255.255 为广播地址，不能用的。
>
> 虽然整个 127.0.0.0/8 网段都保留用于环回，但最常用的地址是 127.0.0.1。不同操作系统和应用程序对其他环回地址的支持可能有所不同，比如有的浏览器无法将 127.0.0.1 以外的环回地址解析到本机。

### 4.3.4 NAT

#### 概述

**NAT：network address translation 网络地址变换**

> 由于公网 IP 地址不同，在网络内部采用假的 IP 地址，和外层的 IP 地址映射。

其实某些机构并不需要连接到因特网，只需要与内部的主机通信，这样如果还是按照全球IP地址去分配，则会大大浪费IP地址。

例如，100 个机构各有 100 台主机，假设现在 100 个机构都分配全球IP 地址，就需要 1000 个全球IP地址，但是现在从所有的全球IP地址里面划分出100 个IP地址专门用作一些只需内部通信的机构使用，即 100个机构都使用这 100 个地址，只需要 100 个 IP 地址就解决问题了。这100个IP地址在计算机网络中被称为专用地址，且**路由器看到专用地址时不转发**，仅在内部网络中通信。所以说专用地址作为目的地址是不可能在因特网上传送的。因特网已经规定了以下地址作为专用地址。

> 10.0.0.0~10.255.255.255 (相当于一个A类网络)。
>
> 172.16.0.0~172.31.255.255 (相当于16个连续的B类网络)。
>
> 192.168.0.0~192.168.255.255 (相当于256个连续的C类网络)。

这种采用专用IP地址的互联网络称为专用互联网或本地互联网,或直接称为专用网。专用IP地址也叫作可重用地址。问题出现了，如果专用网的主机想和因特网的主机通信，怎么办?这时 NAT 就诞生了。**NAT 就是将专用网内部使用的本地 IP 地址转换成有效的外部全球IP地址，使得整个专用网只需要一个全球 IP 地址就可以与因特网连通。**

由于这些本地IP地址是可重用的，因此NAT技术可大大节省IP地址的消耗。使用NAT技术，需要在专用网连接到因特网的路由器上安装NAT软件。装有NAT软件的路由器叫作NAT路由器，它至少有-一个有效的外部全球IP地址。但是NAT并不能从根本上解决IP地址的耗尽问题,因为NAT并没有增加IP地址的个数。而**真正解决IP地址耗尽问题的是IPv6**

NAT使能路由器对于外部世界来说甚至不像一台路由器。相反NAT路由器对外界的行为就如同一个具有单一P地址的单一设备。在图中，所有离开家庭路由器流向更大因特网的报文都拥有一个源P地址138.76.29.7，且所有进入家庭的报文都拥有同一个目的 IP 地址138.76.29.7。从本质上讲，NAT使能路由器对外界隐藏了家庭网络的细节。

#### NAT转换表与示例

![image-20220413160409813](https://telegraph-image-5ms.pages.dev/file/AgACAgUAAyEGAASIfjD1AAPjaJjDrkrdU9_SgeRT3tmt6sTaKa4AAnnKMRvyaslULhuUF2H0DnUBAAMCAAN5AAM2BA.png)

> 每个内部 IP 地址-端口组合对应了路由器外部 IP 地址（唯一）上的不同端口
>
> 发送（流出）包重写源 IP 地址为路由器的公网 IP；接受（流入）包重写目标 IP 地址为内部电脑的内部 IP，可以查询 NAT 转换表实现。
>
> 注意路由器对外通信时表现的 IP 地址只有一个。

如果从广域网到达 NAT 路由器的所有数据报都有相同的目的IP地址（特别是对 NAT 路由器广域网一侧的接口)，那么该路由器怎样知道它应将某个分组转发给哪个内部主机呢？

使用 NAT 路由器上的一张 **NAT 转换表(NAT translation table)**,并且在表项中包含了**端口号及其 IP 地址**。

考虑上图中的例子。

> :one: 假设一个用户坐在家庭网络主机10.0.0.1后，请求P地址为128.119.40.186的某台Web服务器（端口80）上的一个Web页面。主机10.0.0.1为其指派了（任意）源端口号3345并将该数据报发送到LAN中。
>
> :two: NAT路由器收到该数据报，为该数据报生成一个新的源端口号5001，将源P替代为其广域网一侧接口的IP地址138.76.29.7,且将源端口3345更换为新端口5001。当生成一个新的源端口号时，NAT路由器可选择任意一个当前未在NAT转换表中的源端口号。（注意到因为端口号字段为16比特长，NAT协议可支持超过60000个并行使用路由器广域网一侧单个P地址的连接)
>
> :three: 路由器中的NAT也在它的NAT转换表中增加一表项。Web服务器并不知道刚到达的包含HTTP请求的数据报已被NAT路由器进行了改装，它会发回一个响应报文，其目的地址是NAT路由器的P地址，其目的端口是5001。
>
> :four: 当该报文到达NAT路由器时，路由器使用目的IP地址与目的端口号从NAT转换表中检索出家庭网络浏览器使用的适当IP地址(10.0.0.1)和目的端口号(3345)。于是，路由器重写该数据报的目的P地址与目的端口号，并向家庭网络转发该数据报。

进出都要涉及变换,因此会使通信效率下降.

#### NAT网关穿越问题

:one: 静态配置 NAT 表(Statically  Configure  NAT)

> 每有一个新的应用（新的内部 IP-端口号组合），就需要往 NAT 表中加一条表项，映射到一个特定的路由器端口。
>
> 由网络管理员配置.

:two: 动态配置 Universal  Plug  and  Play (UPnP)

> 通过软件自动添加，在遇到新的内部 IP-端口 组合时，自动为其分配一个外部端口号。不过，此分配有时间限制。
>
> 这类软件核心协议是IGD 协议(Internet  Gateway  Device  Protocol)

#### NAT 的缺点

NAT 也有一些缺点：

1. 网络通信速度会变慢（因为需要在路由器处映射并修改 IP 地址）
2. 外部的网络不清楚内部网络主机开通了多少服务（因为内部主机端口和其映射为的外部主机端口不同）

### 4.3.5 子网掩码 Subnet Mask

#### 子网划分

两级 IP 地址划分的不够合理

> IP 地址利用率很低
>
> 给每个物理网络分配一个网络号会使路由表变得太大而使网络性能变坏
>
> 两级的 IP 地址不够灵活

于是有子网划分，使两级的 IP 地址变为三级的 IP 地址。划分子网是一个单位内部的事情，单位对外仍然表现为没有划分子网的网络。

**划分子网的思路**：从主机号高位借用若干比特作为子网号，而主机号也就相应减少了若干个比特，网络号不变，于是 IP 地址可记作：

> 注意子网号不能全 0 或者全 1，因此两位子网号理论上可以划分四个子网段，但其中 00 和 11 是不能作为子网段的，因此只能划分为两个子网：01 和 10。
>
> 同理，3 位子网号只能划分 6 个子网段。

!> 按照早期的标准（RFC 950），子网号不能为全0或全1。但在现代网络实践中，这个限制已经废弃（RFC 1878），现在可以正常使用全0和全1的子网。考试中，请仍然按照“子网号不能为全 0/1” 来做题。

$$
\text{IP地址}::=\{\text{<网络号>，<子网号>，<主机号>}\}
$$

凡是从其他网络发送给本单位某个主机的IP数据报，仍然根据IP分组的目的网络号先找到连接在本单位网络上的路由器。然后此路由器在收到IP数据报后，再按照目的网络号和子网号找到目的子网，最后将IP数据报交给目的主机

#### 子网掩码

子网划分与否是看不出来的，如果要告诉主机或路由器是否对一个A类、B类、C类网络进行了子网划分，则需要子网掩码。

子网掩码是一个与 IP 地址相对应的 32 位的二进制串，它由一串 1 和 0 组成。其中，1 对应于 IP 地址中的网络号和子网号，0 对应于主机号。因为 1 对 1 进行与操作，结果为 1；1 对 0 进行与操作，结果为 0。所以使用一串 1 对网络号和子网号进行与操作，就可以得到网络号。

> **网络号和子网号部分填写 1，主机号部分填写 0，即可得到子网掩码**。

:label: 不管网络有没有划分子网，只要将子网掩码和IP地址进行逐位的“与”运算，就一定能得到子网地址

如果没有给出子网掩码，则采用默认的：A：255.0.0.0、B：255.255.0.0、C：255.255.255.0

> 这个子网掩码只把网络号的部分设置为 1，主机号部分都是 0，因此相当于没有划分。

> IP地址：32 位地址
>
> 网络地址：32 位地址，网络部分不变，后面为 0
>
> 子网地址：32 位地址，子网以前不变，后面为 0
>
> 注意不管是什么地址**一定是 32 位**。你问子网地址后面主机号不知道怎么办？填 0 呀！

子网数量计算：考虑一个 B 类网段，其中包含 65534 个主机（$2^{16}$-2）。那么，划分前 6 位为子网后，其中包含主机数为：

$(2^6-2)(2^{10}-2)=63334$ 个 IP。-2 是因为全 0 和 全 1 两部分都无法分配给主机。

本质上，IP 数量损失是因为子网号禁止全 0 和全 1，导致丢失了两个子网段。

### 4.3.6 CIDR 无类别域间路由选择

Classless Inter-Domain Routing 无类别域间路由选择。

这种无类划分的 IP 地址不包含子网部分，只分为网络部分和主机部分。格式为 a.b.c.d/x，**代表高 x 位是网络部分**，剩余为主机部分。

> 这种划分的 IP 地址中，网络部分包含了上面那种 IP 地址的网络号部分+子网号部分

主要用于路由器存储路由表，因为路由器转发时只关心 IP 地址的网络部分，而不关心其主机部分。

![image-20220413154037936](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPkaJjDwg2Jr0JdjT3v851KzoZDi-8AAmcWAALyaslU4QXRkCc6IWw2BA.png)

### 4.3.7 DHCP

Dynamic Host Configuration Protocol 动态主机配置协议：给主机动态地分配IP地址

他是一个**应用层协议**，DHCP 报文使用 **UDP** 传输（虽然是在网络层讲的）

它提供了**即插即用连网的机制**，这种机制允许一台计算机加入新的网络和获取 IP 地址而不用手工参与。例如，现在有一台主机需要 IP 地址。在该主机启动时就可以向 DHCP 服务器广播发送报文，将源地址设置为`0.0.0.0`,目的地址设置为`255.255.255.255`(特殊IP地址)。这时主机就成为 DHCP 的客户，发送广播报文主要是因为现在该主机还不知道 DHCP 在哪，这样在本网络上的所有主机都能够收到该广播报文，但是只有 DHCP 服务器能够应答。DHCP 服务器先在其数据库中查找该计算机的配置信息，若找到，则返回找到的信息，若找不到，则从服务器的 IP 地址池中取一个地址分配给该计算机。

DHCP 服务器和 DHCP 客户端的交换过程如下（4 步**广播**通信）

由于采用广播通信，协议只能选择 UDP。

> :one: DHCP 客户端广播 <mark>"DHCP discover"</mark> 报文，试图找到网络中的 DHCP 服务器，服务器生成一个未使用的一个 IP 地址
>
> :two: DHCP 服务器收到报文后，就向网络中广播 <mark>"DHCP offer"</mark> 报文，其中包括提供 DHCP 客户端的 IP 地址和相关配置信息。
>
> 这里进行广播通信（目的地址为全 1），因为此时客户端还没有获得 IP 地址。
>
> 网络中可能存在多个 DHCP 服务器，因此可能返回多个 offer 报文。
>
> :three: DHCP 客户机收到 <mark>“DHCP offer”</mark> 报文，如果接受 DHCP 服务器所提供的相关参数，则通过广播 “DHCP request” 报文向 DHCP 服务器请求提供 IP 地址。
>
> :four: DHCP 服务器广播 <mark>“DHCP ack”</mark> 报文，将 IP 地址分配给 DHCP 客户机。同时其他 DHCP 服务器将其 IP 地址收回。
>
> 此时目的地址还是全 1；完成此步骤后，客户端才真正获得了 IP 地址。
>
> DHCP 允许网络上配置多台 DHCP 服务器，当 DHCP 客户发出 DHCP 请求时，就有可能收到多个应答报文。这时，DHCP 客户只会挑选其中的一个，通常是挑选“最先到达的报文。
>
> ![image-20220413154204422](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPlaJjD1qj43WeZVO7QEIisls2jB20AAmgWAALyaslUFlv7MdlTLDA2BA.png)

> yiaddr 就是 DHCP 服务器分给客户端的 IP 地址。
>
> DHCP Request 报文中，虽然前一个报文中客户端已经知道 DHCP 服务器的 IP 了，但目的 IP 还是广播，这是为了应对网络中存在多台 DHCP 服务器的情况。
>
> DHCP 所有步骤都采用广播通信：无论是新加入的客户端还是服务器，它们通信时目的 IP 都是  255.255.255.255（广播）
>
> 客户端的源 IP 地址始终为 0.0.0.0（因为在完成四次通信后，客户端才正式得到了 IP 地址）

除了主机 IP 地址分配以外，DHCP 还允许一台主机得到其他信息：

> 它的子网掩码
>
> 它的第一跳路由器地址（默认网关）
>
> 它的本地 DNS 服务器地址

### 4.3.8 ICMP

Internet Control Message Protocol 网络控制报文协议，位于网络层的上半层（即在 IP 协议之上）

主机在发送数据报时，经常会由于各种原因**发送错误**，如路由器拥塞丢弃了或者传输计程中出现错误丢弃了(注意：如果是首部出错，当然可以发，但是一般都不发，因为首部中错很有可能是源 IP 地址都错了，所以即使发了源主机也不一定收到回包)。

如果检测出错误的路由器或主机都能把这些错误报告通过一些控制消息告诉发送数据的主机，那么发送数据的主机就可根据 ICMP 报文确定发生错误的类型，并确定如何才能更好地重发失败的数据报(比如ICMP报文发过来的是改变路由，那么主机就不能继续按照这个路由线路发送了，需要用另外一条路由线路发送数据)。

尽管这些控制消息并不传输用户数据，但是对于用户数据的传递起着重要的作用。

ICMP 报文分为两种，即 ICMP 差错报告报文和 ICMP 询问报文。

ICMP 报文主要分为两部分：类型和编码。二者一起决定了报文的含义，对应如下：

![image-20250427092810687](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPmaJjD2IkAAS88BJwfU5nk-FjaeUvsAAJpFgAC8mrJVCOKiemLKCTtNgQ.png)ICMP 的两个典型应用，其实在日常生活中经常用，即**ping和tracert**.。

> ping 用来测试两个主机之间的连通性。ping 使用了 ICMP **回送请求与回送回答**报文。ping 是**应用层**直接使用网络层ICMP的例子，它没有通过传输层的TCP或UDP。
>
> tracert (或 traceroute) 可以用来跟踪分组经过的路由。它工作在网络层。其原理是发送一系列TTL从1开始递增的探测包。当第 i 个探测包到达第 i 跳路由器时，TTL减为0，该路由器会返回一个ICMP“超时”报文。通过记录这些返回报文的源IP地址，就可以逐跳地描绘出路径。不同操作系统实现方式略有不同，例如Windows的tracert默认使用ICMP回显请求，而Linux/macOS的traceroute默认使用UDP报文。


## 4.4 IPv6

### 4.4.1 IPv6 的特点

IPv6 地址长度为 **$16 \times 8=128$** 位。每段长度为 16，分为8 个段。

由于 IPv4 地址即将耗尽，因此必须采取相应的办法去解决。前面已经介绍过采用网址转换(NAT)方法以节省全球IP地址和采用无分类编址（CIDR）使IP地址的分配更加理。这两种方法仅是优化了 IPV4 地址的使用方法，并没有从根本上增多 IPv4 地址。

而采用具有**更大地址空间的新版本的 IPv6** 才能在真正意义上解决 IPv4 即将耗尽的问题。

总结 IPv6 的主要特点。

> 1)更大的地址空间。IPv6 将地址从 IPv4 的 32 位增大到了 128 位。
>
> 2)扩展的地址层次结构。因为地址多了，所以可以划分更多的层次。
>
> 3)灵活的首部格式。允许设置“服务优先级”属性，且此属性真的有用
>
> 4)包格式更简洁，因此更快。
>
> 5)支持资源的预分配。
>
> 6)IPv6 首部长度必须是 8B 的整数倍，而IPv4首部是4B的整数倍
>
> IPv6 首部头大部分为 40 字节。

虽然 IPv6 与 IPv4 不兼容，但总的来说它跟所有其他的因特网协议兼容，包括 TCP、UDP、ICMP、DNS 等，只是在少数地方做了必要的修改（大部分是为了处理长的地址）。IPv6 相当好地满足了预定的目标，主要体现在以下3个方面。

> 1)IPv6第一个主要改进也是最重要的，即IPv6有比IPv4长得多的地址。
>
> 2)IPv6第二个主要改进是简化了IP分组的基本首部，它包含8个段（IPv4是12个段）。这一改变使得路由器能够**更快地处理数据报**，从而可以改善吞吐率。
>
> 3)IPv6第三个主要改进是IPv6更好地支持选项。这一改变对新的分组首部很重要，因为一些从前是必要的段现在变成可选的了。此外，表示选项的方式也有所不同，使得路由器能够简单地跳过与它们无关的选项。这一特征加快了数据报处理速度。

### 4.4.2  IPv6 格式

IPv6 的首部格式如下（一共40B）：

> IPv6 头部虽然空间增大了，但项目数从 12 个减少到了 8 个，因此总体更加简洁了。

左侧为 IPv6，右侧为 IPv4

![image-20220502133146399](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/image-20220502133146399.png)

优先级 priority：确定流中数据报的优先级（真的有用）

流标号 flow label：识别相同“流”的数据报。比如，相同的视频/音频流传输时，所有数据报的 flow label 就是相同的。

载荷长度 payload len：记录数据的长度。IPv6 头部长度固定，因此知道了数据长度就知道了包的总长。

下一个报头 next hdr（next header）：识别数据的上层协议，即说明此 IP 数据报是用于传输 TCP, UDP 还是 ICMP 协议的包。

跳转限制 hop limit：相当于 TTL，限制路由器转发的次数。

源 IP 地址：128 位，16 字节长

目的 IP 地址：128 位，16 字节长

IPv6的一个重要改变是，路由器不再对IPv6数据报进行分片。如果数据报过大，路由器会将其丢弃并返回一个ICMPv6“分组过大”的报文。分片必须由源主机完成，通过使用“分片”扩展首部来实现。这大大减轻了路由器的处理负担。此外，IPv6取消了首部校验和字段，以进一步加速处理。

### 4.4.2 从 IPv4 转变到 IPv6

IPv4 和 IPv6 混合的网络将如何运行?

> 隧道技术 *Tunneling*：IPv6 包通过 IPv4 网络时，将整个包作为 IPv4 协议的数据域传输，即添加 IPv4 包头；再次到达 IPv6 网络后，再从 IPv4 包中解出 IPv6 格式的包。
>
> 不会丢失任何字段，不过经过隧道时包大小会增加。
>
> 双栈技术 *Dual-stack*：IPv6 包通过 IPv4 网络时，直接将 IPv6 包转换为 IPv4 的包；再次到达 IPv6 网后再转换回来。但是 IPv6 存在而 IPv4 不存在的选项会丢失（比如优先级字段、flow label 字段）

:one: **双栈技术 *Dual-stack***

![image-20220502133215019](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPnaJjD7hkIMJFJFe-IxRU5MPagJF8AAmoWAALyaslUHuaCynGfLjo2BA.png)

到达边缘路由器（IPv4-v6 协议更改）的时候将包进行转换（IPv4<->IPv6）

主要难点是转换 IPv4 和 IPv6 的地址。

:two: **隧道技术*Tunneling***

![image-20220506210033288](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPoaJjEBXUWerhXMJBf0wMz-OQcR_MAAmsWAALyaslUQsgQljG-yaQ2BA.png)

将 IPv6(IPv4) 的包整个封装到 IPv4(IPv6) 的包中，将整个 IPv4 网络视为隧道。

## 4.5 路由算法

这是本章节**最难的部分**。路由算法对应了网络层两大功能中的**路由选择**（另一个功能是分组转发）

### 路由抽象图

![image-20250428080648869](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPpaJjEB0DO0Ea2uIj9TGscuhXOhCoAAmwWAALyaslUPc-09PbIsj02BA.png)

我们可以通过“图”这一数据结构描述路由之间的传输时间关系。一般边上的代价（权重）是路由器管理员配置的，根据**带宽**或者**拥塞程度**配置。

我们使用 `c(x, x')` 表示从 x 到 x' 之间的边的代价。

路由算法需要解决的问题就是：我有一个数据报要从 u 传送到 z，那么 **u 到 z 之间的最低代价路径是什么**？

> 理论上说 Dijkstra 就可以做，不过 Dijkstra 是计算一个节点到多个节点的最短路径，其实只要算一个节点到一个节点就行，因此可以尝试其他更简单的算法以缩短计算时间。

### 4.5.1 路由算法的种类

现代的计算机网络通常使用动态路由选择算法。动态路由算法又可分为两种基本类型：**距离－向量路由算法和链路状态路由算法**。

**全局性**的路由算法：链路状态路由算法，维护一个全局的拓扑图。

**分散性**的路由算法：距离－向量路由算法，每个路由器只知道自己的邻居路由器和到邻居的代价，迭代式的计算

根据路由表数据是否变化，可以将算法分为静态和动态算法：

**静态**路由算法：路由表的数据随时间变化慢

**动态**路由算法：路由表数据变化比较快

### 4.5.2 距离－向量路由算法“distance vector” algorithms

#### 算法说明

不要求维护一个全局的拓扑图

**距离向量(Distance-Vector,DV)算法**是一种<mark>**迭代的、异步的和分布式**</mark>的算法，而 LS 算法是一种使用全局信息的算法。

前提：每个路由器**知道自己的邻居和到邻居路径的代价**。需要路由器和邻居交互以传递信息。

> :one: **分布式的**：因为每个节点都要从一个或多个直接相连邻居接收某些信息，执行计算，然后将其计算结果分发给邻居。
>
> :two: **迭代的**：此过程一直要持续到邻居之间无更多信息要交换为止。
>
> :three: **异步的**：是因为它不要求所有节点相互之间步伐一致地操作。
>
> :four: **自终止性**：此算法是自我终止的，即没有计算应该停止的信号，它就停止了。

令$d_x(\text{y})$是从**结点x到结点y的最低开销路径的开销**，则该路径开销与Bellman-Ford方程相关
$$
d_x(\text{y})=min_v\{c(x,v)+d_v(\text{y})\}
$$
这个方程有点类似 Dijkstra 的更新方式。

方程中的 $min_v$ **是对于x的所有邻居的**。Bellman-Ford方程是相当直观的。实际上，从x到v遍历之后，如果我们接下来取从v到y的最低开销路径，则该路径开销将是$c(x,v)+d_v(y)$。因此我们必须通过遍历某些邻居v开始，**从x到y的最低开销是对所有邻居v的$c(x,v)+d_v(y)$的最小值**。

> 即计算 x-y 的最小值就需要计算自己->邻居+邻居->y 两个路径和的最小值

x 的邻居怎么知道它到 y 的最短距离呢？因为它也可以通过一样的方式（询问自己的邻居）计算；它的邻居还可以通过询问邻居计算；就这样迭代下去，直到到达一个与 y 直接相邻的节点。

令$\pmb{D}_x=[\pmb{D}_x(y):y\in N]$是节点x的距离向量，该向量是**从x到在N中的所有其他节点y的开销估计向量**，使用DV算法，**每个结点x维护以下路由选择信息**

> :one: 对于每个邻居v，从x到直接邻居v的开销为c(x,v)
>
> :two: 结点x的距离向量，即$\pmb{D}_x=[\pmb{D}_x(y):y\in N]$，包含了从x到在N中的所有其他节点y的开销估计向量
>
> :three: 它的每个邻居的距离向量，对x的每个邻居v，有$\pmb{D}_v=[\pmb{D}_v(y):y\in N]$

在该算法中，每个节点周期性地向它的每个邻居发送它的距离向量副本，当当节点x从它的任何一个邻居v接收到一个**新距离向量**，它保存v的距离向量，然后使用Bellman-Ford方程更新它自己的距离向量如下：
$$
\pmb{D}_x(\text{y})=min_v\{c(x,v)+\pmb{D}_v(\text{y})\}\quad 对于N中的每个结点
$$
**如果节点x的距离向量因这个更新步骤而改变，节点x接下来将向它的每个邻居发送其更新后的距离向量，这继而让所有邻居更新它们自己的距离向量。**只要所有的节点继续以异步方式交换它们的距离向量，每个开销估计$\pmb D_v(y)$收敛到$d_v(y)$，$d_v(y)$为从节点x到节点y的实际最低开销路径的开销。

迭代只会由如下两种情况引起：

1. 本地链路的代价变化了
2. 邻居发送了最短距离变化的消息

发送最短距离变化的时机：仅仅在邻居-目的节点的**最短路径**发生变化后，邻居才会发送距离变化信息。

主要循环：

- 等待本地链路代价变化或者邻居发送最短距离变化信息
- 重新计算代价
- 如果到目标的最小代价变化了，通知邻居
- 返回第一步

<mark>算法伪代码如下(背下来)</mark>

```c
Initialization:
	for(all destination nodes y){
		if(y is a neighbor)
			Dx(y)=c(x,y)
		else{
			Dx(y)=infinity
		}
	}		
	for(each neighbor w){
		send distance vector Dx=[Dx(y):y in N] to w
	}
loop
	wait(until I see a link cost change to neighbor w or until I receive update from neighbor w)
	for(each destinations y){
		Dx(y)=min_v {c(x,v)+D_v(y)}
	}
	if(Dx(y) changed for any destination y){
 send new value of min Dx(y) to all neighbors 
}
forever
```

**举例说明**

![image-20220407144954467](https://telegraph-image-5ms.pages.dev/file/AgACAgUAAyEGAASIfjD1AAPqaJjEC3wdXfDs2jppxROu_IKpFJIAAnrKMRvyaslU_HI9MJboXK0BAAMCAAN5AAM2BA.png)

该图最左边一列显示了这3个节点各自的初始路由选择表(routing table)。例如，位于左上角的表是节点x的初始路由选择表。在一张特定的路由选择表中，每行是一个距离向量一特别是每个节点的路由选择表包括了它的距离向量和它的每个邻居的距离向量。因此，在节点x的初始路由选择表中的第一行是$\pmb D_x=[\pmb D_x(x),\pmb D_x(y),\pmb D_x(z)]=[0,2,7]$。在该表的第二和第三行是最近分别从节点y和z收到的距离向量。因为在初始化时节点x还没有从节点y和z收到任何东西，所以第二行和第三行表项中被初始化为无穷大。

初始化后，每个节点向它的两个邻居发送其距离向量。图5-6中用从表的第一列到表的第二列的箭头说明了这一情况。例如，节点x向两个节点y和z发送了它的距离向量,$\pmb D_x=[0,2,7]$。在接收到该更新后，每个节点重新计算它自己的距离向量。例如，节点x计算
$$
\begin{align}
&\pmb D_x(x)=0\\
&\pmb D_x(y)=\text{min}\{c(x,y)+\pmb D_y(y),c(x,z)+\pmb D_z(y)\}=\text{min}\{2+0,7+1\}=2\\
&\pmb D_x(z)=\text{min}\{c(x,y)+\pmb D_y(z),c(x,z)+\pmb D_z(z)\}=\text{min}\{2+1,7+0\}=3\\
\end{align}
$$
第二列因此为**每个节点显示了节点的新距离向量连同刚从它的邻居接收到的距离向量**。注意到，例如节点x到节点z的最低开销估计$D_x(z)$已经从7变成了3。

从邻居接收更新距离向量、重新计算路由选择表项和通知邻居到目的地的最低开销路径的开销已经变化的过程继续下去，直到无更新报文发送为止。在这个时候，因为无更新报文发送，将不会出现进一步的路由选择表计算，该算法将进入静止状态，即所有的节点将执行DV算法的中的**等待**。该算法停留在静止状态，<mark>**直到一条链路开销发生改变**</mark>，如下面所讨论的那样。

#### 链路开销改变与链路故障

当一个运行DV算法的节点检测到从它自己到邻居的链路开销发生变化时（I see a link cost change to neighbor w )，它就更新其距离向量并且如果最低开销路径的开销发生了变化，向邻居通知其新的距离向量。

##### 好消息传达速度快

下图示了从y到x的链路开销从4变为1的情况。我们在此**只关注y与z到目的地x的距离表中的有关表项。该DV算法导致下列事件序列的出现**

![image-20220407153504800](https://telegraph-image-5ms.pages.dev/file/AgACAgUAAyEGAASIfjD1AAPraJjEEvjh7gtsa4rWGaSXdiPEZdYAAnvKMRvyaslUaYotfC46ufoBAAMCAAN5AAM2BA.png)

> :one: 在$t_0$时刻，y检测到链路开销变化（开销从4变为1），更新其距离向量，并通知其邻居这个变化，因为最低开销路径的开销已改变。
>
> :two: 在$t_1$时刻，z收到来自y的更新报文并更新了其距离表。它计算出到x的新最低开销（从开销5减为开销2），它向其邻居发送了它的新距离向量。
>
> :three: 在$t_2$时刻，y收到来自z的更新并更新其距离表。y的最低开销未变，因此y不发送任何报文给z。该算法进入静止状态。

![image-20220407154218015](https://telegraph-image-5ms.pages.dev/file/AgACAgUAAyEGAASIfjD1AAPsaJjEFY9jv9Bn9qpN38Ai5DJqaVQAAnzKMRvyaslU7-DGup1jTAoBAAMCAAN4AAM2BA.png)

因此，对于该DV算法只**需两次迭代就到达了静止状态**。在x与y之间开销减少的好消息通过网络得到了迅速传播。

##### 坏的消息传送速度慢

假设x与y之间的链路开销从4增加到60，此时整个链路图变化如下：

:one:在链路开销变化之前，D,(x)=4,D,(z)=1,D(y)=1和D,(x)=5。在t0时刻，y检测到链路开销变化（开销从4变为60）。y计算它到x的新的最低开销路径的开销，其值为
$$
D_y(x)=min\{c(y,x)+D_x(x),c(y,z)+D_z(x)\}=min\{60+0,1+5\}=6
$$
当然，从网络全局的视角来看，我们能够看出经过z的这个新开销是错误的。但节点y仅有的信息是：它到x的直接开销是60，且z上次已告诉y,z能以开销5到x。因此，为了到达x,y将通过z路由，完全期望z能以开销5到达x。到了t1时刻，我们遇到**路由选择环路(routing loop),即为到达x,y通过z路由，z又通过y路由**。路由选择环路就像一个黑洞，即目的地为x的分组在1时刻到达y或z后，将在这两个节点之间不停地（或直到转发表发生改变为止)来回反复。

:two: 因为节点y已算出到x的新的最低开销，它在t,时刻将该新距离向量通知z。

:three: 在t1后某个时间，z收到y的新距离向量，它指示了y到x的最低开销是6。z知道它能以开销1到达y,因此计算出到x的新最低开销$D_z(x)=min\{50+0,1+6\}=7$。因为z到x的最低开销已增加了，于是它便在2时刻通知y其新开销。

:four: 以类似方式，在收到z的新距离向量后，y决定D,(x)=8并向z发送其距离向量。接下来z确定D,(x)=9并向y发送其距离向量，等等

以上的过程要一直迭代44次，知道z最终算出它经由y的路径开销大于50为止。这种坏消息会造成**无穷计数问题**count to infinity

![image-20220407154848619](https://telegraph-image-5ms.pages.dev/file/AgACAgUAAyEGAASIfjD1AAPtaJjEGJLom3QqmfApfk5PsThwStoAAn3KMRvyaslUKP-MZttM8XoBAAMCAAN4AAM2BA.png)

#### 算法改进：增加毒性逆转 poisoned reverse

如果 z 通过 y 路由选择到目的地 x,则 z 将通告 y，它(即 z)到 x 的距离是无穷大，也就是 z 将向 y 通告$D_z(x)=∞$（即使 z 实际上知道$D_z(x)=
5$)。只要 z 经 y 路由选择到 x，z 就持续地向 y 讲述这个**善意的谎言**。因为 y 相信 z 没有到 x 的路径，故只要 z 继续经 y 路由选择到 x(并这样去撒谎)，y 将永远不会试图经由 z 路由选择到 x。

这样，坏消息发生时，由于Y 相信自己没有通过 Z 到 X 的路径，它只能通过这个坏消息（Y->X）路径到达 X，因此更新时会直接声称 Y->X 最短距离变为 60（而不是上面错误的 6），从而让 Z 节点快速更新自己的数据。

但是3个或更多节点（而不只是两个直接相连的邻居节点）的环路将无法通过该技术检测到。

![image-20220407155256448](https://telegraph-image-5ms.pages.dev/file/AgACAgUAAyEGAASIfjD1AAPuaJjEGpzx0wyr546W7YmYmdQKh54AAn7KMRvyaslU7UZfY2RGliQBAAMCAAN4AAM2BA.png)

最后，由于 Y 需要通过 Z 到达 X，因此 Y 节点直接声称自己没有到达 X 的路径，从而导致 Z->Y->X 这条链路的代价变为无穷。

> a 通过 b 到达 c，那么 a 需要告诉 b 自己没有任何到 c 的路径。

### 4.5.3 链路状态路由算法“link state” algorithms

链路状态路由算法要求每个参与该算法的节点都有完全的网络拓扑信息，它们执行下述两项任务。

:one: 主动测试所有邻接节点的状态。两个共享一条链接的节点是相邻节点，它们连接到同一条链路

:two:定期地将链路状态传播给其他所有节点

#### Dijkstra 算法（重要）

**概述**

> 网络拓扑结构，所有节点都知道链路开销
>
> 通过“link state broadcast”完成所有节点都有相同的信息
>
> 计算从一个节点(“源”)到所有其他节点的最小开销路径
>
> 迭代:经过k次迭代，知道到达k dest的最小代价路径

**符号**

> C (x,y):节点x到y的链路开销;如果不是直接邻居=∞
>
> D(v):从source到dest的路径开销的当前值
>
> P (v):从源到v路径上的<mark>**前继节点**</mark>
>
> N':已知最小代价路径的节点集合

**算法伪代码**

```c
Initialization: 
 N'= {u}
 for all nodes v 
 if v adjacent to u 
 then D(v)= c(u,v)
 else D(v)= ∞
 Loop 
 find w not in N such that D(w) is a minimum 
/*在集合N'之外找离结点最近的结点w*/
 add w to N'
 update D(v) for all v adjacent to w and not in N': 
 D(v)= min( D(v), D(w)+ c(w,v))
 until all nodes in N'

```

![image-20220331173311285](https://telegraph-image-5ms.pages.dev/file/AgACAgUAAyEGAASIfjD1AAPvaJjEHbC1eCkrTP9qVvTa0zwjMDEAAn_KMRvyaslUH_NakSEkOlkBAAMCAAN5AAM2BA.png)

**时间代价**

> 算法复杂度:n个节点
>
> 每次迭代:需要检查所有节点w，而不是N
>
> n (n +1)/2的比较: $O (n^2)$
>
> 更有效的实现：$O(n\text{logn})$——优先队列
>
> 可能会产生振荡:
>
> 例如，链路成本=承载的流量

每个路由器在运行Dijkstra算法时会引入随机延迟

### 4.4.4 LS 算法和 DV 算法的比较

DV 和 LS 算法采用互补的方法来解决路由选择计算问题。在DV算法中，每个节点仅与它的直接相连的邻居交谈，但它为其邻居提供了从它自己到网络中（它所知道的）所有其他节点的最低开销估计。LS算法需要全局信息。因此，当在每台路由器中实现时，每个节点（经广播）与所有其他节点通信，但仅告诉它们与它直接相连链路的开销。我们通过快速比较它们各自的属性来总结所学的链路状态与距离向量算法。记住N是节点（路由器）的集合，而E是边（链路）的集合。

**报文复杂性**。我们已经看到**LS算法**要求每个节点都知道网络中每条链路的开销，这就要求要发送$O(|N||E|)$个报文。而且无论何时一条链路的开销改变时，必须向所有节点发送新的链路开销。DV算法要求在每次迭代时，**在两个直接相连邻居之间交换报文**。我们已经看到，算法收敛所需时间依赖于许多因素。当链路开销改变时，DV算法仅当在新的链路开销导致与该链路相连节点的最低开销路径发生改变时，才传播已改变的链路开销。

**收敛速度**。我们已经看到LS算法的实现是一个要求$O(|N||E|)$个报文的$O(|N|^2)$算法。**DV 算法收敛较慢（尤其对于坏消息），且在收敛时会遇到路由选择环路。**DV 算法还会遭遇无穷计数的问题。

**健壮性 Robustness**：如果一台路由器发生故障、行为错乱或受到蓄意破坏时情况会怎样呢？

> LS 算法：节点可以通告错误的**链路link开销**；每个节点只计算自己的转发表
>
> DV 算法：节点可以通告不正确的**路径path开销**；每个节点的表被其他节点使用；错误通过网络传播

两个算法都有在使用。

## 4.6 路由选择

世界上可能有数百万台路由器，不可能将全世界的路由器构成一个拓扑图。通常，我们说“全局”路由器，是指一片较大区域内的所有路由器构成的系统。

路由器聚合成区域形成自治系统，简称为 AS：Autonomous System

> 为什么叫自治呢？因为不同区域的服务商不同，因此归属不同

> 同一 AS 内的路由器运行相同的路由协议：**内部网关协议**（Interior Gateway Protocols **(IGP)**）
>
> 不同 AS 中的路由器可以运行不同的 AS 内路由协议
>
> 不同 AS 之间相互连通的路由器称为**边界网关**，这种路由器上运行了**边界网关协议 BGP：border gateway protocol**，所有的边界网关运行相同的 AS 间路由选择协议
>
> 一个自治系统由其全局唯一的AD号（ASN）所标识

网关路由器 gateway router：直接连接到另一个 AS 中的路由器（和其他 AS 路由器相邻的路由器）

边界网关需要维护两个路由表：自己 AS 中的内部路由表，和如何从此服务器到达其他 AS 中路由器的路由表。称为 Intra-AS 和 Inter-AS 路由表。

### 4.6.1 路由选择

假设 AS1 中的路由器接收到一个需要发送到 AS1 以外的数据报。路由器应该将数据包转发到网关路由器，但是选择哪一个网关呢?

AS1 所需要做:

> :one: 了解哪些路由可通过 AS2 访问，哪些路由可通过 AS3 访问
>
> :two: 了解后，将此可达性信息传播到 AS1 中的所有路由器

![image-20220413164511378](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPwaJjEKuYrjJpvQkjT-kAYTvOI4sMAAm0WAALyaslUGQk7TO8dv2A2BA.png)

#### 单个网关路由选择

![image-20220413164802258](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPxaJjEOF_QnEW7z9vGG_wXM7fFmeMAAm4WAALyaslUvNxaCX9NXLs2BA.png)

假设 AS1 得知子网 x 可通过 AS3(网关1c)到达，但不能通过 AS2 到达。跨网关协议将可达性信息传播到所有内部路由器。路由器 1d 根据内部 AS 的路由信息确定其接口 $I$ 在通往 1c 的路径上的开销最小（跳数短）：于是添加转发表项(x,I)

#### 多个网关路由选择

![image-20220413165021877](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPyaJjESND-VgtUf_gOjti8aM6w_GIAAm8WAALyaslUdtx5qd9WbCA2BA.png)

现在，假设 AS1 从内部 AS 协议中得知子网 x 可以通过 AS2 和 AS3 到达。

要配置转发表，路由器 1d 必须确定将目的为 x 的数据包转发到哪个网关，选择 1b 还是 1c？

#### 确定最好的路由

##### 热土豆路由选择

> “热土豆”类似于“烫手山芋”，就是说路由器想以最快速度把数据报送出其所在的 AS，至于其他 AS 到最终位置哪个更近，它不关心。

热土豆路由选择依据的思想是：对于路由器 1d，尽可能快地将数据报送出所在 AS(更明确地说，用可能的最低开销)，而不担心其 AS 外部到目的地的余下部分的开销。

简单来说，就是选择本 AS 内离自身最近的网关，忽略网关到目的地址哪个更近。

在路由转发表中增加AS外部目的地的步骤如下

> :one: 从AS间协议得知经多个网关可达子网x
>
> :two: 使用来自AS内部协议的路由选择信息，以决定到达每个网关的最低开销路径的开销
>
> :three: 热土豆路由选择：选择距离自身开销最低的网关
>
> :four: 从转发表确定通往最低开销网关的接口I，往转发表中添加表项转发表项(x,I)

> 如上图，1d离1b比较近就选择1b转发

### 4.6.2 内部网关协议 IGP

常见的内部网关协议 IGP 如下

> **RIP：Routing Information Protocol 路由信息协议**
>
> **OSPF：Open Shortest Path First 开放最短路径优先**
>
> EIGRP：增强内部网关路由协议(Cisco专有)
>
> IS-IS:Intermediate System to Intermediate System,RFC 1122

#### RIP——路由信息协议

内部网关协议的一种

> :one: 使用距离矢量算法，认为内部任意两个相邻路由器之间的代价都是 1。
>
> :two: AS 内部最远的两点的距离不超过 15 跳，即直径不超过 15 跳
>
> :three: 每 30 秒将距离矢量广播给邻居
>
> :four: AS 周长不超过 25 跳（每次广播时的跳跃次数不超过 25 次）
>
> :five: 180 秒内没有收到来自邻居的信息，则认为跟邻居的链路断开了，BF方程重新进行计算
>
> > 链路故障的信息会很快传播给整个AS
>
> :six: 如果有多条最优路径，选择其中的一条走

大小限制：直径不超过 15 跳，周长不超过 25 跳。

![image-20220413195015871](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAPzaJjEWxOT4rsZT7jDEEQRT5EH0-YAAnAWAALyaslUUkJ3GAWHJ_M2BA.png)

更新方式：路由器 x 向自己的邻居 y 广播最短距离（30 秒一次，或者最短距离变化时立刻广播）。邻居 y 取到外部路由 z 的最短距离为 min(y->z, y->x + x->z)，其中 x->z 的代价是 x 广播给 y 的。

> RIP 是一种典型的距离向量（DV）路由协议。

RIP 路由表由应用程序级进程route-d (daemon)管理

> route-d工作在应用层
>
> 路由表在网络层

报文类型为UDP，周期性重复，端口为520

![image-20220413200017142](https://telegraph-image-5ms.pages.dev/file/AgACAgUAAyEGAASIfjD1AAP0aJjEXmR2QuDjfbKNQPoy2aU4ak0AAoDKMRvyaslUF8LIbp5gzkwBAAMCAAN4AAM2BA.png)

#### OSPF——开放最短路径优先

内部网关协议的一种，核心为**链路状态算法**。

:one: 使用链路状态算法

> 使用链路状态数据包传播
>
> 需要维护每个节点的拓扑图
> 
> 使用Dijkstra算法进行路由计算

:two: 周期性地广播自己跟谁连，代价是多少，广播给整个 AS，周期通常是30分钟。

:three: 报文直接封装在 IP 的报文中，**OSPF 协议直接运行在网络层上部**，也是不可靠的协议（没有传输层做保护）

**OSPF的优势（相较于RIP)**

> :one: 安全性：两个路由器通信之前先对路由器进行认证 authenticated，避免恶意入侵
>
> :two: 两点之间允许多条等价的最优路径，都可以走(RIP 中只记录一条最短路径)
>
> :three: 对同一条链路，传送不同业务时配置的代价可以不一样
>
> :four: 集成单播和多播支持，支持多播协议
>
> :five: AS比较大时可以使用分层OSPF：各自在各自的domain中运行OSPF协议

### 4.6.3 BGP 边界网关协议

> Border Gateway Protocol

AS 之间的路由协议只有一个：BGP 边界网关协议

> 不像 AS 内部存在 RIP 和 OSCP 两种协议

采用路径-矢量（DV）协议

> 边界网关维护的一般不是路由表而是路径表

BGP 为每个 AS 提供了一种方法:

> :one: 向邻居应用服务器获取子网可达性信息。
>
> :two: 将可达性信息传播到所有 AS 内部路由器。
>
> :three: 根据可达性信息和策略确定到外部 AS 的“好”路径。

允许**AS**向他的上一跳广播：我在这

**使用半永久的TCP连接**，可以通过会话（应用层）报文关闭。因此这个协议可能算一个传输层协议。

当 AS2 告知 AS1 自己可以连接到某个外部路由器 x 时：

- AS2 承诺自己可以转发包到 x
- AS2 可以

AS1 会将这个信息（AS2 可以转发前往 x 的数据报）发送到自己内部的所有路由器上，更新其路由表。

**路由选择**

> 根据本地的喜好制定策略，策略的优先级高于路径矢量算法
>
> 缺省时使用最短的路径
>
> 热土豆准则

**BGP 的四种报文**

> OPEN 报文：与相邻的另一个 BGP 路由器建立链接，相互认证
>
> UPDATE 报文：用于发送某一路由的信息，列出要撤销的路径信息（更新路径信息）
>
> KEEPALIVE 报文：用于确认打开报文和周期性地证实邻居关系
>
> NOTIFICATION 报文：报告报文错误以及用来关闭 TCP 连接

### 4.6.4 RIP、OSPF、BGP比较

| 主要特点     | RIP                                                      | OSPF                                               | BGP                |
| ------------ | -------------------------------------------------------- | -------------------------------------------------- | ------------------ |
| 网关协议     | 内部                                                     | 内部                                               | 外部               |
| 路由表内容   | 目的网络，下一跳，距离                                   | 目的网络，下一跳，距离                             | 目的网络，完整路径 |
| 最优通路依据 | 跳数                                                     | 费用                                               | 多种有关策略       |
| 算法         | 距离-矢量算法                                            | 链路状态算法                                       | 路径-矢量算法      |
| 传送方式     | UDP                                                      | IP数据报                                           | TCP连接            |
| 其他         | 简单，效率低，跳数为16不可达，好消息传得快，坏消息传得慢 | 效率高、路由器频繁交换信息，难以维持一致性；规模大 |                    |



## 练习题

1、Which of the following are features of the Internet Protocol (IP)? (Choose two.)

> It is the most widely implemented global addressing scheme.:+1:
>
> It allows two hosts to share a single address on a local area network.
>
> It is a hierarchical addressing scheme allowing addresses to be grouped.:+1:
>
> It is only locally significant, used primarily on local area networks.

2、Which OSI layer defines the functions of a router?

>  physical 
>
>  data link 
>
>  network :+1:
>
>  transport 
>
>  session 

3、Which part of an IP address identifies a specific device on a network?

> first two octets 
>
> third and fourth octets 
>
> network portion 
>
> host portion :+1:
>
> only the fourth octet 

4、Which of the following will test the internal loopback of a node?

> ping 10.10.10.1 
>
> ping 192.168.1.1 
>
> ping 127.0.0.1 :+1: 
>
> ping 223.223.223.223 
>
> ping 255.255.255.255

5、Which protocol functions at the internet layer of the TCP/IP protocol suite?

> File Transfer Protocol (FTP)
>
> Trivial File Transfer Protocol (TFTP)
>
> Transmission Control Protocol (TCP)
>
> Internet Protocol (IP):+1:
>
> User Datagram Protocol (UDP)
>
> Simple Mail Transport Protocol (SMTP)

6、Using the IP address 38.159.163.37 with a subnet mask 255.255.255.240, determine the subnetwork address.

> 38.159.0.0 
>
> 38.159.163.0 
>
> 38.159.163.0 
>
> 38.159.163.16 
>
> 38.159.163.32 :+1:
>
> 38.159.163.36 

7、A company with a Class B license needs to have a minimum of 1,000 subnets with each subnet capable of accommodating 50 hosts. Which mask below is the appropriate one?

> 255.255.0.0 
>
> 255.255.240.0 
>
> 255.255.255.0 
>
> 255.255.255.192 :+1:
>
> 255.255.255.224 

8、Which of the following are Cisco proprietary routing protocols? (Choose two.)

> RIPv2 
>
> IGRP :+1:
>
> OSPF 
>
> BGP 
>
> RIPv1 
>
> EIGRP :+1:

9、When a network administrator applies the subnet mask 255.255.255.248 to a Class A address, for any given subnet, how many IP addresses are available to be assigned to devices?

> 1022 
>
> 510 
>
> 254 
>
> 126 
>
> 30 
>
> 6 :+1: 

10、Which OSI layer encapsulates data into packets?

> session 
>
> transport 
>
> network :+1: 
>
> data link 

## 参考资料

[1] James F.Kurose，Keith W.Ross.Computer Networking—A Top-Down Approach（第6版）.北京：高等教育出版社出版者，2013年。

[2] 西安交通大学Computer Networking2022年春 课程PPT 朱利

[3] 天勤第11版 2023版计算机网络高分笔记