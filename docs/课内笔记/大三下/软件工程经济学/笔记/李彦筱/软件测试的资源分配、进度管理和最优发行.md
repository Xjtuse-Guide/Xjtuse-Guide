# 第七章 软件测试的资源分配、进度管理和最优发行

本章中只有第一节：软件测试与可靠性增长是必考的内容，剩下的三节是“自学”的（就是不考的）

## 软件测试与可靠性增长

软件测试的目标：希望以最少的人力费用和时间发现潜在的各种差错和缺陷，以期望进行改正。

软件测试的分类：（P216）静态测试，黑盒测试、（P217）白盒测试，单元测试，集成测试

四种软件测试（单元测试、集成测试、验收测试、运行测试）的比较：P222

### 软件的可靠性增长模型（重点）

我们认为，软件在编写完成后的差错数就不会增加了。随着集成测试和验收测试的进行，差错一个个被修复，因此软件中的差错将会越来越少，可靠性越来越高。因此，软件的**可靠性是逐步增长的**。

我们将会介绍一些软件可靠性模型：G -O模型，SPQL模型和基于测试人力的可靠性增长模型

G-O 模型的基本出发点是对软件的量测与排错将无限制地延续下去，并认为差错的查出与排错累计过程是一个非时齐的泊松过程(NHPP)

> 非时齐：事件发生频率不恒定的泊松过程

### G-O 模型

假设：

1. 差错随机地存在于程序中，无法得知差错存在于何处；在一段运行时间区间内可以发现的差错数量是**时间区间长度的正比**，是**剩余差错数量的正比**，比例系数设置为 b

2. 在排错过程中，差错的累积计数过程是一个非时齐的泊松过程。

   必须了解“非时齐”：指由于找到差错的数量和剩余差错数量成正比，且剩余差错数量不断减小，刚开始剩余差错多，因此单位时间找到的差错数量多；后面剩余差错少，找到差错的速度越来越慢

3. 修复差错时不会引入新的差错

4. 前后出现的差错没有关联

N(t) 表示 (0, t) 时间内查出的差错数量，由于每个差错找到的时间都不确定，因此 N(t) 为一个非时齐泊松过程。假设 $\lambda(t)$ 是泊松分布的强度函数（不需要理解强度函数是什么意思），m(t) = $\int_0^t \lambda(t)dt$，即从 0-t 时刻 $\lambda(t)$ 的积分。可以证明（总之就是定理），m(t) = E(N(t))（即 m(t) = N(t) 的期望，m(t) = t 时间内期望可查出的差错数量），因此 m(t) 就是 (0, t) 内查出的累积差错数，$\lambda(t) = \frac{dm(t)}{dt}$ 因此可以看成单位时间内可找出的差错。

我们设 a 为软件中的差错总数，那么 t 时刻还没有找到的差错数就是 a-m(t)。由于找到差错的数量和尚未找到的差错数成正比（且比例系数为 b），因此：
$$
\lambda(t)=\frac{dm(t)}{dt}=b(a-m(t))
$$
解这个微分方程，就可以得到结论：

1. m(t) 和 $\lambda(t)$ 的表示：
   $$
   m(t)=a(1-e^{-bt})
   $$
   b 为比例系数
   $$
   \lambda(t)=abe^{-bt}
   $$
   可以看出，在 t->无穷时，m(t) 趋于 a，说明只要时间足够，我们可以找到软件中的所有差错；

   $\lambda(t)$ 是随时间 t 指数下降的，表示发现每个 bug 的速度呈指数下降，发现每个 bug 消耗的时间呈指数上升。 因此，我们没有必要找到软件中的所有 bug，只要软件的可靠性达到 95% 或者 98% 就可以交付了。

2. 如果软件的排错过程无限持续下去，其最终查出的累计差错数具有均值为 a 的泊松分布，是不确定的。

   > 均值为 a 就代表总差错数为 a 的概率是最大的

3. 在 t 时已查出 d 个差错的条件下，t 时的剩余差错数仍然服从泊松分布，且数学期望为：
   $$
   E(N(t, \infin)|N(t)=d)=a-m(t)=ae^{-bt}
   $$
   即具有无记忆性，已经查出部分差错后，剩余差错数仍然服从泊松分布。

4. 软件可靠度的计算：R(t|T)=P(Xn>t|Sn-1=T)=
   $$
   R(t|T)=exp\{-a(1-e^{-bt})e^{-bt}\}
   $$
   外层的 exp 也是 e^n^ 的意思。一般可靠度都取小 t =1（单位时间），但如果题目中要求你给出几天内的可靠度的话，t 就取几。	

如何估计参数 a（软件总差错）和 b（剩余差错数正比的系数）呢？可以采用最大似然估计：

最终得到：
$$
a=\frac{d_n}{1-e^{-bt_n}}
$$
tn 是指最后一段检查差错的时间区间，dn 是指总共检查出的差错数量。a 仅仅和最后一次检查的耗时/差错数量有关，和之前的几次差错寻找过程无关。

ti 表示（0,ti）这段时间，而 di 表示（0,ti）时间内（即从开始到 ti 事件）出现的差错数量。

![image-20250604091149264](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAIBTGibUUhsLqARXzu2lLcZEh2zPLnhAAJbGgACnTzhVJrRh2rooy9iNgQ.png)

可靠性目标：
$$
T=\frac{1}{b}[lnm(t)-ln ln\frac{1}{R_0}]
$$
R0 为目标可靠度。

一般 $\hat{b}$ 都不会让你算，因为根本算不出来。

剩余未提到的结论见 P224

### 扩展 G-O 模型

这里我们认为，软件每个时刻发现的差错不一定会被修正，p 为 t 时刻被发现的差错完全修正的概率（因此 1-p 是没法修正差错的概率）。在这种情况下，公式发生了变化：
$$
m(t)=\frac{a}{p}(1-e^{-bpt})
$$
前面的 1/p 是因为只有 p 的概率修正差错了，因此 a 变为 a/p，a 变大了（相当于差错总数增加）
$$
\lambda(t)=abe^{-bpt}
$$
指数部分修改了。

t 时刻已找到 d 个差错后，t 时的剩余差错数的期望仍然是：
$$
E(N(t, \infin)|N(t)=d)=E(N(t, \infin))=\frac{a}{p}e^{-bpt}
$$
注意这里已经找到 d 个差错和没找到差错后，剩余差错的期望是不变的。

可靠度：
$$
R(t|T)=exp\{-\frac{a}{p}(1-e^{bpt})e^{-bpt}\}=exp\{-m(t)\times e^{-bpt}\}
$$
参数估计：
$$
a=\frac{np}{1-e^{-bpt_n}}
$$
n：总计发现的差错数量；tn：最后一次检查差错的时刻。
$$
\frac{n}{b}=p\sum_{j=1}^nt_j+\frac{npt_n}{e^{bpt_n}-1}
$$
其中 p 取 0.1, 0.2, 0.3, ..., 1.0 即可

实际题目中，我们会发现对于多个 dn 和 tn（多次差错检查的时间/差错个数） a/p 是不变的，b\*p 也是不变的。

大部分情况下，取 t=1（即计算可靠度时，计算单位时间内不出现故障的概率）

可靠性时间：（其中 R0 为目标可靠度，t 一般取 1）
$$
T=\frac{1}{bp}[lnm(t)-ln ln\frac{1}{R_0}]
$$
剩余结论见 P225。

## 软件产品质量水平评价模型

如何评价软件测试的效果？是否测试了正确的内容？

P228 后半页