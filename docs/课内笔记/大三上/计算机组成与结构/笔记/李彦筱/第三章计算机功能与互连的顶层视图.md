# 计算机功能与互连的顶层视图

> 易俊泉学长的原始笔记链接如下：
>
> [chapter03计算机功能与互连](docs/课内笔记/大三上/计算机组成与结构/笔记/易俊泉/chapter03计算机功能与互连.md)

## KEY POINTS

1. 取指周期和执行周期的操作，理解简单的计算机指令执行模型

2. 中断、中断子周期和多重中断的处理方法

3. 总线的概念、系统总线的分类，总线的仲裁方式和通信方式

   > 第三部分内容应该是线上学习的，但这并不代表它不重要。一定要认真看网课。

## 计算机组件

硬件编程：根据我想运行的程序，连接不同的基础逻辑组件，搭建出一个能执行我的程序的电路。

![image-20240918102557181](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAMeZ6DXblJTyWOxxWDOfwcib3qwn8cAAvQXAAK0lAhVXQq3uUUdHv02BA.png)

这种方法的缺点时：每种电路只能用于运行一种程序；如果我想让硬件执行另一个程序，需要重新连线。程序员瞬间变成硬件工程师了（

软件编程：把所有可能用到的逻辑运算元件封装成一个模块（称为通用算术和逻辑功能），通过向模块发送控制信号，让模块执行需要执行的操作。由于程序的指令无法与控制信号完全对应，需要一个指令解释器把程序员的指令转化为具体的控制信号。

![image-20240918102622979](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAMfZ6DXfdDR8NQ96KSmtDa77N1khnQAAvUXAAK0lAhV8TpO0uWgcdk2BA.png)

优点：通用性好，程序员终于不用自己焊电路板了。

缺点：需要一个指令解释器解释，速度比起硬件编程更慢。

软件编程的工作原理和 CPU 有些相似。通用算数与逻辑功能模块类似现在 CPU 中的 ALU，指令解释器类似 CU，整体结合起来，就是 **CPU** 的雏形。

![image-20240918102635386](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAMgZ6DXi4IaLWacfd_Pr292WHhXniAAAvYXAAK0lAhVpcBKjH4POyE2BA.png)

在实际运行中，我们需要一个设备持续的为 CPU 输入指令和数据，输出结果。这种设备就是 **I/O设备**。

程序并不总顺序执行指令，可能存在跳转；因此，我们需要一个组件临时存储指令和数据，这个组件就是 **内存**。

内存的大小一般由「内存单元数」和「每个内存单元空间」决定。二者的乘积才是内存的总大小。内存所使用的编码位数 x 应当满足：$2^x$ 大于或等于内存单元数。比如，一块内存具有 128M 个内存单元，则其编码位数应当至少为：$log_2(128) + 20（1M = 2^{20}） = 27$ 位。

## 计算机功能

计算机的基本功能是**执行程序**（一串指令序列），CPU 是指令的实际执行者。

一条指令执行涉及不同操作，并且可能*占用 CPU 的多个时钟周期*。不同指令占用 CPU 的时间*不同*。我们把一条指令处理的时间称为**指令周期**。指令周期由两段组成：**取指周期**和**执行周期**。

取指周期：CPU 获取指令并将其翻译成控制信号（译码）所需的时间

执行周期：实际执行指令需要花费的时间

### 指令的读取和执行

**取指周期**：

- 处理器从 PC（Program Counter，程序计数器）指向的位置读取一条指令
- 将 PC 加一（使其指向下一条指令）
- 将指令加载到处理器中的指令寄存器 IR 中
- 处理器解释指令并执行操作

**执行周期**：

处理器解释指令后，执行的操作可能分为如下几类：

这四类操作对应了计算机的四大功能。

>:one: **处理器—存储器（数据存储）**:数据可从处理器传送到存储器或从存储器传送到处理器。
>:two: **处理器—I/O（输出移动）**:通过处理器和I/0模块之间的传输，数据可传送到或来自外部设备。
>:three: **数据处理**:处理器可以对数据执行一些算术或逻辑操作。
>:four: **控制**:指令可以用来改变执行顺序。（通过改变 PC）

**举例说明**，使用一台包含下图所列特点的假想机器，其处理器包含唯一的一个数据寄存器，被称为累加器 (AC); 其指令和数据都是 16 位长，且都存储在 16 位长的存储器中。在 16 位指令中，操作码占用4 位，表示最多可以有2 ^ 4= 16 种不同的操作码。地址码占用 12 位，最多有 2^12 = 4096(4K)个字的存储器可以直接寻址。

> PC：程序计数器，存储正在执行的指令的地址
>
> IR：指令寄存器，存储正在执行的指令
>
> AC：临时存储当前指令结果
>
> IR 的长度和指令长度一样（都是 16 位）；AC 长度和数据长度一样（都是 16 位）；PC 长度和指令中地址码的长度一样（12 位）

![在这里插入图片描述](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img5/602e0aed12284bf6a7c2cd82666b0b10.png)

> 为了简便起见，下面的所有数字都是 4 位二进制缩成 1 位 16 进制表示的。也就是说，“1940”，”5941“等数字都是 16 进制的数字。

![在这里插入图片描述](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img5/405356687d094ef088753f5eaf62863b.png)

在上面的机器中，指令及其含义如下：

- 1：取地址码位置的数字，存储到 AC 中
- 2：将 AC 的值写入地址码指示的位置
- 5：将地址码位置的数字和 AC 中缓存的数字相加

:one: 程序计数器 (PC) 的内容是300，即第1条指令的地址。这条指令(其值为十六进制数1940)被装入指令寄存器 IR 并且 PC 加 1。注意,为简便起见，忽略对存储器地址寄存器(MAR) 和存储器缓冲寄存器(MBR)的使用

> 由于这是十六进制的，所以 PC +1 其实是加了 16 位。由于一个内存单元大小是 16 位，这样正好让 PC 指向了下一个内存单元。

:two: **IR中的前4位(第1个十六进制数字)指出要装入累加器(AC)，而其余12位(3个十六进制数字)指定从那个地址(940) 取数据装载**。即地址 940 的数据 0003 装入 AC。

:three: 从单元 301 中取下一条指令 (5941)， 并且 PC 加 1。

:four: AC 中存放的内容和 941 单元的内容相加，结果放入 AC。

> 注意：指令地址码存储的是操作数的位置，而不是操作数本身，千万不能算成 3+941=944 了

:five: 从单元 302 中取下一条指令 (2941)， 并且 PC 加 1

:six: 将 AC 的内容存入 941 单元。

在现实中，指令周期可能比这个简单的例子更加复杂，比如操作数的地址可能需要 CPU 通过 I/O 获得而非直接给出。下面给出了一个基本指令周期更详细的视图：

基本的指令周期所需的状态如下：

:one: **指令地址计算(Instruction address calculation)**: 决定下一条将要执行的指令的地址。通常是将一个固定的值与前一条指令的地址相加。例如，如果每条指令有16位长，并且存储器是由 16 位字构成的，则将原地址加 1;如果存储器是由可独立寻址的 8 位字节构成的，则将原地址加 2。

:two: **读取指令(Instruction fetch)**:将指令从存储器单元读到处理器中。

:three: **指令操作译码(Instruction operation decoding)**: 分析指令,以决定将执行何种操作以及将使用的操作数。

:four: **操作数地址计算(operand address calculation)**: 如果该操作包含对存储器或通过 I/O 的操作数访问，那么决定操作数的地址。

:five: **取操作数(Operand fetch)**:从存储器或从 I/O 中读取操作数。

:six: **数据操作(Data operation)**: 完成指令需要的操作。

:seven: **存储操作数(Operand storage)**: 将结果写人存储器或输出到 I/O。

![image-20240918112214252](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAMhZ6DXnYYyH78dY1fJx65l3GVjQRAAAvcXAAK0lAhVjPKm5J-GMvE2BA.png)

> 和流程图中不同，在实际中，译码和操作数地址的计算是同时完成的；取操作数晚于这两个操作。

### 中断

中断是一种机制，允许其他模块**中断** CPU 的正常处理。中断可以让 CPU 在需要 I/O 时提高处理效率，同时允许 CPU 处理紧急情况（比如突然断电，模块损坏等）

**常见的中断类型**：

| 中断类型 | 产生的原因                          | 备注                                 |
| -------- | ----------------------------------- | ------------------------------------ |
| 程序     | 程序出现异常，比如除0、越界访问内存 | 这就是操作系统课上提到的「软件中断」 |
| 定时器   | CPU 内部计时器产生中断              | OS 课上也提到过                      |
| I/O      | I/O 控制器生成                      |                                      |
| 硬件故障 | 硬件出现故障，比如断电、磁盘错误    |                                      |

> 定时器中断：用于多道程序，这种中断是为了防止某程序永远占用 CPU，导致无法切换到管态

下图说明了事件的这种状态。用户程序执行一次 I/O 调用，I/O 调用与处理过程
交错进行。代码段 1、2、3 是指不包含 I/O 操作的指令序列。

![image-20240918113623562](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAMiZ6DXrb9zwxRYZIfdJ-xQRiso9YYAAvgXAAK0lAhV9mDQpyHfWyo2BA.png)
这段I/0程序包含以下三个部分:

:one: 用于为实际 I/O 操作**准备的指令序列**，在图中标记为4。它可能包括将待输出数据复制到专用的缓冲区，以及为设备命令准备参数。

:two: **实际的 I/O 命令**。如果没有中断的使用，一旦此命令发出，程序必须等待 I/O 设备完成需要的功能( 或周期性地测试设备)。程序可以通过简单地重复执行一个测试操作来决定该 I/O 操作是否完成。

> 就是图中「I/O Command」那一块表示的命令

:three: **完成该操作的指令序列**，在图中标记为 5。执行完这段指令后，I/O 操作就完成了

在没有中断时（第一张图）， I/O Command 期间，CPU 只能不断轮询 I/O 设备，检查 I/O 是否完成，而不能执行用户程序，简直太浪费了！

在存在中断、I/O 耗时短（第二张图）中，CPU 完成 4 后立刻返回执行用户程序，I/O 设备自己执行 I/O Command；完成后，中断处理器打断用户程序的执行，CPU 先完成 5 这部分 I/O 收尾指令，再返回继续执行用户程序。

#### 中断及其指令周期

在中断发生时，CPU 需要完成以下操作：

- 挂起当前正在执行的程序，保存现场（当前 PC、PSW、通用寄存器的值）
- 将 PC 指向中断服务程序的首地址

用户程序无需为了应对中断编写代码；处理器和操作系统负责挂起和完整的恢复用户程序。

> 中断的意义就是：允许处理器和 I/O 设备同时运行，CPU 无需等待 I/O 设备，节约了时间。
>
> CPU 和 I/O 设备在中断时的关系可以看作某种「回调」： I/O 设备向 CPU 发送消息，CPU 响应消息并且执行特定代码（中断服务程序）

出现中断这个概念后，CPU 每个指令周期的末尾添加了对是否发生中断的检查。如果没有中断，CPU 会直接进入下一个指令周期。否则，CPU 会额外执行以下操作：

- 挂起当前执行的程序，保存其上下文（当前 PC、PSW、通用寄存器的值）
- 将 PC 指向中断服务程序的首地址

中断处理程序执行完成后，CPU 恢复之前保存的上下文，并进入新的指令周期。

> 执行中断服务程序可能需要多个时钟周期。每个周期中 CPU 的工作和正常工作一样（毕竟都是执行指令么）

添加了中断检查后的指令周期：

![image-20240918115915493](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAMjZ6DXu-08alHp3Szv8kDuXIfKAfAAAvkXAAK0lAhV33vtmpLSyug2BA.png)

#### 多重中断

**概念**：顾名思义，多重中断就是在同一时间发生多个中断

对于多重中断，有两种解决办法：**禁止中断与定义优先级**

:one: 禁止中断（disable interrupts）

禁止中断就是在中断处理过程中禁止其他中断，此时的中断严格按照顺序处理，等一个中断处理完成以后不用等到用户程序恢复就可以再次允许中断

![image-20240923164143744](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAMkZ6DXyvWnJNr_1SPz-PeQUqSUIjcAAvoXAAK0lAhVVCWY1-fDwYQ2BA.png)

这是禁止中断情况下的程序执行顺序。当一个中断发生时，系统会立即禁止处理其他中断，随后开始处理这个中断；处理完这个中断后，如果在处理期间出现了新的中断，CPU 会立即再次发起一个中断。

---

第二种处理多重中断的方法就是定义中断的优先级，允许优先级高的中断引起低级中断处理程序本身被中断：

![image-20240923164341458](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAMlZ6DX208iHRPZk_9NF1ndRFXJ77kAAvsXAAK0lAhVfD_KvMGJB4s2BA.png)

打断中断服务程序的流程和打断用户程序的流程一样：都是挂起当前程序，保存 PC、PSW、寄存器，将 PC 指向新的中断服务程序的首地址。

**举例说明**：一个有 3 个 I/O 设备的系统:打印机、硬盘和通信线路，它们的优先级逐个递增，分别是 2、4、5。

1. 用户程序开始于 t=0 时刻。当 t=10 时，发生了打印机中断，用户信息放入系统栈，并继续从打印机的中断服务程序（ISR）开始执行。

2. 当打印机的中断服务程序仍在执行时，在 t=15 时刻，通信中断发生。由于通信线的优先级比打印机高，这个中断得到响应。打印机 ISR 被中断，它的状态压入栈，继续从通信 ISR 执行。

> ISR 是中断服务例程（即中断服务程序）的英文简称

3. 当这个通信 ISR 正在执行时，发生了磁盘中断(t=20)。由于它的优先级相对较低，只好挂起，而通信 ISR 持续运行到结束。

4. 当通信 ISR 完成时(t=25), 原来的处理器的状态恢复，先返回到打印机的中断服务程序。但是在打印机程序一条指令都没来得及执行前，处理器响应了之前挂起的、优先级更高的磁盘中断，将控制权传送给磁盘 ISR。

5. 当磁盘 ISR 结束后(t=35)， 打印机的 ISR 才恢复。在它完成后(t=40),控制权才最终交还给用户程序。
   ![image-20240923164528090](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAMmZ6DX6LnsJNsKdTA6DIrqnNtP338AAvwXAAK0lAhValcOnu8AAWIBNgQ.png)

可以看出，具有中断优先级后，中断之间可以无限相互打断，只要打断的中断的优先级高于被打断的中断即可。

### I/O 功能

I/O 组件的主要功能包含两部分：

- I/O 模块和处理器直接交换数据
- I/O 模块直接与内存交换数据。处理器可以让 I/O 模块在不经过 CPU 的情况下进行 I/O 与内存的传输，称为直接内存访问（Direct memory access, DMA）



## 计算机的互连结构

### 互联结构的定义

**互连结构**：连接各个模块的通路

每个模块大致需要的输入、输出端口如下：

- 内存

  内存应当可以读写，因此有两个使能信号 Read 和 Write 决定目前正在读取还是写入。内存一般由 N 个大小相同的字组成。

  如果是读取状态，则 CPU 传入一个地址，内存传出该位置的数据。如果是写入状态，则 CPU 传入地址和数据，内存在对应地址写入数据。

  ![image-20240923165637209](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAMnZ6DX9PzaJgk6HGqhHIwOX96h0GQAAv0XAAK0lAhVvc_0Ee8ylFE2BA.png)

- I/O 模块

  I/O 模块。

  I/O 模块和主存最大的区别在于 I/O 模块可以主动发起中断。这是因为 I/O 模块和 CPU 的运行速度相差较大，为了避免 CPU 和 I/O 交互时影响 CPU 的速度，一般采用中断形式进行交互。

  ![image-20240923165934940](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAMoZ6DYASznIid9yxHMwAaGUxtRUOwAAv4XAAK0lAhVaTrA6p3NlDI2BA.png)

- CPU 

  CPU 需要指令、数据以执行指令。它还可以接受中断信号。在输出时，CPU 可以输出控制其他设备的信号，向主存输出它想取的地址，还有运算后的数据。

  ![image-20240923165944681](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAMpZ6DYFiOdfOu3VNTjO9WWGobcd_IAAv8XAAK0lAhVf0xkh8mKMd82BA.png)

由上图可知，互连结构必须支持下列类型的传送

存储器到处理器、处理器到存储器、I/O到处理器、处理器到I/O、I/O与存储器之间(可以使用**DMA**直接存储器来实现)。

在很久很久以前，CPU、主存和 I/O 模块之间都是直接连接对应端口。但后来，人们觉得这样连接实在是太乱了，就有了总线连接。

### 总线与总线结构

**总线**：连接两个或两个以上设备的通信线路

**总线传输的特点**：**共享传输介质**。由于总线只有一条，多个部件不能在总线上同时发出信息，否则信息会相互干扰。因此规定，某一时刻，只允许由一个部件向总线发送信息，而多个部件可以同时从总线上接受相同的信息。

一个总线中可以有多个数据通路。有多少数据通路，就可以同时传输多少位的数据。

**总线总类**：系统总线、外围总线、芯片内部总线

系统总线：在主板上，连接计算机主要部件的总线。分为数据总线、地址总线和控制总线。

#### 系统总线及其分类

**系统总线**是指 CPU、主存、I/O 设备(通过 I/O 接口)各大部件之间的信息传输线。

按系统总线传输信息不同，可分为 3 类:**数据总线、地址总线和控制总线。**

> 每个部件都要连接这三种总线。没有「内存只要连数据总线」之类的说法。

![在这里插入图片描述](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img5/0c7ae5794551424eb55833dfa1f3dfff.png)


:one: **数据总线**: 数据总线是用来传输各个功能部件之间的数据信息，它是**双向**传输总线，其位数与机器字长、存储字长有关。

> **总线宽度**：总线中包含的线的数目，一般为 8 位、16 位或 32 位。
>
> **数据总线的宽度是决定系统性能的关键因素**。一般情况下，数据总线的宽度= 机器字长。这样，CPU 每次取的数据的长度正好适合它处理。
>
> 在此层面上，CPU 所用的“数据”和“指令”并不区分（因为都是 01 字节流，总线不需要理解传输的是什么东西）

:two: **地址总线**：地址总线主要是用来指出数据总线上的数据的来源和去向，用来指明 CPU 欲访问的存储单元或 I/O 端口的地址，由 CPU 输出，是**单向**的。地址总线的宽度决定了系统地址的最大容量。（比如 20 位宽度，则可寻址单元不能多于 4M）

:three: **控制总线**: 控制总线是用来发出各种控制信号的传输线，其传输是**单向**的。（不过对 CPU 而言，它插的控制总线有的是输入的，有的是输出的，所以某种意义上是双向的）典型的控制信号如下：（简单了解即可）

请注意控制总线传输的信号和 CPU 执行的指令是无关的。控制总线只传输总线相关内容；CPU 需要执行的指令通过数据总线传输。

> ●**存储器写**(Memory Write):引起总线上的数据写人被寻址的单元。
>
> ●**存储器读**( Memory Read):使所寻址单元的数据放到总线上。
>
> ●**I/O 写**(I/O Write):引起总线上的数据输出到被寻址的L/O端口。
>
> ●**I/O 读**(I/0 Read): 使被寻址的I/0端口的数据放到总线上。
>
> ●**传输响应**(Transfer ACK):表示数据已经从总线上接收，或已经将数据放到总线上。
>
> ●**总线请求**( Bus Request):表示模块需要获得对总线的控制。
>
> ●**总线允许**( Bus Grant):表示发出请求的模块已经被允许控制线。
>
> ●**中断请求**( Interupl Request): 表示某个中断正在悬而未决。
>
> ●**中断响应**( Iterrupt ACK):未决的中断请求被响应。
>
> ●**时钟(Clock)**:用于同步操作。
>
> ●**复位(Reset**):初始化所有模块。

#### 总线的物理结构

从物理上讲，系统总线实际上是多条平行的电导线。这些导线是在卡或板(印刷电路板).上刻出来的金属线。总线延伸至所有系统部件，每一个系统部件都连接到总线的全部或部分线
![在这里插入图片描述](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img5/69e236d9a3bd44fb8af08d81967b8239.png)

> 总线相互平行，是为了让数据传输时的电磁干扰最小

#### 多总线层次结构|Multiple-bus Hierarchies

单总线结构存在以下的问题：

:one: 总线上连接的设备越多，总线就越长，传输延迟就越大，这些延迟会显著影响性能

:two: 当聚集的传输请求接近总线容量时，总线就会成为瓶颈

所以，大多数计算机都使用多总线层次结构
![在这里插入图片描述](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img5/b2d4d34bc83440c2b29f8d18599b4453.png)

左侧图片为传统的总线结构。CPU 不直接连接主存，而是通过 cache 获得主存信息；主存和 cache 利用总线通信。外部网络、磁盘等设备通过扩展总线连接到系统总线上。这种分层次总线的好处是：I/O 设备工作时不会干扰 CPU 运行。但坏处是：高速设备和低速设备挂在一起（同一条扩展总线），不利于扩展总线的运行。

右侧图片为「高性能总线接口」，增加一条高速总线，专门连接高性能设备；原先的扩展总线仍然存在，且改为间接挂接到新的高速总线上。

高速总线使高需求的设备和处理器有更紧密的集成，同时又使外设独立于处理器

### 总线的设计要素

![在这里插入图片描述](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img5/6b946c4dc51b4855a41c91f39897a04d.png)

#### 总线类型

总线分为两种基本类型：专用的Dedicated Bus和复用的Multiplexed Bus

| 类型     | 专用总线                     | 复用总线                   |
| -------- | ---------------------------- | -------------------------- |
| **举例** | 使用分立专用的数据线和地址线 | 分时复用，共用线路         |
| **优势** | 高吞吐量                     | 布线数量少，节省空间和成本 |
| **缺点** | 规模和成本较高               | 控制更复杂                 |

#### 总线的仲裁方式

总线上的模块可以按照起是否能控制总线，分为主模块和从模块。

- 主模块：是对总线有控制权的模块，可以发起数据传输请求

- 从模块：只能响应主模块发来的总线命令，没有总线控制权。

有多个主模块想要控制总线式，需要通过**仲裁**决定总线控制权的归属。

仲裁方式主要有两种：集中式 centralized 和分布式 distributed

**集中式**：总线控制器/仲裁器的硬件设备负责分配总线时间，可以独立于CPU

常见的集中式总线控制有三种：**链式查询、计数器定时查询、独立请求**;

- 链式查询方式：所有模块的总线请求和响应线是连在一起的，接到总线控制器。任何一个模块发送请求，如果当前总线空闲，排队器都会响应，并返回总线使用许可。使用许可在模块间依次传递，传递到请求总线的模块时，此模块不再传递，并开始使用总线。

  如果模块在总线繁忙时发出使用请求，排队器不会响应。

  优点：连线简单，易于扩充（再接三根线）

  缺点：优先级固定（由于许可信号顺序传递，离控制器越近的模块天然优先级越高）。对电路故障**最敏感**（一个模块连线故障，后侧模块都无法使用）

  ![image-20241001182001342](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAMqZ6DYJhrz0ujECM7GbhmYwFP5PM0AAxgAArSUCFVCQ_SBuFRf_jYE.png)

- 独立请求方式中，每个模块都有自己的一根排队请求线和响应线，全部连接到排队器上。多个模块同时请求总线时，由排队器按照预先设计的优先级决定谁拿到控制权。

  优点：响应速度**最快**，优先级可动态设置。

  缺点：硬件器件用量大，连线多，可扩展性差。

  ![image-20241001181950606](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAMrZ6DYPOrYSpuzywqNROt7JVO2wfYAAgEYAAK0lAhV1qkO_Cj_A5M2BA.png)

- 计数器轮询方式中，不存在链式请求的「总线获取」线，改为设备号线。有设备发出总线请求后，控制器轮询每个设备；如果设备发起了请求且被轮询到，它就可以把总线忙信号置位，其他设备就不能获取总线，直到它用完后再把总线忙复位。

  优点：相对灵活的优先级（控制器可以通过改变轮询顺序动态调整模块的优先级），对电路故障不敏感（一个模块故障，只会导致其不响应轮询，不会影响控制器对其他完好模块的轮询）
  
  缺点：控制相对复杂（设备号线需要 $log_2(设备数量)$ 根），不过没有独立请求复杂。
  
  计数器轮询方式是独立请求和链式查询方式的折中，继承了二者的部分优点。
  
  ![image-20241001182008027](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAMsZ6DYT986jMsLnlc7YDb6-kzY1QwAAgIYAAK0lAhVkowWW_MCV8U2BA.png)

**分布式**：没有中央控制器，每一个模块中包含有访问控制逻辑，分享总线。即每个主模块相互协商。

这两种仲裁方式的目的都是为了指定一个设备（CPU或者I/O）作为主控器，启动与其他设备的数据传输

### 总线的通信控制

目的：获得总线使用权后，解决通信双方如何获取传输的开始/结束的问题。

**总线传输周期**：完成一次总线操作的时间，可以分为四个阶段：

- 申请分配阶段：主模块提出总线申请，总线仲裁通过其使用权
- 寻址阶段：主模块向从模块发出**地址**和**命令**。
- 传数阶段：主模块和从模块交换数据
- 结束阶段：主从模块清除总线上的信息，释放总线

#### 总线通信控制方式

时序是指总线上协调事件的方式，包括同步时序和异步时序、半同步通信与分离式通信

**同步通信**：事件的发生是由统一的时钟信号决定的

控制总线包括时钟信号线。我们把一次1~0传送称为时钟的时钟周期/总线周期。

所有设备均可读取时钟线，且所有事件都在时钟周期开始时发生。

大多数事件占用一个时钟周期。

优点：规定统一，模块配合简单，必须在规定时间完成规定动作。

缺点：所有部件被强制同步，设计时钟只能按照最慢的设备设计，拉低了快速设备的速度。

![在这里插入图片描述](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img5/69d085b76de84dcda2de2d1d48e649d7.png)

**异步通信**：总线一个事件的发生取决于前一个事件的发生，不存在统一的时钟。采用应答方式：主模块发出请求信号后，需要等待从模块返回响应信号，通信才开始。可用于并行/串行传送。

需要增加一条请求线，一条响应线。

> **优点**：无论使高速设备还是低速设备都适用，允许各个设备速度不一致，设计灵活
>
> **缺点**：控制复杂，调试麻烦

![在这里插入图片描述](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img5/ad4325e336e54cd1b886b5ce69f55e57.png)

**半同步通信** 

所有事件必须同步于系统时钟。但是，增加了加“等待”（Wait） 信号线

当 Wait 信号有效时，就采用插入一个时钟（等待）周地等待。

当 Wait 信号无效时，下一时钟周期才为正常周期

此方法允许各种速度模块协调通信、用于连接低速和较大速度差设备。由于存在等待周期，可以让时钟频率稍微高点。

优点：控制比异步方式简单

缺点：时钟频率不能太高

适合系统工作速度不高，但是挂接的设备速度差异很大的系统。

**三者的共同点**：

在整个传输周期中，总线的使用权完全由占有总线的主模块以及由它选中的从模块占据。

比如：以读数据为例

- 主模块发地址、命令：占用总线（总线忙）
- 从模块准备数据：不占用总线（总线空闲）

- 从模块向主模块发数据：占用总线（总线忙）

但是整个过程中，其他设备都不能使用总线。分离式通信利用了从模块准备数据的空闲时间，允许总线在此时间内被其他设备占用。

**分离式通信**

核心思想：将总线周期分为两个子周期

在第一个子周期中，主模块将命令、地址和其他信息发到总线上，从模块接受并保存相关信息，然后主模块放弃总线 

在第二个子周期中，准备好主模块需要的数据的从模块，申请并获得总线使用权，然后占用总线并发送。

> 两个子周期中的主模块和从模块可以不是同一个；第二个子周期总，任何从模块准备好数据后，都可以占用总线发送，不一定非得是第一个子周期里接受数据的从模块。

优点：总线利用率高，避免总线空闲

缺点：控制复杂，一般不用于微机系统；总通信时间更长了。

#### 4、总线宽度与总线带宽

**总线宽度**： 数据总线的宽度对系统性能有影响；地址总线的宽度对系统容量有影响。

**总线带宽**：总线的传输速率。

#### 5、数据传输类型

![在这里插入图片描述](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img5/8eda828d8b974d19956cb8a32b58801f.png)

## PCI

PCI（外设互联总线）：也称为高速I/O总线 ，是一种高带宽、独立于处理器的总线。

PCI是专门为满足现代系统的I/O要求而设计的较为经济的总线，实现它只需要很少的芯片，而且支持将其他总线连到PCI总线上。

1990年英特尔开发，后向公众发布
